// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 17 May 2016 04:23:02 MSK.
// By http://git.io/cgogen. DO NOT EDIT.

package vulkan

/*
#cgo CFLAGS: -I. -DVK_USE_PLATFORM_ANDROID_KHR -DVK_NO_PROTOTYPES -D__ARM_ARCH_7A__
#include "vulkan/vulkan.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// PassRef returns a reference.
func (x PFNAllocationFunction) PassRef() (ref *C.PFN_vkAllocationFunction, allocs *cgoAllocMap) {
	if pFNAllocationFunction9C4C5852Func == nil {
		pFNAllocationFunction9C4C5852Func = x
	}
	return (*C.PFN_vkAllocationFunction)(C.PFN_vkAllocationFunction_9c4c5852), nil
}

// PassValue returns a value.
func (x PFNAllocationFunction) PassValue() (ref C.PFN_vkAllocationFunction, allocs *cgoAllocMap) {
	if pFNAllocationFunction9C4C5852Func == nil {
		pFNAllocationFunction9C4C5852Func = x
	}
	return (C.PFN_vkAllocationFunction)(C.PFN_vkAllocationFunction_9c4c5852), nil
}

//export pFNAllocationFunction9C4C5852
func pFNAllocationFunction9C4C5852(cPUserData unsafe.Pointer, cSize C.size_t, cAlignment C.size_t, cAllocationScope C.VkSystemAllocationScope) unsafe.Pointer {
	if pFNAllocationFunction9C4C5852Func != nil {
		PUserData9c4c5852 := (unsafe.Pointer)(unsafe.Pointer(cPUserData))
		Size9c4c5852 := (uint)(cSize)
		Alignment9c4c5852 := (uint)(cAlignment)
		AllocationScope9c4c5852 := (SystemAllocationScope)(cAllocationScope)
		ret9c4c5852 := pFNAllocationFunction9C4C5852Func(PUserData9c4c5852, Size9c4c5852, Alignment9c4c5852, AllocationScope9c4c5852)
		ret, _ := (unsafe.Pointer)(unsafe.Pointer(ret9c4c5852)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNAllocationFunction9C4C5852Func PFNAllocationFunction

// PassRef returns a reference.
func (x PFNReallocationFunction) PassRef() (ref *C.PFN_vkReallocationFunction, allocs *cgoAllocMap) {
	if pFNReallocationFunction622801D0Func == nil {
		pFNReallocationFunction622801D0Func = x
	}
	return (*C.PFN_vkReallocationFunction)(C.PFN_vkReallocationFunction_622801d0), nil
}

// PassValue returns a value.
func (x PFNReallocationFunction) PassValue() (ref C.PFN_vkReallocationFunction, allocs *cgoAllocMap) {
	if pFNReallocationFunction622801D0Func == nil {
		pFNReallocationFunction622801D0Func = x
	}
	return (C.PFN_vkReallocationFunction)(C.PFN_vkReallocationFunction_622801d0), nil
}

//export pFNReallocationFunction622801D0
func pFNReallocationFunction622801D0(cPUserData unsafe.Pointer, cPOriginal unsafe.Pointer, cSize C.size_t, cAlignment C.size_t, cAllocationScope C.VkSystemAllocationScope) unsafe.Pointer {
	if pFNReallocationFunction622801D0Func != nil {
		PUserData622801d0 := (unsafe.Pointer)(unsafe.Pointer(cPUserData))
		POriginal622801d0 := (unsafe.Pointer)(unsafe.Pointer(cPOriginal))
		Size622801d0 := (uint)(cSize)
		Alignment622801d0 := (uint)(cAlignment)
		AllocationScope622801d0 := (SystemAllocationScope)(cAllocationScope)
		ret622801d0 := pFNReallocationFunction622801D0Func(PUserData622801d0, POriginal622801d0, Size622801d0, Alignment622801d0, AllocationScope622801d0)
		ret, _ := (unsafe.Pointer)(unsafe.Pointer(ret622801d0)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNReallocationFunction622801D0Func PFNReallocationFunction

// PassRef returns a reference.
func (x PFNFreeFunction) PassRef() (ref *C.PFN_vkFreeFunction, allocs *cgoAllocMap) {
	if pFNFreeFunction28EDD2C6Func == nil {
		pFNFreeFunction28EDD2C6Func = x
	}
	return (*C.PFN_vkFreeFunction)(C.PFN_vkFreeFunction_28edd2c6), nil
}

// PassValue returns a value.
func (x PFNFreeFunction) PassValue() (ref C.PFN_vkFreeFunction, allocs *cgoAllocMap) {
	if pFNFreeFunction28EDD2C6Func == nil {
		pFNFreeFunction28EDD2C6Func = x
	}
	return (C.PFN_vkFreeFunction)(C.PFN_vkFreeFunction_28edd2c6), nil
}

//export pFNFreeFunction28EDD2C6
func pFNFreeFunction28EDD2C6(cPUserData unsafe.Pointer, cPMemory unsafe.Pointer) {
	if pFNFreeFunction28EDD2C6Func != nil {
		PUserData28edd2c6 := (unsafe.Pointer)(unsafe.Pointer(cPUserData))
		PMemory28edd2c6 := (unsafe.Pointer)(unsafe.Pointer(cPMemory))
		pFNFreeFunction28EDD2C6Func(PUserData28edd2c6, PMemory28edd2c6)
	}
	panic("callback func has not been set (race?)")
}

var pFNFreeFunction28EDD2C6Func PFNFreeFunction

// PassRef returns a reference.
func (x PFNInternalAllocationNotification) PassRef() (ref *C.PFN_vkInternalAllocationNotification, allocs *cgoAllocMap) {
	if pFNInternalAllocationNotificationEADF4B16Func == nil {
		pFNInternalAllocationNotificationEADF4B16Func = x
	}
	return (*C.PFN_vkInternalAllocationNotification)(C.PFN_vkInternalAllocationNotification_eadf4b16), nil
}

// PassValue returns a value.
func (x PFNInternalAllocationNotification) PassValue() (ref C.PFN_vkInternalAllocationNotification, allocs *cgoAllocMap) {
	if pFNInternalAllocationNotificationEADF4B16Func == nil {
		pFNInternalAllocationNotificationEADF4B16Func = x
	}
	return (C.PFN_vkInternalAllocationNotification)(C.PFN_vkInternalAllocationNotification_eadf4b16), nil
}

//export pFNInternalAllocationNotificationEADF4B16
func pFNInternalAllocationNotificationEADF4B16(cPUserData unsafe.Pointer, cSize C.size_t, cAllocationType C.VkInternalAllocationType, cAllocationScope C.VkSystemAllocationScope) {
	if pFNInternalAllocationNotificationEADF4B16Func != nil {
		PUserDataeadf4b16 := (unsafe.Pointer)(unsafe.Pointer(cPUserData))
		Sizeeadf4b16 := (uint)(cSize)
		AllocationTypeeadf4b16 := (InternalAllocationType)(cAllocationType)
		AllocationScopeeadf4b16 := (SystemAllocationScope)(cAllocationScope)
		pFNInternalAllocationNotificationEADF4B16Func(PUserDataeadf4b16, Sizeeadf4b16, AllocationTypeeadf4b16, AllocationScopeeadf4b16)
	}
	panic("callback func has not been set (race?)")
}

var pFNInternalAllocationNotificationEADF4B16Func PFNInternalAllocationNotification

// PassRef returns a reference.
func (x PFNInternalFreeNotification) PassRef() (ref *C.PFN_vkInternalFreeNotification, allocs *cgoAllocMap) {
	if pFNInternalFreeNotificationCE87D96Func == nil {
		pFNInternalFreeNotificationCE87D96Func = x
	}
	return (*C.PFN_vkInternalFreeNotification)(C.PFN_vkInternalFreeNotification_ce87d96), nil
}

// PassValue returns a value.
func (x PFNInternalFreeNotification) PassValue() (ref C.PFN_vkInternalFreeNotification, allocs *cgoAllocMap) {
	if pFNInternalFreeNotificationCE87D96Func == nil {
		pFNInternalFreeNotificationCE87D96Func = x
	}
	return (C.PFN_vkInternalFreeNotification)(C.PFN_vkInternalFreeNotification_ce87d96), nil
}

//export pFNInternalFreeNotificationCE87D96
func pFNInternalFreeNotificationCE87D96(cPUserData unsafe.Pointer, cSize C.size_t, cAllocationType C.VkInternalAllocationType, cAllocationScope C.VkSystemAllocationScope) {
	if pFNInternalFreeNotificationCE87D96Func != nil {
		PUserDatace87d96 := (unsafe.Pointer)(unsafe.Pointer(cPUserData))
		Sizece87d96 := (uint)(cSize)
		AllocationTypece87d96 := (InternalAllocationType)(cAllocationType)
		AllocationScopece87d96 := (SystemAllocationScope)(cAllocationScope)
		pFNInternalFreeNotificationCE87D96Func(PUserDatace87d96, Sizece87d96, AllocationTypece87d96, AllocationScopece87d96)
	}
	panic("callback func has not been set (race?)")
}

var pFNInternalFreeNotificationCE87D96Func PFNInternalFreeNotification

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocApplicationInfoMemory allocates memory for type C.VkApplicationInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocApplicationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfApplicationInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfApplicationInfoValue = unsafe.Sizeof([1]C.VkApplicationInfo{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

// Ref returns a reference.
func (x *ApplicationInfo) Ref() *C.VkApplicationInfo {
	if x == nil {
		return nil
	}
	return x.refb0af7378
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ApplicationInfo) Free() {
	if x != nil && x.allocsb0af7378 != nil {
		x.allocsb0af7378.(*cgoAllocMap).Free()
		x.refb0af7378 = nil
	}
}

// NewApplicationInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewApplicationInfoRef(ref *C.VkApplicationInfo) *ApplicationInfo {
	if ref == nil {
		return nil
	}
	obj := new(ApplicationInfo)
	obj.refb0af7378 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ApplicationInfo) PassRef() (*C.VkApplicationInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0af7378 != nil {
		return x.refb0af7378, nil
	}
	memb0af7378 := allocApplicationInfoMemory(1)
	refb0af7378 := (*C.VkApplicationInfo)(memb0af7378)
	allocsb0af7378 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refb0af7378.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb0af7378.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb0af7378.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb0af7378.Borrow(cpNext_allocs)

	var cpApplicationName_allocs *cgoAllocMap
	refb0af7378.pApplicationName, cpApplicationName_allocs = unpackPCharString(x.PApplicationName)
	allocsb0af7378.Borrow(cpApplicationName_allocs)

	var capplicationVersion_allocs *cgoAllocMap
	refb0af7378.applicationVersion, capplicationVersion_allocs = (C.uint32_t)(x.ApplicationVersion), cgoAllocsUnknown
	allocsb0af7378.Borrow(capplicationVersion_allocs)

	var cpEngineName_allocs *cgoAllocMap
	refb0af7378.pEngineName, cpEngineName_allocs = unpackPCharString(x.PEngineName)
	allocsb0af7378.Borrow(cpEngineName_allocs)

	var cengineVersion_allocs *cgoAllocMap
	refb0af7378.engineVersion, cengineVersion_allocs = (C.uint32_t)(x.EngineVersion), cgoAllocsUnknown
	allocsb0af7378.Borrow(cengineVersion_allocs)

	var capiVersion_allocs *cgoAllocMap
	refb0af7378.apiVersion, capiVersion_allocs = (C.uint32_t)(x.ApiVersion), cgoAllocsUnknown
	allocsb0af7378.Borrow(capiVersion_allocs)

	x.refb0af7378 = refb0af7378
	x.allocsb0af7378 = allocsb0af7378
	return refb0af7378, allocsb0af7378

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ApplicationInfo) PassValue() (C.VkApplicationInfo, *cgoAllocMap) {
	if x == nil {
		x = NewApplicationInfoRef(nil)
	} else if x.refb0af7378 != nil {
		return *x.refb0af7378, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ApplicationInfo) Deref() {
	if x.refb0af7378 == nil {
		return
	}
	x.SType = (StructureType)(x.refb0af7378.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb0af7378.pNext))
	x.PApplicationName = packPCharString(x.refb0af7378.pApplicationName)
	x.ApplicationVersion = (uint32)(x.refb0af7378.applicationVersion)
	x.PEngineName = packPCharString(x.refb0af7378.pEngineName)
	x.EngineVersion = (uint32)(x.refb0af7378.engineVersion)
	x.ApiVersion = (uint32)(x.refb0af7378.apiVersion)
}

// allocInstanceCreateInfoMemory allocates memory for type C.VkInstanceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInstanceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInstanceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfInstanceCreateInfoValue = unsafe.Sizeof([1]C.VkInstanceCreateInfo{})

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSApplicationInfo transforms a sliced Go data structure into plain C format.
func unpackSApplicationInfo(x []ApplicationInfo) (unpacked *C.VkApplicationInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkApplicationInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocApplicationInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkApplicationInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkApplicationInfo)(unsafe.Pointer(h.Data))
	return
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(unsafe.Pointer(h.Data))
	return
}

// packSApplicationInfo reads sliced Go data structure out from plain C format.
func packSApplicationInfo(v []ApplicationInfo, ptr0 *C.VkApplicationInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfApplicationInfoValue]C.VkApplicationInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewApplicationInfoRef(&ptr1)
	}
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// Ref returns a reference.
func (x *InstanceCreateInfo) Ref() *C.VkInstanceCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref9b760798
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *InstanceCreateInfo) Free() {
	if x != nil && x.allocs9b760798 != nil {
		x.allocs9b760798.(*cgoAllocMap).Free()
		x.ref9b760798 = nil
	}
}

// NewInstanceCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewInstanceCreateInfoRef(ref *C.VkInstanceCreateInfo) *InstanceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(InstanceCreateInfo)
	obj.ref9b760798 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *InstanceCreateInfo) PassRef() (*C.VkInstanceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9b760798 != nil {
		return x.ref9b760798, nil
	}
	mem9b760798 := allocInstanceCreateInfoMemory(1)
	ref9b760798 := (*C.VkInstanceCreateInfo)(mem9b760798)
	allocs9b760798 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref9b760798.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9b760798.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9b760798.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9b760798.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref9b760798.flags, cflags_allocs = (C.VkInstanceCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs9b760798.Borrow(cflags_allocs)

	var cpApplicationInfo_allocs *cgoAllocMap
	ref9b760798.pApplicationInfo, cpApplicationInfo_allocs = unpackSApplicationInfo(x.PApplicationInfo)
	allocs9b760798.Borrow(cpApplicationInfo_allocs)

	var cenabledLayerCount_allocs *cgoAllocMap
	ref9b760798.enabledLayerCount, cenabledLayerCount_allocs = (C.uint32_t)(x.EnabledLayerCount), cgoAllocsUnknown
	allocs9b760798.Borrow(cenabledLayerCount_allocs)

	var cppEnabledLayerNames_allocs *cgoAllocMap
	ref9b760798.ppEnabledLayerNames, cppEnabledLayerNames_allocs = unpackSString(x.PpEnabledLayerNames)
	allocs9b760798.Borrow(cppEnabledLayerNames_allocs)

	var cenabledExtensionCount_allocs *cgoAllocMap
	ref9b760798.enabledExtensionCount, cenabledExtensionCount_allocs = (C.uint32_t)(x.EnabledExtensionCount), cgoAllocsUnknown
	allocs9b760798.Borrow(cenabledExtensionCount_allocs)

	var cppEnabledExtensionNames_allocs *cgoAllocMap
	ref9b760798.ppEnabledExtensionNames, cppEnabledExtensionNames_allocs = unpackSString(x.PpEnabledExtensionNames)
	allocs9b760798.Borrow(cppEnabledExtensionNames_allocs)

	x.ref9b760798 = ref9b760798
	x.allocs9b760798 = allocs9b760798
	return ref9b760798, allocs9b760798

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *InstanceCreateInfo) PassValue() (C.VkInstanceCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewInstanceCreateInfoRef(nil)
	} else if x.ref9b760798 != nil {
		return *x.ref9b760798, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *InstanceCreateInfo) Deref() {
	if x.ref9b760798 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9b760798.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9b760798.pNext))
	x.Flags = (InstanceCreateFlags)(x.ref9b760798.flags)
	packSApplicationInfo(x.PApplicationInfo, x.ref9b760798.pApplicationInfo)
	x.EnabledLayerCount = (uint32)(x.ref9b760798.enabledLayerCount)
	packSString(x.PpEnabledLayerNames, x.ref9b760798.ppEnabledLayerNames)
	x.EnabledExtensionCount = (uint32)(x.ref9b760798.enabledExtensionCount)
	packSString(x.PpEnabledExtensionNames, x.ref9b760798.ppEnabledExtensionNames)
}

// allocAllocationCallbacksMemory allocates memory for type C.VkAllocationCallbacks in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAllocationCallbacksMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAllocationCallbacksValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAllocationCallbacksValue = unsafe.Sizeof([1]C.VkAllocationCallbacks{})

// Ref returns a reference.
func (x *AllocationCallbacks) Ref() *C.VkAllocationCallbacks {
	if x == nil {
		return nil
	}
	return x.ref9638e01
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *AllocationCallbacks) Free() {
	if x != nil && x.allocs9638e01 != nil {
		x.allocs9638e01.(*cgoAllocMap).Free()
		x.ref9638e01 = nil
	}
}

// NewAllocationCallbacksRef initialises a new struct holding the reference to the originaitng C struct.
func NewAllocationCallbacksRef(ref *C.VkAllocationCallbacks) *AllocationCallbacks {
	if ref == nil {
		return nil
	}
	obj := new(AllocationCallbacks)
	obj.ref9638e01 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *AllocationCallbacks) PassRef() (*C.VkAllocationCallbacks, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9638e01 != nil {
		return x.ref9638e01, nil
	}
	mem9638e01 := allocAllocationCallbacksMemory(1)
	ref9638e01 := (*C.VkAllocationCallbacks)(mem9638e01)
	allocs9638e01 := new(cgoAllocMap)
	var cpUserData_allocs *cgoAllocMap
	ref9638e01.pUserData, cpUserData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PUserData)), cgoAllocsUnknown
	allocs9638e01.Borrow(cpUserData_allocs)

	var cpfnAllocation_allocs *cgoAllocMap
	ref9638e01.pfnAllocation, cpfnAllocation_allocs = x.PfnAllocation.PassValue()
	allocs9638e01.Borrow(cpfnAllocation_allocs)

	var cpfnReallocation_allocs *cgoAllocMap
	ref9638e01.pfnReallocation, cpfnReallocation_allocs = x.PfnReallocation.PassValue()
	allocs9638e01.Borrow(cpfnReallocation_allocs)

	var cpfnFree_allocs *cgoAllocMap
	ref9638e01.pfnFree, cpfnFree_allocs = x.PfnFree.PassValue()
	allocs9638e01.Borrow(cpfnFree_allocs)

	var cpfnInternalAllocation_allocs *cgoAllocMap
	ref9638e01.pfnInternalAllocation, cpfnInternalAllocation_allocs = x.PfnInternalAllocation.PassValue()
	allocs9638e01.Borrow(cpfnInternalAllocation_allocs)

	var cpfnInternalFree_allocs *cgoAllocMap
	ref9638e01.pfnInternalFree, cpfnInternalFree_allocs = x.PfnInternalFree.PassValue()
	allocs9638e01.Borrow(cpfnInternalFree_allocs)

	x.ref9638e01 = ref9638e01
	x.allocs9638e01 = allocs9638e01
	return ref9638e01, allocs9638e01

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *AllocationCallbacks) PassValue() (C.VkAllocationCallbacks, *cgoAllocMap) {
	if x == nil {
		x = NewAllocationCallbacksRef(nil)
	} else if x.ref9638e01 != nil {
		return *x.ref9638e01, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *AllocationCallbacks) Deref() {
	if x.ref9638e01 == nil {
		return
	}
	x.PUserData = (unsafe.Pointer)(unsafe.Pointer(x.ref9638e01.pUserData))
	// x.PfnAllocation is a callback func
	// x.PfnReallocation is a callback func
	// x.PfnFree is a callback func
	// x.PfnInternalAllocation is a callback func
	// x.PfnInternalFree is a callback func
}

// allocPhysicalDeviceFeaturesMemory allocates memory for type C.VkPhysicalDeviceFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFeatures{})

// Ref returns a reference.
func (x *PhysicalDeviceFeatures) Ref() *C.VkPhysicalDeviceFeatures {
	if x == nil {
		return nil
	}
	return x.reff97e405d
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PhysicalDeviceFeatures) Free() {
	if x != nil && x.allocsf97e405d != nil {
		x.allocsf97e405d.(*cgoAllocMap).Free()
		x.reff97e405d = nil
	}
}

// NewPhysicalDeviceFeaturesRef initialises a new struct holding the reference to the originaitng C struct.
func NewPhysicalDeviceFeaturesRef(ref *C.VkPhysicalDeviceFeatures) *PhysicalDeviceFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFeatures)
	obj.reff97e405d = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PhysicalDeviceFeatures) PassRef() (*C.VkPhysicalDeviceFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff97e405d != nil {
		return x.reff97e405d, nil
	}
	memf97e405d := allocPhysicalDeviceFeaturesMemory(1)
	reff97e405d := (*C.VkPhysicalDeviceFeatures)(memf97e405d)
	allocsf97e405d := new(cgoAllocMap)
	var crobustBufferAccess_allocs *cgoAllocMap
	reff97e405d.robustBufferAccess, crobustBufferAccess_allocs = (C.VkBool32)(x.RobustBufferAccess), cgoAllocsUnknown
	allocsf97e405d.Borrow(crobustBufferAccess_allocs)

	var cfullDrawIndexUint32_allocs *cgoAllocMap
	reff97e405d.fullDrawIndexUint32, cfullDrawIndexUint32_allocs = (C.VkBool32)(x.FullDrawIndexUint32), cgoAllocsUnknown
	allocsf97e405d.Borrow(cfullDrawIndexUint32_allocs)

	var cimageCubeArray_allocs *cgoAllocMap
	reff97e405d.imageCubeArray, cimageCubeArray_allocs = (C.VkBool32)(x.ImageCubeArray), cgoAllocsUnknown
	allocsf97e405d.Borrow(cimageCubeArray_allocs)

	var cindependentBlend_allocs *cgoAllocMap
	reff97e405d.independentBlend, cindependentBlend_allocs = (C.VkBool32)(x.IndependentBlend), cgoAllocsUnknown
	allocsf97e405d.Borrow(cindependentBlend_allocs)

	var cgeometryShader_allocs *cgoAllocMap
	reff97e405d.geometryShader, cgeometryShader_allocs = (C.VkBool32)(x.GeometryShader), cgoAllocsUnknown
	allocsf97e405d.Borrow(cgeometryShader_allocs)

	var ctessellationShader_allocs *cgoAllocMap
	reff97e405d.tessellationShader, ctessellationShader_allocs = (C.VkBool32)(x.TessellationShader), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctessellationShader_allocs)

	var csampleRateShading_allocs *cgoAllocMap
	reff97e405d.sampleRateShading, csampleRateShading_allocs = (C.VkBool32)(x.SampleRateShading), cgoAllocsUnknown
	allocsf97e405d.Borrow(csampleRateShading_allocs)

	var cdualSrcBlend_allocs *cgoAllocMap
	reff97e405d.dualSrcBlend, cdualSrcBlend_allocs = (C.VkBool32)(x.DualSrcBlend), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdualSrcBlend_allocs)

	var clogicOp_allocs *cgoAllocMap
	reff97e405d.logicOp, clogicOp_allocs = (C.VkBool32)(x.LogicOp), cgoAllocsUnknown
	allocsf97e405d.Borrow(clogicOp_allocs)

	var cmultiDrawIndirect_allocs *cgoAllocMap
	reff97e405d.multiDrawIndirect, cmultiDrawIndirect_allocs = (C.VkBool32)(x.MultiDrawIndirect), cgoAllocsUnknown
	allocsf97e405d.Borrow(cmultiDrawIndirect_allocs)

	var cdrawIndirectFirstInstance_allocs *cgoAllocMap
	reff97e405d.drawIndirectFirstInstance, cdrawIndirectFirstInstance_allocs = (C.VkBool32)(x.DrawIndirectFirstInstance), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdrawIndirectFirstInstance_allocs)

	var cdepthClamp_allocs *cgoAllocMap
	reff97e405d.depthClamp, cdepthClamp_allocs = (C.VkBool32)(x.DepthClamp), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdepthClamp_allocs)

	var cdepthBiasClamp_allocs *cgoAllocMap
	reff97e405d.depthBiasClamp, cdepthBiasClamp_allocs = (C.VkBool32)(x.DepthBiasClamp), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdepthBiasClamp_allocs)

	var cfillModeNonSolid_allocs *cgoAllocMap
	reff97e405d.fillModeNonSolid, cfillModeNonSolid_allocs = (C.VkBool32)(x.FillModeNonSolid), cgoAllocsUnknown
	allocsf97e405d.Borrow(cfillModeNonSolid_allocs)

	var cdepthBounds_allocs *cgoAllocMap
	reff97e405d.depthBounds, cdepthBounds_allocs = (C.VkBool32)(x.DepthBounds), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdepthBounds_allocs)

	var cwideLines_allocs *cgoAllocMap
	reff97e405d.wideLines, cwideLines_allocs = (C.VkBool32)(x.WideLines), cgoAllocsUnknown
	allocsf97e405d.Borrow(cwideLines_allocs)

	var clargePoints_allocs *cgoAllocMap
	reff97e405d.largePoints, clargePoints_allocs = (C.VkBool32)(x.LargePoints), cgoAllocsUnknown
	allocsf97e405d.Borrow(clargePoints_allocs)

	var calphaToOne_allocs *cgoAllocMap
	reff97e405d.alphaToOne, calphaToOne_allocs = (C.VkBool32)(x.AlphaToOne), cgoAllocsUnknown
	allocsf97e405d.Borrow(calphaToOne_allocs)

	var cmultiViewport_allocs *cgoAllocMap
	reff97e405d.multiViewport, cmultiViewport_allocs = (C.VkBool32)(x.MultiViewport), cgoAllocsUnknown
	allocsf97e405d.Borrow(cmultiViewport_allocs)

	var csamplerAnisotropy_allocs *cgoAllocMap
	reff97e405d.samplerAnisotropy, csamplerAnisotropy_allocs = (C.VkBool32)(x.SamplerAnisotropy), cgoAllocsUnknown
	allocsf97e405d.Borrow(csamplerAnisotropy_allocs)

	var ctextureCompressionETC2_allocs *cgoAllocMap
	reff97e405d.textureCompressionETC2, ctextureCompressionETC2_allocs = (C.VkBool32)(x.TextureCompressionETC2), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctextureCompressionETC2_allocs)

	var ctextureCompressionASTC_LDR_allocs *cgoAllocMap
	reff97e405d.textureCompressionASTC_LDR, ctextureCompressionASTC_LDR_allocs = (C.VkBool32)(x.TextureCompressionASTC_LDR), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctextureCompressionASTC_LDR_allocs)

	var ctextureCompressionBC_allocs *cgoAllocMap
	reff97e405d.textureCompressionBC, ctextureCompressionBC_allocs = (C.VkBool32)(x.TextureCompressionBC), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctextureCompressionBC_allocs)

	var cocclusionQueryPrecise_allocs *cgoAllocMap
	reff97e405d.occlusionQueryPrecise, cocclusionQueryPrecise_allocs = (C.VkBool32)(x.OcclusionQueryPrecise), cgoAllocsUnknown
	allocsf97e405d.Borrow(cocclusionQueryPrecise_allocs)

	var cpipelineStatisticsQuery_allocs *cgoAllocMap
	reff97e405d.pipelineStatisticsQuery, cpipelineStatisticsQuery_allocs = (C.VkBool32)(x.PipelineStatisticsQuery), cgoAllocsUnknown
	allocsf97e405d.Borrow(cpipelineStatisticsQuery_allocs)

	var cvertexPipelineStoresAndAtomics_allocs *cgoAllocMap
	reff97e405d.vertexPipelineStoresAndAtomics, cvertexPipelineStoresAndAtomics_allocs = (C.VkBool32)(x.VertexPipelineStoresAndAtomics), cgoAllocsUnknown
	allocsf97e405d.Borrow(cvertexPipelineStoresAndAtomics_allocs)

	var cfragmentStoresAndAtomics_allocs *cgoAllocMap
	reff97e405d.fragmentStoresAndAtomics, cfragmentStoresAndAtomics_allocs = (C.VkBool32)(x.FragmentStoresAndAtomics), cgoAllocsUnknown
	allocsf97e405d.Borrow(cfragmentStoresAndAtomics_allocs)

	var cshaderTessellationAndGeometryPointSize_allocs *cgoAllocMap
	reff97e405d.shaderTessellationAndGeometryPointSize, cshaderTessellationAndGeometryPointSize_allocs = (C.VkBool32)(x.ShaderTessellationAndGeometryPointSize), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderTessellationAndGeometryPointSize_allocs)

	var cshaderImageGatherExtended_allocs *cgoAllocMap
	reff97e405d.shaderImageGatherExtended, cshaderImageGatherExtended_allocs = (C.VkBool32)(x.ShaderImageGatherExtended), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderImageGatherExtended_allocs)

	var cshaderStorageImageExtendedFormats_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageExtendedFormats, cshaderStorageImageExtendedFormats_allocs = (C.VkBool32)(x.ShaderStorageImageExtendedFormats), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageExtendedFormats_allocs)

	var cshaderStorageImageMultisample_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageMultisample, cshaderStorageImageMultisample_allocs = (C.VkBool32)(x.ShaderStorageImageMultisample), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageMultisample_allocs)

	var cshaderStorageImageReadWithoutFormat_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageReadWithoutFormat, cshaderStorageImageReadWithoutFormat_allocs = (C.VkBool32)(x.ShaderStorageImageReadWithoutFormat), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageReadWithoutFormat_allocs)

	var cshaderStorageImageWriteWithoutFormat_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageWriteWithoutFormat, cshaderStorageImageWriteWithoutFormat_allocs = (C.VkBool32)(x.ShaderStorageImageWriteWithoutFormat), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageWriteWithoutFormat_allocs)

	var cshaderUniformBufferArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderUniformBufferArrayDynamicIndexing, cshaderUniformBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderUniformBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderUniformBufferArrayDynamicIndexing_allocs)

	var cshaderSampledImageArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderSampledImageArrayDynamicIndexing, cshaderSampledImageArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderSampledImageArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderSampledImageArrayDynamicIndexing_allocs)

	var cshaderStorageBufferArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderStorageBufferArrayDynamicIndexing, cshaderStorageBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderStorageBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageBufferArrayDynamicIndexing_allocs)

	var cshaderStorageImageArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageArrayDynamicIndexing, cshaderStorageImageArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderStorageImageArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageArrayDynamicIndexing_allocs)

	var cshaderClipDistance_allocs *cgoAllocMap
	reff97e405d.shaderClipDistance, cshaderClipDistance_allocs = (C.VkBool32)(x.ShaderClipDistance), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderClipDistance_allocs)

	var cshaderCullDistance_allocs *cgoAllocMap
	reff97e405d.shaderCullDistance, cshaderCullDistance_allocs = (C.VkBool32)(x.ShaderCullDistance), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderCullDistance_allocs)

	var cshaderFloat64_allocs *cgoAllocMap
	reff97e405d.shaderFloat64, cshaderFloat64_allocs = (C.VkBool32)(x.ShaderFloat64), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderFloat64_allocs)

	var cshaderInt64_allocs *cgoAllocMap
	reff97e405d.shaderInt64, cshaderInt64_allocs = (C.VkBool32)(x.ShaderInt64), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderInt64_allocs)

	var cshaderInt16_allocs *cgoAllocMap
	reff97e405d.shaderInt16, cshaderInt16_allocs = (C.VkBool32)(x.ShaderInt16), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderInt16_allocs)

	var cshaderResourceResidency_allocs *cgoAllocMap
	reff97e405d.shaderResourceResidency, cshaderResourceResidency_allocs = (C.VkBool32)(x.ShaderResourceResidency), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderResourceResidency_allocs)

	var cshaderResourceMinLod_allocs *cgoAllocMap
	reff97e405d.shaderResourceMinLod, cshaderResourceMinLod_allocs = (C.VkBool32)(x.ShaderResourceMinLod), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderResourceMinLod_allocs)

	var csparseBinding_allocs *cgoAllocMap
	reff97e405d.sparseBinding, csparseBinding_allocs = (C.VkBool32)(x.SparseBinding), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseBinding_allocs)

	var csparseResidencyBuffer_allocs *cgoAllocMap
	reff97e405d.sparseResidencyBuffer, csparseResidencyBuffer_allocs = (C.VkBool32)(x.SparseResidencyBuffer), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyBuffer_allocs)

	var csparseResidencyImage2D_allocs *cgoAllocMap
	reff97e405d.sparseResidencyImage2D, csparseResidencyImage2D_allocs = (C.VkBool32)(x.SparseResidencyImage2D), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyImage2D_allocs)

	var csparseResidencyImage3D_allocs *cgoAllocMap
	reff97e405d.sparseResidencyImage3D, csparseResidencyImage3D_allocs = (C.VkBool32)(x.SparseResidencyImage3D), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyImage3D_allocs)

	var csparseResidency2Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency2Samples, csparseResidency2Samples_allocs = (C.VkBool32)(x.SparseResidency2Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency2Samples_allocs)

	var csparseResidency4Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency4Samples, csparseResidency4Samples_allocs = (C.VkBool32)(x.SparseResidency4Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency4Samples_allocs)

	var csparseResidency8Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency8Samples, csparseResidency8Samples_allocs = (C.VkBool32)(x.SparseResidency8Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency8Samples_allocs)

	var csparseResidency16Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency16Samples, csparseResidency16Samples_allocs = (C.VkBool32)(x.SparseResidency16Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency16Samples_allocs)

	var csparseResidencyAliased_allocs *cgoAllocMap
	reff97e405d.sparseResidencyAliased, csparseResidencyAliased_allocs = (C.VkBool32)(x.SparseResidencyAliased), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyAliased_allocs)

	var cvariableMultisampleRate_allocs *cgoAllocMap
	reff97e405d.variableMultisampleRate, cvariableMultisampleRate_allocs = (C.VkBool32)(x.VariableMultisampleRate), cgoAllocsUnknown
	allocsf97e405d.Borrow(cvariableMultisampleRate_allocs)

	var cinheritedQueries_allocs *cgoAllocMap
	reff97e405d.inheritedQueries, cinheritedQueries_allocs = (C.VkBool32)(x.InheritedQueries), cgoAllocsUnknown
	allocsf97e405d.Borrow(cinheritedQueries_allocs)

	x.reff97e405d = reff97e405d
	x.allocsf97e405d = allocsf97e405d
	return reff97e405d, allocsf97e405d

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PhysicalDeviceFeatures) PassValue() (C.VkPhysicalDeviceFeatures, *cgoAllocMap) {
	if x == nil {
		x = NewPhysicalDeviceFeaturesRef(nil)
	} else if x.reff97e405d != nil {
		return *x.reff97e405d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PhysicalDeviceFeatures) Deref() {
	if x.reff97e405d == nil {
		return
	}
	x.RobustBufferAccess = (Bool32)(x.reff97e405d.robustBufferAccess)
	x.FullDrawIndexUint32 = (Bool32)(x.reff97e405d.fullDrawIndexUint32)
	x.ImageCubeArray = (Bool32)(x.reff97e405d.imageCubeArray)
	x.IndependentBlend = (Bool32)(x.reff97e405d.independentBlend)
	x.GeometryShader = (Bool32)(x.reff97e405d.geometryShader)
	x.TessellationShader = (Bool32)(x.reff97e405d.tessellationShader)
	x.SampleRateShading = (Bool32)(x.reff97e405d.sampleRateShading)
	x.DualSrcBlend = (Bool32)(x.reff97e405d.dualSrcBlend)
	x.LogicOp = (Bool32)(x.reff97e405d.logicOp)
	x.MultiDrawIndirect = (Bool32)(x.reff97e405d.multiDrawIndirect)
	x.DrawIndirectFirstInstance = (Bool32)(x.reff97e405d.drawIndirectFirstInstance)
	x.DepthClamp = (Bool32)(x.reff97e405d.depthClamp)
	x.DepthBiasClamp = (Bool32)(x.reff97e405d.depthBiasClamp)
	x.FillModeNonSolid = (Bool32)(x.reff97e405d.fillModeNonSolid)
	x.DepthBounds = (Bool32)(x.reff97e405d.depthBounds)
	x.WideLines = (Bool32)(x.reff97e405d.wideLines)
	x.LargePoints = (Bool32)(x.reff97e405d.largePoints)
	x.AlphaToOne = (Bool32)(x.reff97e405d.alphaToOne)
	x.MultiViewport = (Bool32)(x.reff97e405d.multiViewport)
	x.SamplerAnisotropy = (Bool32)(x.reff97e405d.samplerAnisotropy)
	x.TextureCompressionETC2 = (Bool32)(x.reff97e405d.textureCompressionETC2)
	x.TextureCompressionASTC_LDR = (Bool32)(x.reff97e405d.textureCompressionASTC_LDR)
	x.TextureCompressionBC = (Bool32)(x.reff97e405d.textureCompressionBC)
	x.OcclusionQueryPrecise = (Bool32)(x.reff97e405d.occlusionQueryPrecise)
	x.PipelineStatisticsQuery = (Bool32)(x.reff97e405d.pipelineStatisticsQuery)
	x.VertexPipelineStoresAndAtomics = (Bool32)(x.reff97e405d.vertexPipelineStoresAndAtomics)
	x.FragmentStoresAndAtomics = (Bool32)(x.reff97e405d.fragmentStoresAndAtomics)
	x.ShaderTessellationAndGeometryPointSize = (Bool32)(x.reff97e405d.shaderTessellationAndGeometryPointSize)
	x.ShaderImageGatherExtended = (Bool32)(x.reff97e405d.shaderImageGatherExtended)
	x.ShaderStorageImageExtendedFormats = (Bool32)(x.reff97e405d.shaderStorageImageExtendedFormats)
	x.ShaderStorageImageMultisample = (Bool32)(x.reff97e405d.shaderStorageImageMultisample)
	x.ShaderStorageImageReadWithoutFormat = (Bool32)(x.reff97e405d.shaderStorageImageReadWithoutFormat)
	x.ShaderStorageImageWriteWithoutFormat = (Bool32)(x.reff97e405d.shaderStorageImageWriteWithoutFormat)
	x.ShaderUniformBufferArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderUniformBufferArrayDynamicIndexing)
	x.ShaderSampledImageArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderSampledImageArrayDynamicIndexing)
	x.ShaderStorageBufferArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderStorageBufferArrayDynamicIndexing)
	x.ShaderStorageImageArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderStorageImageArrayDynamicIndexing)
	x.ShaderClipDistance = (Bool32)(x.reff97e405d.shaderClipDistance)
	x.ShaderCullDistance = (Bool32)(x.reff97e405d.shaderCullDistance)
	x.ShaderFloat64 = (Bool32)(x.reff97e405d.shaderFloat64)
	x.ShaderInt64 = (Bool32)(x.reff97e405d.shaderInt64)
	x.ShaderInt16 = (Bool32)(x.reff97e405d.shaderInt16)
	x.ShaderResourceResidency = (Bool32)(x.reff97e405d.shaderResourceResidency)
	x.ShaderResourceMinLod = (Bool32)(x.reff97e405d.shaderResourceMinLod)
	x.SparseBinding = (Bool32)(x.reff97e405d.sparseBinding)
	x.SparseResidencyBuffer = (Bool32)(x.reff97e405d.sparseResidencyBuffer)
	x.SparseResidencyImage2D = (Bool32)(x.reff97e405d.sparseResidencyImage2D)
	x.SparseResidencyImage3D = (Bool32)(x.reff97e405d.sparseResidencyImage3D)
	x.SparseResidency2Samples = (Bool32)(x.reff97e405d.sparseResidency2Samples)
	x.SparseResidency4Samples = (Bool32)(x.reff97e405d.sparseResidency4Samples)
	x.SparseResidency8Samples = (Bool32)(x.reff97e405d.sparseResidency8Samples)
	x.SparseResidency16Samples = (Bool32)(x.reff97e405d.sparseResidency16Samples)
	x.SparseResidencyAliased = (Bool32)(x.reff97e405d.sparseResidencyAliased)
	x.VariableMultisampleRate = (Bool32)(x.reff97e405d.variableMultisampleRate)
	x.InheritedQueries = (Bool32)(x.reff97e405d.inheritedQueries)
}

// allocFormatPropertiesMemory allocates memory for type C.VkFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFormatPropertiesValue = unsafe.Sizeof([1]C.VkFormatProperties{})

// Ref returns a reference.
func (x *FormatProperties) Ref() *C.VkFormatProperties {
	if x == nil {
		return nil
	}
	return x.refc4b9937b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *FormatProperties) Free() {
	if x != nil && x.allocsc4b9937b != nil {
		x.allocsc4b9937b.(*cgoAllocMap).Free()
		x.refc4b9937b = nil
	}
}

// NewFormatPropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewFormatPropertiesRef(ref *C.VkFormatProperties) *FormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(FormatProperties)
	obj.refc4b9937b = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *FormatProperties) PassRef() (*C.VkFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc4b9937b != nil {
		return x.refc4b9937b, nil
	}
	memc4b9937b := allocFormatPropertiesMemory(1)
	refc4b9937b := (*C.VkFormatProperties)(memc4b9937b)
	allocsc4b9937b := new(cgoAllocMap)
	var clinearTilingFeatures_allocs *cgoAllocMap
	refc4b9937b.linearTilingFeatures, clinearTilingFeatures_allocs = (C.VkFormatFeatureFlags)(x.LinearTilingFeatures), cgoAllocsUnknown
	allocsc4b9937b.Borrow(clinearTilingFeatures_allocs)

	var coptimalTilingFeatures_allocs *cgoAllocMap
	refc4b9937b.optimalTilingFeatures, coptimalTilingFeatures_allocs = (C.VkFormatFeatureFlags)(x.OptimalTilingFeatures), cgoAllocsUnknown
	allocsc4b9937b.Borrow(coptimalTilingFeatures_allocs)

	var cbufferFeatures_allocs *cgoAllocMap
	refc4b9937b.bufferFeatures, cbufferFeatures_allocs = (C.VkFormatFeatureFlags)(x.BufferFeatures), cgoAllocsUnknown
	allocsc4b9937b.Borrow(cbufferFeatures_allocs)

	x.refc4b9937b = refc4b9937b
	x.allocsc4b9937b = allocsc4b9937b
	return refc4b9937b, allocsc4b9937b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *FormatProperties) PassValue() (C.VkFormatProperties, *cgoAllocMap) {
	if x == nil {
		x = NewFormatPropertiesRef(nil)
	} else if x.refc4b9937b != nil {
		return *x.refc4b9937b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *FormatProperties) Deref() {
	if x.refc4b9937b == nil {
		return
	}
	x.LinearTilingFeatures = (FormatFeatureFlags)(x.refc4b9937b.linearTilingFeatures)
	x.OptimalTilingFeatures = (FormatFeatureFlags)(x.refc4b9937b.optimalTilingFeatures)
	x.BufferFeatures = (FormatFeatureFlags)(x.refc4b9937b.bufferFeatures)
}

// allocExtent3DMemory allocates memory for type C.VkExtent3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtent3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtent3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExtent3DValue = unsafe.Sizeof([1]C.VkExtent3D{})

// Ref returns a reference.
func (x *Extent3D) Ref() *C.VkExtent3D {
	if x == nil {
		return nil
	}
	return x.reffbf6c42a
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Extent3D) Free() {
	if x != nil && x.allocsfbf6c42a != nil {
		x.allocsfbf6c42a.(*cgoAllocMap).Free()
		x.reffbf6c42a = nil
	}
}

// NewExtent3DRef initialises a new struct holding the reference to the originaitng C struct.
func NewExtent3DRef(ref *C.VkExtent3D) *Extent3D {
	if ref == nil {
		return nil
	}
	obj := new(Extent3D)
	obj.reffbf6c42a = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Extent3D) PassRef() (*C.VkExtent3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffbf6c42a != nil {
		return x.reffbf6c42a, nil
	}
	memfbf6c42a := allocExtent3DMemory(1)
	reffbf6c42a := (*C.VkExtent3D)(memfbf6c42a)
	allocsfbf6c42a := new(cgoAllocMap)
	var cwidth_allocs *cgoAllocMap
	reffbf6c42a.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocsfbf6c42a.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	reffbf6c42a.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocsfbf6c42a.Borrow(cheight_allocs)

	var cdepth_allocs *cgoAllocMap
	reffbf6c42a.depth, cdepth_allocs = (C.uint32_t)(x.Depth), cgoAllocsUnknown
	allocsfbf6c42a.Borrow(cdepth_allocs)

	x.reffbf6c42a = reffbf6c42a
	x.allocsfbf6c42a = allocsfbf6c42a
	return reffbf6c42a, allocsfbf6c42a

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Extent3D) PassValue() (C.VkExtent3D, *cgoAllocMap) {
	if x == nil {
		x = NewExtent3DRef(nil)
	} else if x.reffbf6c42a != nil {
		return *x.reffbf6c42a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Extent3D) Deref() {
	if x.reffbf6c42a == nil {
		return
	}
	x.Width = (uint32)(x.reffbf6c42a.width)
	x.Height = (uint32)(x.reffbf6c42a.height)
	x.Depth = (uint32)(x.reffbf6c42a.depth)
}

// allocImageFormatPropertiesMemory allocates memory for type C.VkImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkImageFormatProperties{})

// Ref returns a reference.
func (x *ImageFormatProperties) Ref() *C.VkImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.ref4cfb2ea2
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageFormatProperties) Free() {
	if x != nil && x.allocs4cfb2ea2 != nil {
		x.allocs4cfb2ea2.(*cgoAllocMap).Free()
		x.ref4cfb2ea2 = nil
	}
}

// NewImageFormatPropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageFormatPropertiesRef(ref *C.VkImageFormatProperties) *ImageFormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(ImageFormatProperties)
	obj.ref4cfb2ea2 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageFormatProperties) PassRef() (*C.VkImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4cfb2ea2 != nil {
		return x.ref4cfb2ea2, nil
	}
	mem4cfb2ea2 := allocImageFormatPropertiesMemory(1)
	ref4cfb2ea2 := (*C.VkImageFormatProperties)(mem4cfb2ea2)
	allocs4cfb2ea2 := new(cgoAllocMap)
	var cmaxExtent_allocs *cgoAllocMap
	ref4cfb2ea2.maxExtent, cmaxExtent_allocs = x.MaxExtent.PassValue()
	allocs4cfb2ea2.Borrow(cmaxExtent_allocs)

	var cmaxMipLevels_allocs *cgoAllocMap
	ref4cfb2ea2.maxMipLevels, cmaxMipLevels_allocs = (C.uint32_t)(x.MaxMipLevels), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(cmaxMipLevels_allocs)

	var cmaxArrayLayers_allocs *cgoAllocMap
	ref4cfb2ea2.maxArrayLayers, cmaxArrayLayers_allocs = (C.uint32_t)(x.MaxArrayLayers), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(cmaxArrayLayers_allocs)

	var csampleCounts_allocs *cgoAllocMap
	ref4cfb2ea2.sampleCounts, csampleCounts_allocs = (C.VkSampleCountFlags)(x.SampleCounts), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(csampleCounts_allocs)

	var cmaxResourceSize_allocs *cgoAllocMap
	ref4cfb2ea2.maxResourceSize, cmaxResourceSize_allocs = (C.VkDeviceSize)(x.MaxResourceSize), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(cmaxResourceSize_allocs)

	x.ref4cfb2ea2 = ref4cfb2ea2
	x.allocs4cfb2ea2 = allocs4cfb2ea2
	return ref4cfb2ea2, allocs4cfb2ea2

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ImageFormatProperties) PassValue() (C.VkImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		x = NewImageFormatPropertiesRef(nil)
	} else if x.ref4cfb2ea2 != nil {
		return *x.ref4cfb2ea2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageFormatProperties) Deref() {
	if x.ref4cfb2ea2 == nil {
		return
	}
	x.MaxExtent = *NewExtent3DRef(&x.ref4cfb2ea2.maxExtent)
	x.MaxMipLevels = (uint32)(x.ref4cfb2ea2.maxMipLevels)
	x.MaxArrayLayers = (uint32)(x.ref4cfb2ea2.maxArrayLayers)
	x.SampleCounts = (SampleCountFlags)(x.ref4cfb2ea2.sampleCounts)
	x.MaxResourceSize = (DeviceSize)(x.ref4cfb2ea2.maxResourceSize)
}

// allocPhysicalDeviceLimitsMemory allocates memory for type C.VkPhysicalDeviceLimits in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceLimitsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceLimitsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceLimitsValue = unsafe.Sizeof([1]C.VkPhysicalDeviceLimits{})

// Ref returns a reference.
func (x *PhysicalDeviceLimits) Ref() *C.VkPhysicalDeviceLimits {
	if x == nil {
		return nil
	}
	return x.ref7926795a
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PhysicalDeviceLimits) Free() {
	if x != nil && x.allocs7926795a != nil {
		x.allocs7926795a.(*cgoAllocMap).Free()
		x.ref7926795a = nil
	}
}

// NewPhysicalDeviceLimitsRef initialises a new struct holding the reference to the originaitng C struct.
func NewPhysicalDeviceLimitsRef(ref *C.VkPhysicalDeviceLimits) *PhysicalDeviceLimits {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceLimits)
	obj.ref7926795a = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PhysicalDeviceLimits) PassRef() (*C.VkPhysicalDeviceLimits, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7926795a != nil {
		return x.ref7926795a, nil
	}
	mem7926795a := allocPhysicalDeviceLimitsMemory(1)
	ref7926795a := (*C.VkPhysicalDeviceLimits)(mem7926795a)
	allocs7926795a := new(cgoAllocMap)
	var cmaxImageDimension1D_allocs *cgoAllocMap
	ref7926795a.maxImageDimension1D, cmaxImageDimension1D_allocs = (C.uint32_t)(x.MaxImageDimension1D), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimension1D_allocs)

	var cmaxImageDimension2D_allocs *cgoAllocMap
	ref7926795a.maxImageDimension2D, cmaxImageDimension2D_allocs = (C.uint32_t)(x.MaxImageDimension2D), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimension2D_allocs)

	var cmaxImageDimension3D_allocs *cgoAllocMap
	ref7926795a.maxImageDimension3D, cmaxImageDimension3D_allocs = (C.uint32_t)(x.MaxImageDimension3D), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimension3D_allocs)

	var cmaxImageDimensionCube_allocs *cgoAllocMap
	ref7926795a.maxImageDimensionCube, cmaxImageDimensionCube_allocs = (C.uint32_t)(x.MaxImageDimensionCube), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimensionCube_allocs)

	var cmaxImageArrayLayers_allocs *cgoAllocMap
	ref7926795a.maxImageArrayLayers, cmaxImageArrayLayers_allocs = (C.uint32_t)(x.MaxImageArrayLayers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageArrayLayers_allocs)

	var cmaxTexelBufferElements_allocs *cgoAllocMap
	ref7926795a.maxTexelBufferElements, cmaxTexelBufferElements_allocs = (C.uint32_t)(x.MaxTexelBufferElements), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTexelBufferElements_allocs)

	var cmaxUniformBufferRange_allocs *cgoAllocMap
	ref7926795a.maxUniformBufferRange, cmaxUniformBufferRange_allocs = (C.uint32_t)(x.MaxUniformBufferRange), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxUniformBufferRange_allocs)

	var cmaxStorageBufferRange_allocs *cgoAllocMap
	ref7926795a.maxStorageBufferRange, cmaxStorageBufferRange_allocs = (C.uint32_t)(x.MaxStorageBufferRange), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxStorageBufferRange_allocs)

	var cmaxPushConstantsSize_allocs *cgoAllocMap
	ref7926795a.maxPushConstantsSize, cmaxPushConstantsSize_allocs = (C.uint32_t)(x.MaxPushConstantsSize), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPushConstantsSize_allocs)

	var cmaxMemoryAllocationCount_allocs *cgoAllocMap
	ref7926795a.maxMemoryAllocationCount, cmaxMemoryAllocationCount_allocs = (C.uint32_t)(x.MaxMemoryAllocationCount), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxMemoryAllocationCount_allocs)

	var cmaxSamplerAllocationCount_allocs *cgoAllocMap
	ref7926795a.maxSamplerAllocationCount, cmaxSamplerAllocationCount_allocs = (C.uint32_t)(x.MaxSamplerAllocationCount), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSamplerAllocationCount_allocs)

	var cbufferImageGranularity_allocs *cgoAllocMap
	ref7926795a.bufferImageGranularity, cbufferImageGranularity_allocs = (C.VkDeviceSize)(x.BufferImageGranularity), cgoAllocsUnknown
	allocs7926795a.Borrow(cbufferImageGranularity_allocs)

	var csparseAddressSpaceSize_allocs *cgoAllocMap
	ref7926795a.sparseAddressSpaceSize, csparseAddressSpaceSize_allocs = (C.VkDeviceSize)(x.SparseAddressSpaceSize), cgoAllocsUnknown
	allocs7926795a.Borrow(csparseAddressSpaceSize_allocs)

	var cmaxBoundDescriptorSets_allocs *cgoAllocMap
	ref7926795a.maxBoundDescriptorSets, cmaxBoundDescriptorSets_allocs = (C.uint32_t)(x.MaxBoundDescriptorSets), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxBoundDescriptorSets_allocs)

	var cmaxPerStageDescriptorSamplers_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorSamplers, cmaxPerStageDescriptorSamplers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorSamplers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorSamplers_allocs)

	var cmaxPerStageDescriptorUniformBuffers_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorUniformBuffers, cmaxPerStageDescriptorUniformBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUniformBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorUniformBuffers_allocs)

	var cmaxPerStageDescriptorStorageBuffers_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorStorageBuffers, cmaxPerStageDescriptorStorageBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorStorageBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorStorageBuffers_allocs)

	var cmaxPerStageDescriptorSampledImages_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorSampledImages, cmaxPerStageDescriptorSampledImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorSampledImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorSampledImages_allocs)

	var cmaxPerStageDescriptorStorageImages_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorStorageImages, cmaxPerStageDescriptorStorageImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorStorageImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorStorageImages_allocs)

	var cmaxPerStageDescriptorInputAttachments_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorInputAttachments, cmaxPerStageDescriptorInputAttachments_allocs = (C.uint32_t)(x.MaxPerStageDescriptorInputAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorInputAttachments_allocs)

	var cmaxPerStageResources_allocs *cgoAllocMap
	ref7926795a.maxPerStageResources, cmaxPerStageResources_allocs = (C.uint32_t)(x.MaxPerStageResources), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageResources_allocs)

	var cmaxDescriptorSetSamplers_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetSamplers, cmaxDescriptorSetSamplers_allocs = (C.uint32_t)(x.MaxDescriptorSetSamplers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetSamplers_allocs)

	var cmaxDescriptorSetUniformBuffers_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetUniformBuffers, cmaxDescriptorSetUniformBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetUniformBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetUniformBuffers_allocs)

	var cmaxDescriptorSetUniformBuffersDynamic_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetUniformBuffersDynamic, cmaxDescriptorSetUniformBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetUniformBuffersDynamic), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetUniformBuffersDynamic_allocs)

	var cmaxDescriptorSetStorageBuffers_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetStorageBuffers, cmaxDescriptorSetStorageBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetStorageBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetStorageBuffers_allocs)

	var cmaxDescriptorSetStorageBuffersDynamic_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetStorageBuffersDynamic, cmaxDescriptorSetStorageBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetStorageBuffersDynamic), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetStorageBuffersDynamic_allocs)

	var cmaxDescriptorSetSampledImages_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetSampledImages, cmaxDescriptorSetSampledImages_allocs = (C.uint32_t)(x.MaxDescriptorSetSampledImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetSampledImages_allocs)

	var cmaxDescriptorSetStorageImages_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetStorageImages, cmaxDescriptorSetStorageImages_allocs = (C.uint32_t)(x.MaxDescriptorSetStorageImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetStorageImages_allocs)

	var cmaxDescriptorSetInputAttachments_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetInputAttachments, cmaxDescriptorSetInputAttachments_allocs = (C.uint32_t)(x.MaxDescriptorSetInputAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetInputAttachments_allocs)

	var cmaxVertexInputAttributes_allocs *cgoAllocMap
	ref7926795a.maxVertexInputAttributes, cmaxVertexInputAttributes_allocs = (C.uint32_t)(x.MaxVertexInputAttributes), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputAttributes_allocs)

	var cmaxVertexInputBindings_allocs *cgoAllocMap
	ref7926795a.maxVertexInputBindings, cmaxVertexInputBindings_allocs = (C.uint32_t)(x.MaxVertexInputBindings), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputBindings_allocs)

	var cmaxVertexInputAttributeOffset_allocs *cgoAllocMap
	ref7926795a.maxVertexInputAttributeOffset, cmaxVertexInputAttributeOffset_allocs = (C.uint32_t)(x.MaxVertexInputAttributeOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputAttributeOffset_allocs)

	var cmaxVertexInputBindingStride_allocs *cgoAllocMap
	ref7926795a.maxVertexInputBindingStride, cmaxVertexInputBindingStride_allocs = (C.uint32_t)(x.MaxVertexInputBindingStride), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputBindingStride_allocs)

	var cmaxVertexOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxVertexOutputComponents, cmaxVertexOutputComponents_allocs = (C.uint32_t)(x.MaxVertexOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexOutputComponents_allocs)

	var cmaxTessellationGenerationLevel_allocs *cgoAllocMap
	ref7926795a.maxTessellationGenerationLevel, cmaxTessellationGenerationLevel_allocs = (C.uint32_t)(x.MaxTessellationGenerationLevel), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationGenerationLevel_allocs)

	var cmaxTessellationPatchSize_allocs *cgoAllocMap
	ref7926795a.maxTessellationPatchSize, cmaxTessellationPatchSize_allocs = (C.uint32_t)(x.MaxTessellationPatchSize), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationPatchSize_allocs)

	var cmaxTessellationControlPerVertexInputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlPerVertexInputComponents, cmaxTessellationControlPerVertexInputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlPerVertexInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlPerVertexInputComponents_allocs)

	var cmaxTessellationControlPerVertexOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlPerVertexOutputComponents, cmaxTessellationControlPerVertexOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlPerVertexOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlPerVertexOutputComponents_allocs)

	var cmaxTessellationControlPerPatchOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlPerPatchOutputComponents, cmaxTessellationControlPerPatchOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlPerPatchOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlPerPatchOutputComponents_allocs)

	var cmaxTessellationControlTotalOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlTotalOutputComponents, cmaxTessellationControlTotalOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlTotalOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlTotalOutputComponents_allocs)

	var cmaxTessellationEvaluationInputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationEvaluationInputComponents, cmaxTessellationEvaluationInputComponents_allocs = (C.uint32_t)(x.MaxTessellationEvaluationInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationEvaluationInputComponents_allocs)

	var cmaxTessellationEvaluationOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationEvaluationOutputComponents, cmaxTessellationEvaluationOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationEvaluationOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationEvaluationOutputComponents_allocs)

	var cmaxGeometryShaderInvocations_allocs *cgoAllocMap
	ref7926795a.maxGeometryShaderInvocations, cmaxGeometryShaderInvocations_allocs = (C.uint32_t)(x.MaxGeometryShaderInvocations), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryShaderInvocations_allocs)

	var cmaxGeometryInputComponents_allocs *cgoAllocMap
	ref7926795a.maxGeometryInputComponents, cmaxGeometryInputComponents_allocs = (C.uint32_t)(x.MaxGeometryInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryInputComponents_allocs)

	var cmaxGeometryOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxGeometryOutputComponents, cmaxGeometryOutputComponents_allocs = (C.uint32_t)(x.MaxGeometryOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryOutputComponents_allocs)

	var cmaxGeometryOutputVertices_allocs *cgoAllocMap
	ref7926795a.maxGeometryOutputVertices, cmaxGeometryOutputVertices_allocs = (C.uint32_t)(x.MaxGeometryOutputVertices), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryOutputVertices_allocs)

	var cmaxGeometryTotalOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxGeometryTotalOutputComponents, cmaxGeometryTotalOutputComponents_allocs = (C.uint32_t)(x.MaxGeometryTotalOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryTotalOutputComponents_allocs)

	var cmaxFragmentInputComponents_allocs *cgoAllocMap
	ref7926795a.maxFragmentInputComponents, cmaxFragmentInputComponents_allocs = (C.uint32_t)(x.MaxFragmentInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentInputComponents_allocs)

	var cmaxFragmentOutputAttachments_allocs *cgoAllocMap
	ref7926795a.maxFragmentOutputAttachments, cmaxFragmentOutputAttachments_allocs = (C.uint32_t)(x.MaxFragmentOutputAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentOutputAttachments_allocs)

	var cmaxFragmentDualSrcAttachments_allocs *cgoAllocMap
	ref7926795a.maxFragmentDualSrcAttachments, cmaxFragmentDualSrcAttachments_allocs = (C.uint32_t)(x.MaxFragmentDualSrcAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentDualSrcAttachments_allocs)

	var cmaxFragmentCombinedOutputResources_allocs *cgoAllocMap
	ref7926795a.maxFragmentCombinedOutputResources, cmaxFragmentCombinedOutputResources_allocs = (C.uint32_t)(x.MaxFragmentCombinedOutputResources), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentCombinedOutputResources_allocs)

	var cmaxComputeSharedMemorySize_allocs *cgoAllocMap
	ref7926795a.maxComputeSharedMemorySize, cmaxComputeSharedMemorySize_allocs = (C.uint32_t)(x.MaxComputeSharedMemorySize), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeSharedMemorySize_allocs)

	var cmaxComputeWorkGroupCount_allocs *cgoAllocMap
	ref7926795a.maxComputeWorkGroupCount, cmaxComputeWorkGroupCount_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.MaxComputeWorkGroupCount)), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeWorkGroupCount_allocs)

	var cmaxComputeWorkGroupInvocations_allocs *cgoAllocMap
	ref7926795a.maxComputeWorkGroupInvocations, cmaxComputeWorkGroupInvocations_allocs = (C.uint32_t)(x.MaxComputeWorkGroupInvocations), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeWorkGroupInvocations_allocs)

	var cmaxComputeWorkGroupSize_allocs *cgoAllocMap
	ref7926795a.maxComputeWorkGroupSize, cmaxComputeWorkGroupSize_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.MaxComputeWorkGroupSize)), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeWorkGroupSize_allocs)

	var csubPixelPrecisionBits_allocs *cgoAllocMap
	ref7926795a.subPixelPrecisionBits, csubPixelPrecisionBits_allocs = (C.uint32_t)(x.SubPixelPrecisionBits), cgoAllocsUnknown
	allocs7926795a.Borrow(csubPixelPrecisionBits_allocs)

	var csubTexelPrecisionBits_allocs *cgoAllocMap
	ref7926795a.subTexelPrecisionBits, csubTexelPrecisionBits_allocs = (C.uint32_t)(x.SubTexelPrecisionBits), cgoAllocsUnknown
	allocs7926795a.Borrow(csubTexelPrecisionBits_allocs)

	var cmipmapPrecisionBits_allocs *cgoAllocMap
	ref7926795a.mipmapPrecisionBits, cmipmapPrecisionBits_allocs = (C.uint32_t)(x.MipmapPrecisionBits), cgoAllocsUnknown
	allocs7926795a.Borrow(cmipmapPrecisionBits_allocs)

	var cmaxDrawIndexedIndexValue_allocs *cgoAllocMap
	ref7926795a.maxDrawIndexedIndexValue, cmaxDrawIndexedIndexValue_allocs = (C.uint32_t)(x.MaxDrawIndexedIndexValue), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDrawIndexedIndexValue_allocs)

	var cmaxDrawIndirectCount_allocs *cgoAllocMap
	ref7926795a.maxDrawIndirectCount, cmaxDrawIndirectCount_allocs = (C.uint32_t)(x.MaxDrawIndirectCount), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDrawIndirectCount_allocs)

	var cmaxSamplerLodBias_allocs *cgoAllocMap
	ref7926795a.maxSamplerLodBias, cmaxSamplerLodBias_allocs = (C.float)(x.MaxSamplerLodBias), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSamplerLodBias_allocs)

	var cmaxSamplerAnisotropy_allocs *cgoAllocMap
	ref7926795a.maxSamplerAnisotropy, cmaxSamplerAnisotropy_allocs = (C.float)(x.MaxSamplerAnisotropy), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSamplerAnisotropy_allocs)

	var cmaxViewports_allocs *cgoAllocMap
	ref7926795a.maxViewports, cmaxViewports_allocs = (C.uint32_t)(x.MaxViewports), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxViewports_allocs)

	var cmaxViewportDimensions_allocs *cgoAllocMap
	ref7926795a.maxViewportDimensions, cmaxViewportDimensions_allocs = *(*[2]C.uint32_t)(unsafe.Pointer(&x.MaxViewportDimensions)), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxViewportDimensions_allocs)

	var cviewportBoundsRange_allocs *cgoAllocMap
	ref7926795a.viewportBoundsRange, cviewportBoundsRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.ViewportBoundsRange)), cgoAllocsUnknown
	allocs7926795a.Borrow(cviewportBoundsRange_allocs)

	var cviewportSubPixelBits_allocs *cgoAllocMap
	ref7926795a.viewportSubPixelBits, cviewportSubPixelBits_allocs = (C.uint32_t)(x.ViewportSubPixelBits), cgoAllocsUnknown
	allocs7926795a.Borrow(cviewportSubPixelBits_allocs)

	var cminMemoryMapAlignment_allocs *cgoAllocMap
	ref7926795a.minMemoryMapAlignment, cminMemoryMapAlignment_allocs = (C.size_t)(x.MinMemoryMapAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminMemoryMapAlignment_allocs)

	var cminTexelBufferOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.minTexelBufferOffsetAlignment, cminTexelBufferOffsetAlignment_allocs = (C.VkDeviceSize)(x.MinTexelBufferOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminTexelBufferOffsetAlignment_allocs)

	var cminUniformBufferOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.minUniformBufferOffsetAlignment, cminUniformBufferOffsetAlignment_allocs = (C.VkDeviceSize)(x.MinUniformBufferOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminUniformBufferOffsetAlignment_allocs)

	var cminStorageBufferOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.minStorageBufferOffsetAlignment, cminStorageBufferOffsetAlignment_allocs = (C.VkDeviceSize)(x.MinStorageBufferOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminStorageBufferOffsetAlignment_allocs)

	var cminTexelOffset_allocs *cgoAllocMap
	ref7926795a.minTexelOffset, cminTexelOffset_allocs = (C.int32_t)(x.MinTexelOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cminTexelOffset_allocs)

	var cmaxTexelOffset_allocs *cgoAllocMap
	ref7926795a.maxTexelOffset, cmaxTexelOffset_allocs = (C.uint32_t)(x.MaxTexelOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTexelOffset_allocs)

	var cminTexelGatherOffset_allocs *cgoAllocMap
	ref7926795a.minTexelGatherOffset, cminTexelGatherOffset_allocs = (C.int32_t)(x.MinTexelGatherOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cminTexelGatherOffset_allocs)

	var cmaxTexelGatherOffset_allocs *cgoAllocMap
	ref7926795a.maxTexelGatherOffset, cmaxTexelGatherOffset_allocs = (C.uint32_t)(x.MaxTexelGatherOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTexelGatherOffset_allocs)

	var cminInterpolationOffset_allocs *cgoAllocMap
	ref7926795a.minInterpolationOffset, cminInterpolationOffset_allocs = (C.float)(x.MinInterpolationOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cminInterpolationOffset_allocs)

	var cmaxInterpolationOffset_allocs *cgoAllocMap
	ref7926795a.maxInterpolationOffset, cmaxInterpolationOffset_allocs = (C.float)(x.MaxInterpolationOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxInterpolationOffset_allocs)

	var csubPixelInterpolationOffsetBits_allocs *cgoAllocMap
	ref7926795a.subPixelInterpolationOffsetBits, csubPixelInterpolationOffsetBits_allocs = (C.uint32_t)(x.SubPixelInterpolationOffsetBits), cgoAllocsUnknown
	allocs7926795a.Borrow(csubPixelInterpolationOffsetBits_allocs)

	var cmaxFramebufferWidth_allocs *cgoAllocMap
	ref7926795a.maxFramebufferWidth, cmaxFramebufferWidth_allocs = (C.uint32_t)(x.MaxFramebufferWidth), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFramebufferWidth_allocs)

	var cmaxFramebufferHeight_allocs *cgoAllocMap
	ref7926795a.maxFramebufferHeight, cmaxFramebufferHeight_allocs = (C.uint32_t)(x.MaxFramebufferHeight), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFramebufferHeight_allocs)

	var cmaxFramebufferLayers_allocs *cgoAllocMap
	ref7926795a.maxFramebufferLayers, cmaxFramebufferLayers_allocs = (C.uint32_t)(x.MaxFramebufferLayers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFramebufferLayers_allocs)

	var cframebufferColorSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferColorSampleCounts, cframebufferColorSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferColorSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferColorSampleCounts_allocs)

	var cframebufferDepthSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferDepthSampleCounts, cframebufferDepthSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferDepthSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferDepthSampleCounts_allocs)

	var cframebufferStencilSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferStencilSampleCounts, cframebufferStencilSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferStencilSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferStencilSampleCounts_allocs)

	var cframebufferNoAttachmentsSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferNoAttachmentsSampleCounts, cframebufferNoAttachmentsSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferNoAttachmentsSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferNoAttachmentsSampleCounts_allocs)

	var cmaxColorAttachments_allocs *cgoAllocMap
	ref7926795a.maxColorAttachments, cmaxColorAttachments_allocs = (C.uint32_t)(x.MaxColorAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxColorAttachments_allocs)

	var csampledImageColorSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageColorSampleCounts, csampledImageColorSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageColorSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageColorSampleCounts_allocs)

	var csampledImageIntegerSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageIntegerSampleCounts, csampledImageIntegerSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageIntegerSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageIntegerSampleCounts_allocs)

	var csampledImageDepthSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageDepthSampleCounts, csampledImageDepthSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageDepthSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageDepthSampleCounts_allocs)

	var csampledImageStencilSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageStencilSampleCounts, csampledImageStencilSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageStencilSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageStencilSampleCounts_allocs)

	var cstorageImageSampleCounts_allocs *cgoAllocMap
	ref7926795a.storageImageSampleCounts, cstorageImageSampleCounts_allocs = (C.VkSampleCountFlags)(x.StorageImageSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cstorageImageSampleCounts_allocs)

	var cmaxSampleMaskWords_allocs *cgoAllocMap
	ref7926795a.maxSampleMaskWords, cmaxSampleMaskWords_allocs = (C.uint32_t)(x.MaxSampleMaskWords), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSampleMaskWords_allocs)

	var ctimestampComputeAndGraphics_allocs *cgoAllocMap
	ref7926795a.timestampComputeAndGraphics, ctimestampComputeAndGraphics_allocs = (C.VkBool32)(x.TimestampComputeAndGraphics), cgoAllocsUnknown
	allocs7926795a.Borrow(ctimestampComputeAndGraphics_allocs)

	var ctimestampPeriod_allocs *cgoAllocMap
	ref7926795a.timestampPeriod, ctimestampPeriod_allocs = (C.float)(x.TimestampPeriod), cgoAllocsUnknown
	allocs7926795a.Borrow(ctimestampPeriod_allocs)

	var cmaxClipDistances_allocs *cgoAllocMap
	ref7926795a.maxClipDistances, cmaxClipDistances_allocs = (C.uint32_t)(x.MaxClipDistances), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxClipDistances_allocs)

	var cmaxCullDistances_allocs *cgoAllocMap
	ref7926795a.maxCullDistances, cmaxCullDistances_allocs = (C.uint32_t)(x.MaxCullDistances), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxCullDistances_allocs)

	var cmaxCombinedClipAndCullDistances_allocs *cgoAllocMap
	ref7926795a.maxCombinedClipAndCullDistances, cmaxCombinedClipAndCullDistances_allocs = (C.uint32_t)(x.MaxCombinedClipAndCullDistances), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxCombinedClipAndCullDistances_allocs)

	var cdiscreteQueuePriorities_allocs *cgoAllocMap
	ref7926795a.discreteQueuePriorities, cdiscreteQueuePriorities_allocs = (C.uint32_t)(x.DiscreteQueuePriorities), cgoAllocsUnknown
	allocs7926795a.Borrow(cdiscreteQueuePriorities_allocs)

	var cpointSizeRange_allocs *cgoAllocMap
	ref7926795a.pointSizeRange, cpointSizeRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.PointSizeRange)), cgoAllocsUnknown
	allocs7926795a.Borrow(cpointSizeRange_allocs)

	var clineWidthRange_allocs *cgoAllocMap
	ref7926795a.lineWidthRange, clineWidthRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.LineWidthRange)), cgoAllocsUnknown
	allocs7926795a.Borrow(clineWidthRange_allocs)

	var cpointSizeGranularity_allocs *cgoAllocMap
	ref7926795a.pointSizeGranularity, cpointSizeGranularity_allocs = (C.float)(x.PointSizeGranularity), cgoAllocsUnknown
	allocs7926795a.Borrow(cpointSizeGranularity_allocs)

	var clineWidthGranularity_allocs *cgoAllocMap
	ref7926795a.lineWidthGranularity, clineWidthGranularity_allocs = (C.float)(x.LineWidthGranularity), cgoAllocsUnknown
	allocs7926795a.Borrow(clineWidthGranularity_allocs)

	var cstrictLines_allocs *cgoAllocMap
	ref7926795a.strictLines, cstrictLines_allocs = (C.VkBool32)(x.StrictLines), cgoAllocsUnknown
	allocs7926795a.Borrow(cstrictLines_allocs)

	var cstandardSampleLocations_allocs *cgoAllocMap
	ref7926795a.standardSampleLocations, cstandardSampleLocations_allocs = (C.VkBool32)(x.StandardSampleLocations), cgoAllocsUnknown
	allocs7926795a.Borrow(cstandardSampleLocations_allocs)

	var coptimalBufferCopyOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.optimalBufferCopyOffsetAlignment, coptimalBufferCopyOffsetAlignment_allocs = (C.VkDeviceSize)(x.OptimalBufferCopyOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(coptimalBufferCopyOffsetAlignment_allocs)

	var coptimalBufferCopyRowPitchAlignment_allocs *cgoAllocMap
	ref7926795a.optimalBufferCopyRowPitchAlignment, coptimalBufferCopyRowPitchAlignment_allocs = (C.VkDeviceSize)(x.OptimalBufferCopyRowPitchAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(coptimalBufferCopyRowPitchAlignment_allocs)

	var cnonCoherentAtomSize_allocs *cgoAllocMap
	ref7926795a.nonCoherentAtomSize, cnonCoherentAtomSize_allocs = (C.VkDeviceSize)(x.NonCoherentAtomSize), cgoAllocsUnknown
	allocs7926795a.Borrow(cnonCoherentAtomSize_allocs)

	x.ref7926795a = ref7926795a
	x.allocs7926795a = allocs7926795a
	return ref7926795a, allocs7926795a

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PhysicalDeviceLimits) PassValue() (C.VkPhysicalDeviceLimits, *cgoAllocMap) {
	if x == nil {
		x = NewPhysicalDeviceLimitsRef(nil)
	} else if x.ref7926795a != nil {
		return *x.ref7926795a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PhysicalDeviceLimits) Deref() {
	if x.ref7926795a == nil {
		return
	}
	x.MaxImageDimension1D = (uint32)(x.ref7926795a.maxImageDimension1D)
	x.MaxImageDimension2D = (uint32)(x.ref7926795a.maxImageDimension2D)
	x.MaxImageDimension3D = (uint32)(x.ref7926795a.maxImageDimension3D)
	x.MaxImageDimensionCube = (uint32)(x.ref7926795a.maxImageDimensionCube)
	x.MaxImageArrayLayers = (uint32)(x.ref7926795a.maxImageArrayLayers)
	x.MaxTexelBufferElements = (uint32)(x.ref7926795a.maxTexelBufferElements)
	x.MaxUniformBufferRange = (uint32)(x.ref7926795a.maxUniformBufferRange)
	x.MaxStorageBufferRange = (uint32)(x.ref7926795a.maxStorageBufferRange)
	x.MaxPushConstantsSize = (uint32)(x.ref7926795a.maxPushConstantsSize)
	x.MaxMemoryAllocationCount = (uint32)(x.ref7926795a.maxMemoryAllocationCount)
	x.MaxSamplerAllocationCount = (uint32)(x.ref7926795a.maxSamplerAllocationCount)
	x.BufferImageGranularity = (DeviceSize)(x.ref7926795a.bufferImageGranularity)
	x.SparseAddressSpaceSize = (DeviceSize)(x.ref7926795a.sparseAddressSpaceSize)
	x.MaxBoundDescriptorSets = (uint32)(x.ref7926795a.maxBoundDescriptorSets)
	x.MaxPerStageDescriptorSamplers = (uint32)(x.ref7926795a.maxPerStageDescriptorSamplers)
	x.MaxPerStageDescriptorUniformBuffers = (uint32)(x.ref7926795a.maxPerStageDescriptorUniformBuffers)
	x.MaxPerStageDescriptorStorageBuffers = (uint32)(x.ref7926795a.maxPerStageDescriptorStorageBuffers)
	x.MaxPerStageDescriptorSampledImages = (uint32)(x.ref7926795a.maxPerStageDescriptorSampledImages)
	x.MaxPerStageDescriptorStorageImages = (uint32)(x.ref7926795a.maxPerStageDescriptorStorageImages)
	x.MaxPerStageDescriptorInputAttachments = (uint32)(x.ref7926795a.maxPerStageDescriptorInputAttachments)
	x.MaxPerStageResources = (uint32)(x.ref7926795a.maxPerStageResources)
	x.MaxDescriptorSetSamplers = (uint32)(x.ref7926795a.maxDescriptorSetSamplers)
	x.MaxDescriptorSetUniformBuffers = (uint32)(x.ref7926795a.maxDescriptorSetUniformBuffers)
	x.MaxDescriptorSetUniformBuffersDynamic = (uint32)(x.ref7926795a.maxDescriptorSetUniformBuffersDynamic)
	x.MaxDescriptorSetStorageBuffers = (uint32)(x.ref7926795a.maxDescriptorSetStorageBuffers)
	x.MaxDescriptorSetStorageBuffersDynamic = (uint32)(x.ref7926795a.maxDescriptorSetStorageBuffersDynamic)
	x.MaxDescriptorSetSampledImages = (uint32)(x.ref7926795a.maxDescriptorSetSampledImages)
	x.MaxDescriptorSetStorageImages = (uint32)(x.ref7926795a.maxDescriptorSetStorageImages)
	x.MaxDescriptorSetInputAttachments = (uint32)(x.ref7926795a.maxDescriptorSetInputAttachments)
	x.MaxVertexInputAttributes = (uint32)(x.ref7926795a.maxVertexInputAttributes)
	x.MaxVertexInputBindings = (uint32)(x.ref7926795a.maxVertexInputBindings)
	x.MaxVertexInputAttributeOffset = (uint32)(x.ref7926795a.maxVertexInputAttributeOffset)
	x.MaxVertexInputBindingStride = (uint32)(x.ref7926795a.maxVertexInputBindingStride)
	x.MaxVertexOutputComponents = (uint32)(x.ref7926795a.maxVertexOutputComponents)
	x.MaxTessellationGenerationLevel = (uint32)(x.ref7926795a.maxTessellationGenerationLevel)
	x.MaxTessellationPatchSize = (uint32)(x.ref7926795a.maxTessellationPatchSize)
	x.MaxTessellationControlPerVertexInputComponents = (uint32)(x.ref7926795a.maxTessellationControlPerVertexInputComponents)
	x.MaxTessellationControlPerVertexOutputComponents = (uint32)(x.ref7926795a.maxTessellationControlPerVertexOutputComponents)
	x.MaxTessellationControlPerPatchOutputComponents = (uint32)(x.ref7926795a.maxTessellationControlPerPatchOutputComponents)
	x.MaxTessellationControlTotalOutputComponents = (uint32)(x.ref7926795a.maxTessellationControlTotalOutputComponents)
	x.MaxTessellationEvaluationInputComponents = (uint32)(x.ref7926795a.maxTessellationEvaluationInputComponents)
	x.MaxTessellationEvaluationOutputComponents = (uint32)(x.ref7926795a.maxTessellationEvaluationOutputComponents)
	x.MaxGeometryShaderInvocations = (uint32)(x.ref7926795a.maxGeometryShaderInvocations)
	x.MaxGeometryInputComponents = (uint32)(x.ref7926795a.maxGeometryInputComponents)
	x.MaxGeometryOutputComponents = (uint32)(x.ref7926795a.maxGeometryOutputComponents)
	x.MaxGeometryOutputVertices = (uint32)(x.ref7926795a.maxGeometryOutputVertices)
	x.MaxGeometryTotalOutputComponents = (uint32)(x.ref7926795a.maxGeometryTotalOutputComponents)
	x.MaxFragmentInputComponents = (uint32)(x.ref7926795a.maxFragmentInputComponents)
	x.MaxFragmentOutputAttachments = (uint32)(x.ref7926795a.maxFragmentOutputAttachments)
	x.MaxFragmentDualSrcAttachments = (uint32)(x.ref7926795a.maxFragmentDualSrcAttachments)
	x.MaxFragmentCombinedOutputResources = (uint32)(x.ref7926795a.maxFragmentCombinedOutputResources)
	x.MaxComputeSharedMemorySize = (uint32)(x.ref7926795a.maxComputeSharedMemorySize)
	x.MaxComputeWorkGroupCount = *(*[3]uint32)(unsafe.Pointer(&x.ref7926795a.maxComputeWorkGroupCount))
	x.MaxComputeWorkGroupInvocations = (uint32)(x.ref7926795a.maxComputeWorkGroupInvocations)
	x.MaxComputeWorkGroupSize = *(*[3]uint32)(unsafe.Pointer(&x.ref7926795a.maxComputeWorkGroupSize))
	x.SubPixelPrecisionBits = (uint32)(x.ref7926795a.subPixelPrecisionBits)
	x.SubTexelPrecisionBits = (uint32)(x.ref7926795a.subTexelPrecisionBits)
	x.MipmapPrecisionBits = (uint32)(x.ref7926795a.mipmapPrecisionBits)
	x.MaxDrawIndexedIndexValue = (uint32)(x.ref7926795a.maxDrawIndexedIndexValue)
	x.MaxDrawIndirectCount = (uint32)(x.ref7926795a.maxDrawIndirectCount)
	x.MaxSamplerLodBias = (float32)(x.ref7926795a.maxSamplerLodBias)
	x.MaxSamplerAnisotropy = (float32)(x.ref7926795a.maxSamplerAnisotropy)
	x.MaxViewports = (uint32)(x.ref7926795a.maxViewports)
	x.MaxViewportDimensions = *(*[2]uint32)(unsafe.Pointer(&x.ref7926795a.maxViewportDimensions))
	x.ViewportBoundsRange = *(*[2]float32)(unsafe.Pointer(&x.ref7926795a.viewportBoundsRange))
	x.ViewportSubPixelBits = (uint32)(x.ref7926795a.viewportSubPixelBits)
	x.MinMemoryMapAlignment = (uint)(x.ref7926795a.minMemoryMapAlignment)
	x.MinTexelBufferOffsetAlignment = (DeviceSize)(x.ref7926795a.minTexelBufferOffsetAlignment)
	x.MinUniformBufferOffsetAlignment = (DeviceSize)(x.ref7926795a.minUniformBufferOffsetAlignment)
	x.MinStorageBufferOffsetAlignment = (DeviceSize)(x.ref7926795a.minStorageBufferOffsetAlignment)
	x.MinTexelOffset = (int32)(x.ref7926795a.minTexelOffset)
	x.MaxTexelOffset = (uint32)(x.ref7926795a.maxTexelOffset)
	x.MinTexelGatherOffset = (int32)(x.ref7926795a.minTexelGatherOffset)
	x.MaxTexelGatherOffset = (uint32)(x.ref7926795a.maxTexelGatherOffset)
	x.MinInterpolationOffset = (float32)(x.ref7926795a.minInterpolationOffset)
	x.MaxInterpolationOffset = (float32)(x.ref7926795a.maxInterpolationOffset)
	x.SubPixelInterpolationOffsetBits = (uint32)(x.ref7926795a.subPixelInterpolationOffsetBits)
	x.MaxFramebufferWidth = (uint32)(x.ref7926795a.maxFramebufferWidth)
	x.MaxFramebufferHeight = (uint32)(x.ref7926795a.maxFramebufferHeight)
	x.MaxFramebufferLayers = (uint32)(x.ref7926795a.maxFramebufferLayers)
	x.FramebufferColorSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferColorSampleCounts)
	x.FramebufferDepthSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferDepthSampleCounts)
	x.FramebufferStencilSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferStencilSampleCounts)
	x.FramebufferNoAttachmentsSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferNoAttachmentsSampleCounts)
	x.MaxColorAttachments = (uint32)(x.ref7926795a.maxColorAttachments)
	x.SampledImageColorSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageColorSampleCounts)
	x.SampledImageIntegerSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageIntegerSampleCounts)
	x.SampledImageDepthSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageDepthSampleCounts)
	x.SampledImageStencilSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageStencilSampleCounts)
	x.StorageImageSampleCounts = (SampleCountFlags)(x.ref7926795a.storageImageSampleCounts)
	x.MaxSampleMaskWords = (uint32)(x.ref7926795a.maxSampleMaskWords)
	x.TimestampComputeAndGraphics = (Bool32)(x.ref7926795a.timestampComputeAndGraphics)
	x.TimestampPeriod = (float32)(x.ref7926795a.timestampPeriod)
	x.MaxClipDistances = (uint32)(x.ref7926795a.maxClipDistances)
	x.MaxCullDistances = (uint32)(x.ref7926795a.maxCullDistances)
	x.MaxCombinedClipAndCullDistances = (uint32)(x.ref7926795a.maxCombinedClipAndCullDistances)
	x.DiscreteQueuePriorities = (uint32)(x.ref7926795a.discreteQueuePriorities)
	x.PointSizeRange = *(*[2]float32)(unsafe.Pointer(&x.ref7926795a.pointSizeRange))
	x.LineWidthRange = *(*[2]float32)(unsafe.Pointer(&x.ref7926795a.lineWidthRange))
	x.PointSizeGranularity = (float32)(x.ref7926795a.pointSizeGranularity)
	x.LineWidthGranularity = (float32)(x.ref7926795a.lineWidthGranularity)
	x.StrictLines = (Bool32)(x.ref7926795a.strictLines)
	x.StandardSampleLocations = (Bool32)(x.ref7926795a.standardSampleLocations)
	x.OptimalBufferCopyOffsetAlignment = (DeviceSize)(x.ref7926795a.optimalBufferCopyOffsetAlignment)
	x.OptimalBufferCopyRowPitchAlignment = (DeviceSize)(x.ref7926795a.optimalBufferCopyRowPitchAlignment)
	x.NonCoherentAtomSize = (DeviceSize)(x.ref7926795a.nonCoherentAtomSize)
}

// allocPhysicalDeviceSparsePropertiesMemory allocates memory for type C.VkPhysicalDeviceSparseProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSparsePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSparsePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSparsePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSparseProperties{})

// Ref returns a reference.
func (x *PhysicalDeviceSparseProperties) Ref() *C.VkPhysicalDeviceSparseProperties {
	if x == nil {
		return nil
	}
	return x.ref6d7c11e6
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PhysicalDeviceSparseProperties) Free() {
	if x != nil && x.allocs6d7c11e6 != nil {
		x.allocs6d7c11e6.(*cgoAllocMap).Free()
		x.ref6d7c11e6 = nil
	}
}

// NewPhysicalDeviceSparsePropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewPhysicalDeviceSparsePropertiesRef(ref *C.VkPhysicalDeviceSparseProperties) *PhysicalDeviceSparseProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSparseProperties)
	obj.ref6d7c11e6 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PhysicalDeviceSparseProperties) PassRef() (*C.VkPhysicalDeviceSparseProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6d7c11e6 != nil {
		return x.ref6d7c11e6, nil
	}
	mem6d7c11e6 := allocPhysicalDeviceSparsePropertiesMemory(1)
	ref6d7c11e6 := (*C.VkPhysicalDeviceSparseProperties)(mem6d7c11e6)
	allocs6d7c11e6 := new(cgoAllocMap)
	var cresidencyStandard2DBlockShape_allocs *cgoAllocMap
	ref6d7c11e6.residencyStandard2DBlockShape, cresidencyStandard2DBlockShape_allocs = (C.VkBool32)(x.ResidencyStandard2DBlockShape), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyStandard2DBlockShape_allocs)

	var cresidencyStandard2DMultisampleBlockShape_allocs *cgoAllocMap
	ref6d7c11e6.residencyStandard2DMultisampleBlockShape, cresidencyStandard2DMultisampleBlockShape_allocs = (C.VkBool32)(x.ResidencyStandard2DMultisampleBlockShape), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyStandard2DMultisampleBlockShape_allocs)

	var cresidencyStandard3DBlockShape_allocs *cgoAllocMap
	ref6d7c11e6.residencyStandard3DBlockShape, cresidencyStandard3DBlockShape_allocs = (C.VkBool32)(x.ResidencyStandard3DBlockShape), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyStandard3DBlockShape_allocs)

	var cresidencyAlignedMipSize_allocs *cgoAllocMap
	ref6d7c11e6.residencyAlignedMipSize, cresidencyAlignedMipSize_allocs = (C.VkBool32)(x.ResidencyAlignedMipSize), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyAlignedMipSize_allocs)

	var cresidencyNonResidentStrict_allocs *cgoAllocMap
	ref6d7c11e6.residencyNonResidentStrict, cresidencyNonResidentStrict_allocs = (C.VkBool32)(x.ResidencyNonResidentStrict), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyNonResidentStrict_allocs)

	x.ref6d7c11e6 = ref6d7c11e6
	x.allocs6d7c11e6 = allocs6d7c11e6
	return ref6d7c11e6, allocs6d7c11e6

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PhysicalDeviceSparseProperties) PassValue() (C.VkPhysicalDeviceSparseProperties, *cgoAllocMap) {
	if x == nil {
		x = NewPhysicalDeviceSparsePropertiesRef(nil)
	} else if x.ref6d7c11e6 != nil {
		return *x.ref6d7c11e6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PhysicalDeviceSparseProperties) Deref() {
	if x.ref6d7c11e6 == nil {
		return
	}
	x.ResidencyStandard2DBlockShape = (Bool32)(x.ref6d7c11e6.residencyStandard2DBlockShape)
	x.ResidencyStandard2DMultisampleBlockShape = (Bool32)(x.ref6d7c11e6.residencyStandard2DMultisampleBlockShape)
	x.ResidencyStandard3DBlockShape = (Bool32)(x.ref6d7c11e6.residencyStandard3DBlockShape)
	x.ResidencyAlignedMipSize = (Bool32)(x.ref6d7c11e6.residencyAlignedMipSize)
	x.ResidencyNonResidentStrict = (Bool32)(x.ref6d7c11e6.residencyNonResidentStrict)
}

// allocPhysicalDevicePropertiesMemory allocates memory for type C.VkPhysicalDeviceProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDevicePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceProperties{})

// Ref returns a reference.
func (x *PhysicalDeviceProperties) Ref() *C.VkPhysicalDeviceProperties {
	if x == nil {
		return nil
	}
	return x.ref1080ca9d
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PhysicalDeviceProperties) Free() {
	if x != nil && x.allocs1080ca9d != nil {
		x.allocs1080ca9d.(*cgoAllocMap).Free()
		x.ref1080ca9d = nil
	}
}

// NewPhysicalDevicePropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewPhysicalDevicePropertiesRef(ref *C.VkPhysicalDeviceProperties) *PhysicalDeviceProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProperties)
	obj.ref1080ca9d = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PhysicalDeviceProperties) PassRef() (*C.VkPhysicalDeviceProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1080ca9d != nil {
		return x.ref1080ca9d, nil
	}
	mem1080ca9d := allocPhysicalDevicePropertiesMemory(1)
	ref1080ca9d := (*C.VkPhysicalDeviceProperties)(mem1080ca9d)
	allocs1080ca9d := new(cgoAllocMap)
	var capiVersion_allocs *cgoAllocMap
	ref1080ca9d.apiVersion, capiVersion_allocs = (C.uint32_t)(x.ApiVersion), cgoAllocsUnknown
	allocs1080ca9d.Borrow(capiVersion_allocs)

	var cdriverVersion_allocs *cgoAllocMap
	ref1080ca9d.driverVersion, cdriverVersion_allocs = (C.uint32_t)(x.DriverVersion), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdriverVersion_allocs)

	var cvendorID_allocs *cgoAllocMap
	ref1080ca9d.vendorID, cvendorID_allocs = (C.uint32_t)(x.VendorID), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cvendorID_allocs)

	var cdeviceID_allocs *cgoAllocMap
	ref1080ca9d.deviceID, cdeviceID_allocs = (C.uint32_t)(x.DeviceID), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdeviceID_allocs)

	var cdeviceType_allocs *cgoAllocMap
	ref1080ca9d.deviceType, cdeviceType_allocs = (C.VkPhysicalDeviceType)(x.DeviceType), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdeviceType_allocs)

	var cdeviceName_allocs *cgoAllocMap
	ref1080ca9d.deviceName, cdeviceName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.DeviceName)), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdeviceName_allocs)

	var cpipelineCacheUUID_allocs *cgoAllocMap
	ref1080ca9d.pipelineCacheUUID, cpipelineCacheUUID_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.PipelineCacheUUID)), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cpipelineCacheUUID_allocs)

	var climits_allocs *cgoAllocMap
	ref1080ca9d.limits, climits_allocs = x.Limits.PassValue()
	allocs1080ca9d.Borrow(climits_allocs)

	var csparseProperties_allocs *cgoAllocMap
	ref1080ca9d.sparseProperties, csparseProperties_allocs = x.SparseProperties.PassValue()
	allocs1080ca9d.Borrow(csparseProperties_allocs)

	x.ref1080ca9d = ref1080ca9d
	x.allocs1080ca9d = allocs1080ca9d
	return ref1080ca9d, allocs1080ca9d

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PhysicalDeviceProperties) PassValue() (C.VkPhysicalDeviceProperties, *cgoAllocMap) {
	if x == nil {
		x = NewPhysicalDevicePropertiesRef(nil)
	} else if x.ref1080ca9d != nil {
		return *x.ref1080ca9d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PhysicalDeviceProperties) Deref() {
	if x.ref1080ca9d == nil {
		return
	}
	x.ApiVersion = (uint32)(x.ref1080ca9d.apiVersion)
	x.DriverVersion = (uint32)(x.ref1080ca9d.driverVersion)
	x.VendorID = (uint32)(x.ref1080ca9d.vendorID)
	x.DeviceID = (uint32)(x.ref1080ca9d.deviceID)
	x.DeviceType = (PhysicalDeviceType)(x.ref1080ca9d.deviceType)
	x.DeviceName = *(*[256]byte)(unsafe.Pointer(&x.ref1080ca9d.deviceName))
	x.PipelineCacheUUID = *(*[16]byte)(unsafe.Pointer(&x.ref1080ca9d.pipelineCacheUUID))
	x.Limits = *NewPhysicalDeviceLimitsRef(&x.ref1080ca9d.limits)
	x.SparseProperties = *NewPhysicalDeviceSparsePropertiesRef(&x.ref1080ca9d.sparseProperties)
}

// allocQueueFamilyPropertiesMemory allocates memory for type C.VkQueueFamilyProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueueFamilyPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueueFamilyPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfQueueFamilyPropertiesValue = unsafe.Sizeof([1]C.VkQueueFamilyProperties{})

// Ref returns a reference.
func (x *QueueFamilyProperties) Ref() *C.VkQueueFamilyProperties {
	if x == nil {
		return nil
	}
	return x.refd538c446
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *QueueFamilyProperties) Free() {
	if x != nil && x.allocsd538c446 != nil {
		x.allocsd538c446.(*cgoAllocMap).Free()
		x.refd538c446 = nil
	}
}

// NewQueueFamilyPropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewQueueFamilyPropertiesRef(ref *C.VkQueueFamilyProperties) *QueueFamilyProperties {
	if ref == nil {
		return nil
	}
	obj := new(QueueFamilyProperties)
	obj.refd538c446 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *QueueFamilyProperties) PassRef() (*C.VkQueueFamilyProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd538c446 != nil {
		return x.refd538c446, nil
	}
	memd538c446 := allocQueueFamilyPropertiesMemory(1)
	refd538c446 := (*C.VkQueueFamilyProperties)(memd538c446)
	allocsd538c446 := new(cgoAllocMap)
	var cqueueFlags_allocs *cgoAllocMap
	refd538c446.queueFlags, cqueueFlags_allocs = (C.VkQueueFlags)(x.QueueFlags), cgoAllocsUnknown
	allocsd538c446.Borrow(cqueueFlags_allocs)

	var cqueueCount_allocs *cgoAllocMap
	refd538c446.queueCount, cqueueCount_allocs = (C.uint32_t)(x.QueueCount), cgoAllocsUnknown
	allocsd538c446.Borrow(cqueueCount_allocs)

	var ctimestampValidBits_allocs *cgoAllocMap
	refd538c446.timestampValidBits, ctimestampValidBits_allocs = (C.uint32_t)(x.TimestampValidBits), cgoAllocsUnknown
	allocsd538c446.Borrow(ctimestampValidBits_allocs)

	var cminImageTransferGranularity_allocs *cgoAllocMap
	refd538c446.minImageTransferGranularity, cminImageTransferGranularity_allocs = x.MinImageTransferGranularity.PassValue()
	allocsd538c446.Borrow(cminImageTransferGranularity_allocs)

	x.refd538c446 = refd538c446
	x.allocsd538c446 = allocsd538c446
	return refd538c446, allocsd538c446

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *QueueFamilyProperties) PassValue() (C.VkQueueFamilyProperties, *cgoAllocMap) {
	if x == nil {
		x = NewQueueFamilyPropertiesRef(nil)
	} else if x.refd538c446 != nil {
		return *x.refd538c446, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *QueueFamilyProperties) Deref() {
	if x.refd538c446 == nil {
		return
	}
	x.QueueFlags = (QueueFlags)(x.refd538c446.queueFlags)
	x.QueueCount = (uint32)(x.refd538c446.queueCount)
	x.TimestampValidBits = (uint32)(x.refd538c446.timestampValidBits)
	x.MinImageTransferGranularity = *NewExtent3DRef(&x.refd538c446.minImageTransferGranularity)
}

// allocMemoryTypeMemory allocates memory for type C.VkMemoryType in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryTypeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryTypeValue = unsafe.Sizeof([1]C.VkMemoryType{})

// Ref returns a reference.
func (x *MemoryType) Ref() *C.VkMemoryType {
	if x == nil {
		return nil
	}
	return x.ref2f46e01d
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *MemoryType) Free() {
	if x != nil && x.allocs2f46e01d != nil {
		x.allocs2f46e01d.(*cgoAllocMap).Free()
		x.ref2f46e01d = nil
	}
}

// NewMemoryTypeRef initialises a new struct holding the reference to the originaitng C struct.
func NewMemoryTypeRef(ref *C.VkMemoryType) *MemoryType {
	if ref == nil {
		return nil
	}
	obj := new(MemoryType)
	obj.ref2f46e01d = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *MemoryType) PassRef() (*C.VkMemoryType, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f46e01d != nil {
		return x.ref2f46e01d, nil
	}
	mem2f46e01d := allocMemoryTypeMemory(1)
	ref2f46e01d := (*C.VkMemoryType)(mem2f46e01d)
	allocs2f46e01d := new(cgoAllocMap)
	var cpropertyFlags_allocs *cgoAllocMap
	ref2f46e01d.propertyFlags, cpropertyFlags_allocs = (C.VkMemoryPropertyFlags)(x.PropertyFlags), cgoAllocsUnknown
	allocs2f46e01d.Borrow(cpropertyFlags_allocs)

	var cheapIndex_allocs *cgoAllocMap
	ref2f46e01d.heapIndex, cheapIndex_allocs = (C.uint32_t)(x.HeapIndex), cgoAllocsUnknown
	allocs2f46e01d.Borrow(cheapIndex_allocs)

	x.ref2f46e01d = ref2f46e01d
	x.allocs2f46e01d = allocs2f46e01d
	return ref2f46e01d, allocs2f46e01d

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *MemoryType) PassValue() (C.VkMemoryType, *cgoAllocMap) {
	if x == nil {
		x = NewMemoryTypeRef(nil)
	} else if x.ref2f46e01d != nil {
		return *x.ref2f46e01d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *MemoryType) Deref() {
	if x.ref2f46e01d == nil {
		return
	}
	x.PropertyFlags = (MemoryPropertyFlags)(x.ref2f46e01d.propertyFlags)
	x.HeapIndex = (uint32)(x.ref2f46e01d.heapIndex)
}

// allocMemoryHeapMemory allocates memory for type C.VkMemoryHeap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryHeapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryHeapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryHeapValue = unsafe.Sizeof([1]C.VkMemoryHeap{})

// Ref returns a reference.
func (x *MemoryHeap) Ref() *C.VkMemoryHeap {
	if x == nil {
		return nil
	}
	return x.ref1eb195d5
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *MemoryHeap) Free() {
	if x != nil && x.allocs1eb195d5 != nil {
		x.allocs1eb195d5.(*cgoAllocMap).Free()
		x.ref1eb195d5 = nil
	}
}

// NewMemoryHeapRef initialises a new struct holding the reference to the originaitng C struct.
func NewMemoryHeapRef(ref *C.VkMemoryHeap) *MemoryHeap {
	if ref == nil {
		return nil
	}
	obj := new(MemoryHeap)
	obj.ref1eb195d5 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *MemoryHeap) PassRef() (*C.VkMemoryHeap, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1eb195d5 != nil {
		return x.ref1eb195d5, nil
	}
	mem1eb195d5 := allocMemoryHeapMemory(1)
	ref1eb195d5 := (*C.VkMemoryHeap)(mem1eb195d5)
	allocs1eb195d5 := new(cgoAllocMap)
	var csize_allocs *cgoAllocMap
	ref1eb195d5.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs1eb195d5.Borrow(csize_allocs)

	var cflags_allocs *cgoAllocMap
	ref1eb195d5.flags, cflags_allocs = (C.VkMemoryHeapFlags)(x.Flags), cgoAllocsUnknown
	allocs1eb195d5.Borrow(cflags_allocs)

	x.ref1eb195d5 = ref1eb195d5
	x.allocs1eb195d5 = allocs1eb195d5
	return ref1eb195d5, allocs1eb195d5

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *MemoryHeap) PassValue() (C.VkMemoryHeap, *cgoAllocMap) {
	if x == nil {
		x = NewMemoryHeapRef(nil)
	} else if x.ref1eb195d5 != nil {
		return *x.ref1eb195d5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *MemoryHeap) Deref() {
	if x.ref1eb195d5 == nil {
		return
	}
	x.Size = (DeviceSize)(x.ref1eb195d5.size)
	x.Flags = (MemoryHeapFlags)(x.ref1eb195d5.flags)
}

// allocPhysicalDeviceMemoryPropertiesMemory allocates memory for type C.VkPhysicalDeviceMemoryProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMemoryPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMemoryPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMemoryPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMemoryProperties{})

// allocA32MemoryTypeMemory allocates memory for type [32]C.VkMemoryType in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA32MemoryTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA32MemoryTypeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA32MemoryTypeValue = unsafe.Sizeof([1][32]C.VkMemoryType{})

// unpackA32MemoryType transforms a sliced Go data structure into plain C format.
func unpackA32MemoryType(x [32]MemoryType) (unpacked [32]C.VkMemoryType, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**[51][50][93]C.VkMemoryType) {
		go allocs.Free()
	})

	mem0 := allocA32MemoryTypeMemory(1)
	allocs.Add(mem0)
	v0 := (*[32]C.VkMemoryType)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[32]C.VkMemoryType)(mem0)
	return
}

// allocA16MemoryHeapMemory allocates memory for type [16]C.VkMemoryHeap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA16MemoryHeapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA16MemoryHeapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA16MemoryHeapValue = unsafe.Sizeof([1][16]C.VkMemoryHeap{})

// unpackA16MemoryHeap transforms a sliced Go data structure into plain C format.
func unpackA16MemoryHeap(x [16]MemoryHeap) (unpacked [16]C.VkMemoryHeap, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**[49][54][93]C.VkMemoryHeap) {
		go allocs.Free()
	})

	mem0 := allocA16MemoryHeapMemory(1)
	allocs.Add(mem0)
	v0 := (*[16]C.VkMemoryHeap)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[16]C.VkMemoryHeap)(mem0)
	return
}

// packA32MemoryType reads sliced Go data structure out from plain C format.
func packA32MemoryType(v *[32]MemoryType, ptr0 *[32]C.VkMemoryType) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewMemoryTypeRef(&ptr1)
	}
}

// packA16MemoryHeap reads sliced Go data structure out from plain C format.
func packA16MemoryHeap(v *[16]MemoryHeap, ptr0 *[16]C.VkMemoryHeap) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewMemoryHeapRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *PhysicalDeviceMemoryProperties) Ref() *C.VkPhysicalDeviceMemoryProperties {
	if x == nil {
		return nil
	}
	return x.ref3aabb5fd
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PhysicalDeviceMemoryProperties) Free() {
	if x != nil && x.allocs3aabb5fd != nil {
		x.allocs3aabb5fd.(*cgoAllocMap).Free()
		x.ref3aabb5fd = nil
	}
}

// NewPhysicalDeviceMemoryPropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewPhysicalDeviceMemoryPropertiesRef(ref *C.VkPhysicalDeviceMemoryProperties) *PhysicalDeviceMemoryProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMemoryProperties)
	obj.ref3aabb5fd = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PhysicalDeviceMemoryProperties) PassRef() (*C.VkPhysicalDeviceMemoryProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3aabb5fd != nil {
		return x.ref3aabb5fd, nil
	}
	mem3aabb5fd := allocPhysicalDeviceMemoryPropertiesMemory(1)
	ref3aabb5fd := (*C.VkPhysicalDeviceMemoryProperties)(mem3aabb5fd)
	allocs3aabb5fd := new(cgoAllocMap)
	var cmemoryTypeCount_allocs *cgoAllocMap
	ref3aabb5fd.memoryTypeCount, cmemoryTypeCount_allocs = (C.uint32_t)(x.MemoryTypeCount), cgoAllocsUnknown
	allocs3aabb5fd.Borrow(cmemoryTypeCount_allocs)

	var cmemoryTypes_allocs *cgoAllocMap
	ref3aabb5fd.memoryTypes, cmemoryTypes_allocs = unpackA32MemoryType(x.MemoryTypes)
	allocs3aabb5fd.Borrow(cmemoryTypes_allocs)

	var cmemoryHeapCount_allocs *cgoAllocMap
	ref3aabb5fd.memoryHeapCount, cmemoryHeapCount_allocs = (C.uint32_t)(x.MemoryHeapCount), cgoAllocsUnknown
	allocs3aabb5fd.Borrow(cmemoryHeapCount_allocs)

	var cmemoryHeaps_allocs *cgoAllocMap
	ref3aabb5fd.memoryHeaps, cmemoryHeaps_allocs = unpackA16MemoryHeap(x.MemoryHeaps)
	allocs3aabb5fd.Borrow(cmemoryHeaps_allocs)

	x.ref3aabb5fd = ref3aabb5fd
	x.allocs3aabb5fd = allocs3aabb5fd
	return ref3aabb5fd, allocs3aabb5fd

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PhysicalDeviceMemoryProperties) PassValue() (C.VkPhysicalDeviceMemoryProperties, *cgoAllocMap) {
	if x == nil {
		x = NewPhysicalDeviceMemoryPropertiesRef(nil)
	} else if x.ref3aabb5fd != nil {
		return *x.ref3aabb5fd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PhysicalDeviceMemoryProperties) Deref() {
	if x.ref3aabb5fd == nil {
		return
	}
	x.MemoryTypeCount = (uint32)(x.ref3aabb5fd.memoryTypeCount)
	packA32MemoryType(&x.MemoryTypes, (*[32]C.VkMemoryType)(unsafe.Pointer(&x.ref3aabb5fd.memoryTypes)))
	x.MemoryHeapCount = (uint32)(x.ref3aabb5fd.memoryHeapCount)
	packA16MemoryHeap(&x.MemoryHeaps, (*[16]C.VkMemoryHeap)(unsafe.Pointer(&x.ref3aabb5fd.memoryHeaps)))
}

// allocDeviceQueueCreateInfoMemory allocates memory for type C.VkDeviceQueueCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceQueueCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceQueueCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceQueueCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceQueueCreateInfo{})

// Ref returns a reference.
func (x *DeviceQueueCreateInfo) Ref() *C.VkDeviceQueueCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref6087b30d
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DeviceQueueCreateInfo) Free() {
	if x != nil && x.allocs6087b30d != nil {
		x.allocs6087b30d.(*cgoAllocMap).Free()
		x.ref6087b30d = nil
	}
}

// NewDeviceQueueCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDeviceQueueCreateInfoRef(ref *C.VkDeviceQueueCreateInfo) *DeviceQueueCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceQueueCreateInfo)
	obj.ref6087b30d = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DeviceQueueCreateInfo) PassRef() (*C.VkDeviceQueueCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6087b30d != nil {
		return x.ref6087b30d, nil
	}
	mem6087b30d := allocDeviceQueueCreateInfoMemory(1)
	ref6087b30d := (*C.VkDeviceQueueCreateInfo)(mem6087b30d)
	allocs6087b30d := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref6087b30d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6087b30d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6087b30d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6087b30d.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref6087b30d.flags, cflags_allocs = (C.VkDeviceQueueCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs6087b30d.Borrow(cflags_allocs)

	var cqueueFamilyIndex_allocs *cgoAllocMap
	ref6087b30d.queueFamilyIndex, cqueueFamilyIndex_allocs = (C.uint32_t)(x.QueueFamilyIndex), cgoAllocsUnknown
	allocs6087b30d.Borrow(cqueueFamilyIndex_allocs)

	var cqueueCount_allocs *cgoAllocMap
	ref6087b30d.queueCount, cqueueCount_allocs = (C.uint32_t)(x.QueueCount), cgoAllocsUnknown
	allocs6087b30d.Borrow(cqueueCount_allocs)

	var cpQueuePriorities_allocs *cgoAllocMap
	ref6087b30d.pQueuePriorities, cpQueuePriorities_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueuePriorities)).Data)), cgoAllocsUnknown
	allocs6087b30d.Borrow(cpQueuePriorities_allocs)

	x.ref6087b30d = ref6087b30d
	x.allocs6087b30d = allocs6087b30d
	return ref6087b30d, allocs6087b30d

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DeviceQueueCreateInfo) PassValue() (C.VkDeviceQueueCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewDeviceQueueCreateInfoRef(nil)
	} else if x.ref6087b30d != nil {
		return *x.ref6087b30d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DeviceQueueCreateInfo) Deref() {
	if x.ref6087b30d == nil {
		return
	}
	x.SType = (StructureType)(x.ref6087b30d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6087b30d.pNext))
	x.Flags = (DeviceQueueCreateFlags)(x.ref6087b30d.flags)
	x.QueueFamilyIndex = (uint32)(x.ref6087b30d.queueFamilyIndex)
	x.QueueCount = (uint32)(x.ref6087b30d.queueCount)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.PQueuePriorities))
	hxfc4425b.Data = uintptr(unsafe.Pointer(x.ref6087b30d.pQueuePriorities))
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

}

// allocDeviceCreateInfoMemory allocates memory for type C.VkDeviceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceCreateInfo{})

// unpackSDeviceQueueCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSDeviceQueueCreateInfo(x []DeviceQueueCreateInfo) (unpacked *C.VkDeviceQueueCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDeviceQueueCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDeviceQueueCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDeviceQueueCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDeviceQueueCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPhysicalDeviceFeatures transforms a sliced Go data structure into plain C format.
func unpackSPhysicalDeviceFeatures(x []PhysicalDeviceFeatures) (unpacked *C.VkPhysicalDeviceFeatures, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceFeatures) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceFeaturesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceFeatures)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceFeatures)(unsafe.Pointer(h.Data))
	return
}

// packSDeviceQueueCreateInfo reads sliced Go data structure out from plain C format.
func packSDeviceQueueCreateInfo(v []DeviceQueueCreateInfo, ptr0 *C.VkDeviceQueueCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDeviceQueueCreateInfoValue]C.VkDeviceQueueCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceQueueCreateInfoRef(&ptr1)
	}
}

// packSPhysicalDeviceFeatures reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceFeatures(v []PhysicalDeviceFeatures, ptr0 *C.VkPhysicalDeviceFeatures) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceFeaturesValue]C.VkPhysicalDeviceFeatures)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceFeaturesRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *DeviceCreateInfo) Ref() *C.VkDeviceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc0d8b997
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DeviceCreateInfo) Free() {
	if x != nil && x.allocsc0d8b997 != nil {
		x.allocsc0d8b997.(*cgoAllocMap).Free()
		x.refc0d8b997 = nil
	}
}

// NewDeviceCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDeviceCreateInfoRef(ref *C.VkDeviceCreateInfo) *DeviceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceCreateInfo)
	obj.refc0d8b997 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DeviceCreateInfo) PassRef() (*C.VkDeviceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0d8b997 != nil {
		return x.refc0d8b997, nil
	}
	memc0d8b997 := allocDeviceCreateInfoMemory(1)
	refc0d8b997 := (*C.VkDeviceCreateInfo)(memc0d8b997)
	allocsc0d8b997 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refc0d8b997.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc0d8b997.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc0d8b997.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc0d8b997.flags, cflags_allocs = (C.VkDeviceCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cflags_allocs)

	var cqueueCreateInfoCount_allocs *cgoAllocMap
	refc0d8b997.queueCreateInfoCount, cqueueCreateInfoCount_allocs = (C.uint32_t)(x.QueueCreateInfoCount), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cqueueCreateInfoCount_allocs)

	var cpQueueCreateInfos_allocs *cgoAllocMap
	refc0d8b997.pQueueCreateInfos, cpQueueCreateInfos_allocs = unpackSDeviceQueueCreateInfo(x.PQueueCreateInfos)
	allocsc0d8b997.Borrow(cpQueueCreateInfos_allocs)

	var cenabledLayerCount_allocs *cgoAllocMap
	refc0d8b997.enabledLayerCount, cenabledLayerCount_allocs = (C.uint32_t)(x.EnabledLayerCount), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cenabledLayerCount_allocs)

	var cppEnabledLayerNames_allocs *cgoAllocMap
	refc0d8b997.ppEnabledLayerNames, cppEnabledLayerNames_allocs = unpackSString(x.PpEnabledLayerNames)
	allocsc0d8b997.Borrow(cppEnabledLayerNames_allocs)

	var cenabledExtensionCount_allocs *cgoAllocMap
	refc0d8b997.enabledExtensionCount, cenabledExtensionCount_allocs = (C.uint32_t)(x.EnabledExtensionCount), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cenabledExtensionCount_allocs)

	var cppEnabledExtensionNames_allocs *cgoAllocMap
	refc0d8b997.ppEnabledExtensionNames, cppEnabledExtensionNames_allocs = unpackSString(x.PpEnabledExtensionNames)
	allocsc0d8b997.Borrow(cppEnabledExtensionNames_allocs)

	var cpEnabledFeatures_allocs *cgoAllocMap
	refc0d8b997.pEnabledFeatures, cpEnabledFeatures_allocs = unpackSPhysicalDeviceFeatures(x.PEnabledFeatures)
	allocsc0d8b997.Borrow(cpEnabledFeatures_allocs)

	x.refc0d8b997 = refc0d8b997
	x.allocsc0d8b997 = allocsc0d8b997
	return refc0d8b997, allocsc0d8b997

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DeviceCreateInfo) PassValue() (C.VkDeviceCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewDeviceCreateInfoRef(nil)
	} else if x.refc0d8b997 != nil {
		return *x.refc0d8b997, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DeviceCreateInfo) Deref() {
	if x.refc0d8b997 == nil {
		return
	}
	x.SType = (StructureType)(x.refc0d8b997.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc0d8b997.pNext))
	x.Flags = (DeviceCreateFlags)(x.refc0d8b997.flags)
	x.QueueCreateInfoCount = (uint32)(x.refc0d8b997.queueCreateInfoCount)
	packSDeviceQueueCreateInfo(x.PQueueCreateInfos, x.refc0d8b997.pQueueCreateInfos)
	x.EnabledLayerCount = (uint32)(x.refc0d8b997.enabledLayerCount)
	packSString(x.PpEnabledLayerNames, x.refc0d8b997.ppEnabledLayerNames)
	x.EnabledExtensionCount = (uint32)(x.refc0d8b997.enabledExtensionCount)
	packSString(x.PpEnabledExtensionNames, x.refc0d8b997.ppEnabledExtensionNames)
	packSPhysicalDeviceFeatures(x.PEnabledFeatures, x.refc0d8b997.pEnabledFeatures)
}

// allocExtensionPropertiesMemory allocates memory for type C.VkExtensionProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtensionPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtensionPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExtensionPropertiesValue = unsafe.Sizeof([1]C.VkExtensionProperties{})

// Ref returns a reference.
func (x *ExtensionProperties) Ref() *C.VkExtensionProperties {
	if x == nil {
		return nil
	}
	return x.ref2f001956
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ExtensionProperties) Free() {
	if x != nil && x.allocs2f001956 != nil {
		x.allocs2f001956.(*cgoAllocMap).Free()
		x.ref2f001956 = nil
	}
}

// NewExtensionPropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewExtensionPropertiesRef(ref *C.VkExtensionProperties) *ExtensionProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExtensionProperties)
	obj.ref2f001956 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ExtensionProperties) PassRef() (*C.VkExtensionProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f001956 != nil {
		return x.ref2f001956, nil
	}
	mem2f001956 := allocExtensionPropertiesMemory(1)
	ref2f001956 := (*C.VkExtensionProperties)(mem2f001956)
	allocs2f001956 := new(cgoAllocMap)
	var cextensionName_allocs *cgoAllocMap
	ref2f001956.extensionName, cextensionName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.ExtensionName)), cgoAllocsUnknown
	allocs2f001956.Borrow(cextensionName_allocs)

	var cspecVersion_allocs *cgoAllocMap
	ref2f001956.specVersion, cspecVersion_allocs = (C.uint32_t)(x.SpecVersion), cgoAllocsUnknown
	allocs2f001956.Borrow(cspecVersion_allocs)

	x.ref2f001956 = ref2f001956
	x.allocs2f001956 = allocs2f001956
	return ref2f001956, allocs2f001956

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ExtensionProperties) PassValue() (C.VkExtensionProperties, *cgoAllocMap) {
	if x == nil {
		x = NewExtensionPropertiesRef(nil)
	} else if x.ref2f001956 != nil {
		return *x.ref2f001956, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ExtensionProperties) Deref() {
	if x.ref2f001956 == nil {
		return
	}
	x.ExtensionName = *(*[256]byte)(unsafe.Pointer(&x.ref2f001956.extensionName))
	x.SpecVersion = (uint32)(x.ref2f001956.specVersion)
}

// allocLayerPropertiesMemory allocates memory for type C.VkLayerProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLayerPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLayerPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLayerPropertiesValue = unsafe.Sizeof([1]C.VkLayerProperties{})

// Ref returns a reference.
func (x *LayerProperties) Ref() *C.VkLayerProperties {
	if x == nil {
		return nil
	}
	return x.refd9407ce7
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *LayerProperties) Free() {
	if x != nil && x.allocsd9407ce7 != nil {
		x.allocsd9407ce7.(*cgoAllocMap).Free()
		x.refd9407ce7 = nil
	}
}

// NewLayerPropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewLayerPropertiesRef(ref *C.VkLayerProperties) *LayerProperties {
	if ref == nil {
		return nil
	}
	obj := new(LayerProperties)
	obj.refd9407ce7 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *LayerProperties) PassRef() (*C.VkLayerProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9407ce7 != nil {
		return x.refd9407ce7, nil
	}
	memd9407ce7 := allocLayerPropertiesMemory(1)
	refd9407ce7 := (*C.VkLayerProperties)(memd9407ce7)
	allocsd9407ce7 := new(cgoAllocMap)
	var clayerName_allocs *cgoAllocMap
	refd9407ce7.layerName, clayerName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.LayerName)), cgoAllocsUnknown
	allocsd9407ce7.Borrow(clayerName_allocs)

	var cspecVersion_allocs *cgoAllocMap
	refd9407ce7.specVersion, cspecVersion_allocs = (C.uint32_t)(x.SpecVersion), cgoAllocsUnknown
	allocsd9407ce7.Borrow(cspecVersion_allocs)

	var cimplementationVersion_allocs *cgoAllocMap
	refd9407ce7.implementationVersion, cimplementationVersion_allocs = (C.uint32_t)(x.ImplementationVersion), cgoAllocsUnknown
	allocsd9407ce7.Borrow(cimplementationVersion_allocs)

	var cdescription_allocs *cgoAllocMap
	refd9407ce7.description, cdescription_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Description)), cgoAllocsUnknown
	allocsd9407ce7.Borrow(cdescription_allocs)

	x.refd9407ce7 = refd9407ce7
	x.allocsd9407ce7 = allocsd9407ce7
	return refd9407ce7, allocsd9407ce7

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *LayerProperties) PassValue() (C.VkLayerProperties, *cgoAllocMap) {
	if x == nil {
		x = NewLayerPropertiesRef(nil)
	} else if x.refd9407ce7 != nil {
		return *x.refd9407ce7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *LayerProperties) Deref() {
	if x.refd9407ce7 == nil {
		return
	}
	x.LayerName = *(*[256]byte)(unsafe.Pointer(&x.refd9407ce7.layerName))
	x.SpecVersion = (uint32)(x.refd9407ce7.specVersion)
	x.ImplementationVersion = (uint32)(x.refd9407ce7.implementationVersion)
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.refd9407ce7.description))
}

// allocSubmitInfoMemory allocates memory for type C.VkSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubmitInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubmitInfoValue = unsafe.Sizeof([1]C.VkSubmitInfo{})

// Ref returns a reference.
func (x *SubmitInfo) Ref() *C.VkSubmitInfo {
	if x == nil {
		return nil
	}
	return x.ref22884025
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SubmitInfo) Free() {
	if x != nil && x.allocs22884025 != nil {
		x.allocs22884025.(*cgoAllocMap).Free()
		x.ref22884025 = nil
	}
}

// NewSubmitInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewSubmitInfoRef(ref *C.VkSubmitInfo) *SubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(SubmitInfo)
	obj.ref22884025 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SubmitInfo) PassRef() (*C.VkSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref22884025 != nil {
		return x.ref22884025, nil
	}
	mem22884025 := allocSubmitInfoMemory(1)
	ref22884025 := (*C.VkSubmitInfo)(mem22884025)
	allocs22884025 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref22884025.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs22884025.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref22884025.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs22884025.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	ref22884025.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocs22884025.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphores_allocs *cgoAllocMap
	ref22884025.pWaitSemaphores, cpWaitSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpWaitSemaphores_allocs)

	var cpWaitDstStageMask_allocs *cgoAllocMap
	ref22884025.pWaitDstStageMask, cpWaitDstStageMask_allocs = (*C.VkPipelineStageFlags)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitDstStageMask)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpWaitDstStageMask_allocs)

	var ccommandBufferCount_allocs *cgoAllocMap
	ref22884025.commandBufferCount, ccommandBufferCount_allocs = (C.uint32_t)(x.CommandBufferCount), cgoAllocsUnknown
	allocs22884025.Borrow(ccommandBufferCount_allocs)

	var cpCommandBuffers_allocs *cgoAllocMap
	ref22884025.pCommandBuffers, cpCommandBuffers_allocs = (*C.VkCommandBuffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCommandBuffers)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpCommandBuffers_allocs)

	var csignalSemaphoreCount_allocs *cgoAllocMap
	ref22884025.signalSemaphoreCount, csignalSemaphoreCount_allocs = (C.uint32_t)(x.SignalSemaphoreCount), cgoAllocsUnknown
	allocs22884025.Borrow(csignalSemaphoreCount_allocs)

	var cpSignalSemaphores_allocs *cgoAllocMap
	ref22884025.pSignalSemaphores, cpSignalSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpSignalSemaphores_allocs)

	x.ref22884025 = ref22884025
	x.allocs22884025 = allocs22884025
	return ref22884025, allocs22884025

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SubmitInfo) PassValue() (C.VkSubmitInfo, *cgoAllocMap) {
	if x == nil {
		x = NewSubmitInfoRef(nil)
	} else if x.ref22884025 != nil {
		return *x.ref22884025, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SubmitInfo) Deref() {
	if x.ref22884025 == nil {
		return
	}
	x.SType = (StructureType)(x.ref22884025.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref22884025.pNext))
	x.WaitSemaphoreCount = (uint32)(x.ref22884025.waitSemaphoreCount)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxf95e7c8.Data = uintptr(unsafe.Pointer(x.ref22884025.pWaitSemaphores))
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.PWaitDstStageMask))
	hxff2234b.Data = uintptr(unsafe.Pointer(x.ref22884025.pWaitDstStageMask))
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	x.CommandBufferCount = (uint32)(x.ref22884025.commandBufferCount)
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.PCommandBuffers))
	hxff73280.Data = uintptr(unsafe.Pointer(x.ref22884025.pCommandBuffers))
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	x.SignalSemaphoreCount = (uint32)(x.ref22884025.signalSemaphoreCount)
	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores))
	hxfa9955c.Data = uintptr(unsafe.Pointer(x.ref22884025.pSignalSemaphores))
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

}

// allocMemoryAllocateInfoMemory allocates memory for type C.VkMemoryAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryAllocateInfoValue = unsafe.Sizeof([1]C.VkMemoryAllocateInfo{})

// Ref returns a reference.
func (x *MemoryAllocateInfo) Ref() *C.VkMemoryAllocateInfo {
	if x == nil {
		return nil
	}
	return x.ref31032b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *MemoryAllocateInfo) Free() {
	if x != nil && x.allocs31032b != nil {
		x.allocs31032b.(*cgoAllocMap).Free()
		x.ref31032b = nil
	}
}

// NewMemoryAllocateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewMemoryAllocateInfoRef(ref *C.VkMemoryAllocateInfo) *MemoryAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryAllocateInfo)
	obj.ref31032b = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *MemoryAllocateInfo) PassRef() (*C.VkMemoryAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref31032b != nil {
		return x.ref31032b, nil
	}
	mem31032b := allocMemoryAllocateInfoMemory(1)
	ref31032b := (*C.VkMemoryAllocateInfo)(mem31032b)
	allocs31032b := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref31032b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs31032b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref31032b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs31032b.Borrow(cpNext_allocs)

	var callocationSize_allocs *cgoAllocMap
	ref31032b.allocationSize, callocationSize_allocs = (C.VkDeviceSize)(x.AllocationSize), cgoAllocsUnknown
	allocs31032b.Borrow(callocationSize_allocs)

	var cmemoryTypeIndex_allocs *cgoAllocMap
	ref31032b.memoryTypeIndex, cmemoryTypeIndex_allocs = (C.uint32_t)(x.MemoryTypeIndex), cgoAllocsUnknown
	allocs31032b.Borrow(cmemoryTypeIndex_allocs)

	x.ref31032b = ref31032b
	x.allocs31032b = allocs31032b
	return ref31032b, allocs31032b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *MemoryAllocateInfo) PassValue() (C.VkMemoryAllocateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewMemoryAllocateInfoRef(nil)
	} else if x.ref31032b != nil {
		return *x.ref31032b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *MemoryAllocateInfo) Deref() {
	if x.ref31032b == nil {
		return
	}
	x.SType = (StructureType)(x.ref31032b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref31032b.pNext))
	x.AllocationSize = (DeviceSize)(x.ref31032b.allocationSize)
	x.MemoryTypeIndex = (uint32)(x.ref31032b.memoryTypeIndex)
}

// allocMappedMemoryRangeMemory allocates memory for type C.VkMappedMemoryRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMappedMemoryRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMappedMemoryRangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMappedMemoryRangeValue = unsafe.Sizeof([1]C.VkMappedMemoryRange{})

// Ref returns a reference.
func (x *MappedMemoryRange) Ref() *C.VkMappedMemoryRange {
	if x == nil {
		return nil
	}
	return x.ref42a37320
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *MappedMemoryRange) Free() {
	if x != nil && x.allocs42a37320 != nil {
		x.allocs42a37320.(*cgoAllocMap).Free()
		x.ref42a37320 = nil
	}
}

// NewMappedMemoryRangeRef initialises a new struct holding the reference to the originaitng C struct.
func NewMappedMemoryRangeRef(ref *C.VkMappedMemoryRange) *MappedMemoryRange {
	if ref == nil {
		return nil
	}
	obj := new(MappedMemoryRange)
	obj.ref42a37320 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *MappedMemoryRange) PassRef() (*C.VkMappedMemoryRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref42a37320 != nil {
		return x.ref42a37320, nil
	}
	mem42a37320 := allocMappedMemoryRangeMemory(1)
	ref42a37320 := (*C.VkMappedMemoryRange)(mem42a37320)
	allocs42a37320 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref42a37320.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs42a37320.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref42a37320.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs42a37320.Borrow(cpNext_allocs)

	var cmemory_allocs *cgoAllocMap
	ref42a37320.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs42a37320.Borrow(cmemory_allocs)

	var coffset_allocs *cgoAllocMap
	ref42a37320.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs42a37320.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref42a37320.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs42a37320.Borrow(csize_allocs)

	x.ref42a37320 = ref42a37320
	x.allocs42a37320 = allocs42a37320
	return ref42a37320, allocs42a37320

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *MappedMemoryRange) PassValue() (C.VkMappedMemoryRange, *cgoAllocMap) {
	if x == nil {
		x = NewMappedMemoryRangeRef(nil)
	} else if x.ref42a37320 != nil {
		return *x.ref42a37320, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *MappedMemoryRange) Deref() {
	if x.ref42a37320 == nil {
		return
	}
	x.SType = (StructureType)(x.ref42a37320.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref42a37320.pNext))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref42a37320.memory))
	x.Offset = (DeviceSize)(x.ref42a37320.offset)
	x.Size = (DeviceSize)(x.ref42a37320.size)
}

// allocMemoryRequirementsMemory allocates memory for type C.VkMemoryRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryRequirementsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryRequirementsValue = unsafe.Sizeof([1]C.VkMemoryRequirements{})

// Ref returns a reference.
func (x *MemoryRequirements) Ref() *C.VkMemoryRequirements {
	if x == nil {
		return nil
	}
	return x.ref5259fc6b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *MemoryRequirements) Free() {
	if x != nil && x.allocs5259fc6b != nil {
		x.allocs5259fc6b.(*cgoAllocMap).Free()
		x.ref5259fc6b = nil
	}
}

// NewMemoryRequirementsRef initialises a new struct holding the reference to the originaitng C struct.
func NewMemoryRequirementsRef(ref *C.VkMemoryRequirements) *MemoryRequirements {
	if ref == nil {
		return nil
	}
	obj := new(MemoryRequirements)
	obj.ref5259fc6b = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *MemoryRequirements) PassRef() (*C.VkMemoryRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5259fc6b != nil {
		return x.ref5259fc6b, nil
	}
	mem5259fc6b := allocMemoryRequirementsMemory(1)
	ref5259fc6b := (*C.VkMemoryRequirements)(mem5259fc6b)
	allocs5259fc6b := new(cgoAllocMap)
	var csize_allocs *cgoAllocMap
	ref5259fc6b.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs5259fc6b.Borrow(csize_allocs)

	var calignment_allocs *cgoAllocMap
	ref5259fc6b.alignment, calignment_allocs = (C.VkDeviceSize)(x.Alignment), cgoAllocsUnknown
	allocs5259fc6b.Borrow(calignment_allocs)

	var cmemoryTypeBits_allocs *cgoAllocMap
	ref5259fc6b.memoryTypeBits, cmemoryTypeBits_allocs = (C.uint32_t)(x.MemoryTypeBits), cgoAllocsUnknown
	allocs5259fc6b.Borrow(cmemoryTypeBits_allocs)

	x.ref5259fc6b = ref5259fc6b
	x.allocs5259fc6b = allocs5259fc6b
	return ref5259fc6b, allocs5259fc6b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *MemoryRequirements) PassValue() (C.VkMemoryRequirements, *cgoAllocMap) {
	if x == nil {
		x = NewMemoryRequirementsRef(nil)
	} else if x.ref5259fc6b != nil {
		return *x.ref5259fc6b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *MemoryRequirements) Deref() {
	if x.ref5259fc6b == nil {
		return
	}
	x.Size = (DeviceSize)(x.ref5259fc6b.size)
	x.Alignment = (DeviceSize)(x.ref5259fc6b.alignment)
	x.MemoryTypeBits = (uint32)(x.ref5259fc6b.memoryTypeBits)
}

// allocSparseImageFormatPropertiesMemory allocates memory for type C.VkSparseImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkSparseImageFormatProperties{})

// Ref returns a reference.
func (x *SparseImageFormatProperties) Ref() *C.VkSparseImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.ref2c12cf44
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SparseImageFormatProperties) Free() {
	if x != nil && x.allocs2c12cf44 != nil {
		x.allocs2c12cf44.(*cgoAllocMap).Free()
		x.ref2c12cf44 = nil
	}
}

// NewSparseImageFormatPropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewSparseImageFormatPropertiesRef(ref *C.VkSparseImageFormatProperties) *SparseImageFormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageFormatProperties)
	obj.ref2c12cf44 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SparseImageFormatProperties) PassRef() (*C.VkSparseImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2c12cf44 != nil {
		return x.ref2c12cf44, nil
	}
	mem2c12cf44 := allocSparseImageFormatPropertiesMemory(1)
	ref2c12cf44 := (*C.VkSparseImageFormatProperties)(mem2c12cf44)
	allocs2c12cf44 := new(cgoAllocMap)
	var caspectMask_allocs *cgoAllocMap
	ref2c12cf44.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs2c12cf44.Borrow(caspectMask_allocs)

	var cimageGranularity_allocs *cgoAllocMap
	ref2c12cf44.imageGranularity, cimageGranularity_allocs = x.ImageGranularity.PassValue()
	allocs2c12cf44.Borrow(cimageGranularity_allocs)

	var cflags_allocs *cgoAllocMap
	ref2c12cf44.flags, cflags_allocs = (C.VkSparseImageFormatFlags)(x.Flags), cgoAllocsUnknown
	allocs2c12cf44.Borrow(cflags_allocs)

	x.ref2c12cf44 = ref2c12cf44
	x.allocs2c12cf44 = allocs2c12cf44
	return ref2c12cf44, allocs2c12cf44

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SparseImageFormatProperties) PassValue() (C.VkSparseImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		x = NewSparseImageFormatPropertiesRef(nil)
	} else if x.ref2c12cf44 != nil {
		return *x.ref2c12cf44, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SparseImageFormatProperties) Deref() {
	if x.ref2c12cf44 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.ref2c12cf44.aspectMask)
	x.ImageGranularity = *NewExtent3DRef(&x.ref2c12cf44.imageGranularity)
	x.Flags = (SparseImageFormatFlags)(x.ref2c12cf44.flags)
}

// allocSparseImageMemoryRequirementsMemory allocates memory for type C.VkSparseImageMemoryRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryRequirementsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageMemoryRequirementsValue = unsafe.Sizeof([1]C.VkSparseImageMemoryRequirements{})

// Ref returns a reference.
func (x *SparseImageMemoryRequirements) Ref() *C.VkSparseImageMemoryRequirements {
	if x == nil {
		return nil
	}
	return x.ref685a2323
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SparseImageMemoryRequirements) Free() {
	if x != nil && x.allocs685a2323 != nil {
		x.allocs685a2323.(*cgoAllocMap).Free()
		x.ref685a2323 = nil
	}
}

// NewSparseImageMemoryRequirementsRef initialises a new struct holding the reference to the originaitng C struct.
func NewSparseImageMemoryRequirementsRef(ref *C.VkSparseImageMemoryRequirements) *SparseImageMemoryRequirements {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryRequirements)
	obj.ref685a2323 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SparseImageMemoryRequirements) PassRef() (*C.VkSparseImageMemoryRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref685a2323 != nil {
		return x.ref685a2323, nil
	}
	mem685a2323 := allocSparseImageMemoryRequirementsMemory(1)
	ref685a2323 := (*C.VkSparseImageMemoryRequirements)(mem685a2323)
	allocs685a2323 := new(cgoAllocMap)
	var cformatProperties_allocs *cgoAllocMap
	ref685a2323.formatProperties, cformatProperties_allocs = x.FormatProperties.PassValue()
	allocs685a2323.Borrow(cformatProperties_allocs)

	var cimageMipTailFirstLod_allocs *cgoAllocMap
	ref685a2323.imageMipTailFirstLod, cimageMipTailFirstLod_allocs = (C.uint32_t)(x.ImageMipTailFirstLod), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailFirstLod_allocs)

	var cimageMipTailSize_allocs *cgoAllocMap
	ref685a2323.imageMipTailSize, cimageMipTailSize_allocs = (C.VkDeviceSize)(x.ImageMipTailSize), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailSize_allocs)

	var cimageMipTailOffset_allocs *cgoAllocMap
	ref685a2323.imageMipTailOffset, cimageMipTailOffset_allocs = (C.VkDeviceSize)(x.ImageMipTailOffset), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailOffset_allocs)

	var cimageMipTailStride_allocs *cgoAllocMap
	ref685a2323.imageMipTailStride, cimageMipTailStride_allocs = (C.VkDeviceSize)(x.ImageMipTailStride), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailStride_allocs)

	x.ref685a2323 = ref685a2323
	x.allocs685a2323 = allocs685a2323
	return ref685a2323, allocs685a2323

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SparseImageMemoryRequirements) PassValue() (C.VkSparseImageMemoryRequirements, *cgoAllocMap) {
	if x == nil {
		x = NewSparseImageMemoryRequirementsRef(nil)
	} else if x.ref685a2323 != nil {
		return *x.ref685a2323, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SparseImageMemoryRequirements) Deref() {
	if x.ref685a2323 == nil {
		return
	}
	x.FormatProperties = *NewSparseImageFormatPropertiesRef(&x.ref685a2323.formatProperties)
	x.ImageMipTailFirstLod = (uint32)(x.ref685a2323.imageMipTailFirstLod)
	x.ImageMipTailSize = (DeviceSize)(x.ref685a2323.imageMipTailSize)
	x.ImageMipTailOffset = (DeviceSize)(x.ref685a2323.imageMipTailOffset)
	x.ImageMipTailStride = (DeviceSize)(x.ref685a2323.imageMipTailStride)
}

// allocSparseMemoryBindMemory allocates memory for type C.VkSparseMemoryBind in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseMemoryBindMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseMemoryBindValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

// Ref returns a reference.
func (x *SparseMemoryBind) Ref() *C.VkSparseMemoryBind {
	if x == nil {
		return nil
	}
	return x.ref5bf418e8
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SparseMemoryBind) Free() {
	if x != nil && x.allocs5bf418e8 != nil {
		x.allocs5bf418e8.(*cgoAllocMap).Free()
		x.ref5bf418e8 = nil
	}
}

// NewSparseMemoryBindRef initialises a new struct holding the reference to the originaitng C struct.
func NewSparseMemoryBindRef(ref *C.VkSparseMemoryBind) *SparseMemoryBind {
	if ref == nil {
		return nil
	}
	obj := new(SparseMemoryBind)
	obj.ref5bf418e8 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SparseMemoryBind) PassRef() (*C.VkSparseMemoryBind, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5bf418e8 != nil {
		return x.ref5bf418e8, nil
	}
	mem5bf418e8 := allocSparseMemoryBindMemory(1)
	ref5bf418e8 := (*C.VkSparseMemoryBind)(mem5bf418e8)
	allocs5bf418e8 := new(cgoAllocMap)
	var cresourceOffset_allocs *cgoAllocMap
	ref5bf418e8.resourceOffset, cresourceOffset_allocs = (C.VkDeviceSize)(x.ResourceOffset), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cresourceOffset_allocs)

	var csize_allocs *cgoAllocMap
	ref5bf418e8.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs5bf418e8.Borrow(csize_allocs)

	var cmemory_allocs *cgoAllocMap
	ref5bf418e8.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	ref5bf418e8.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cmemoryOffset_allocs)

	var cflags_allocs *cgoAllocMap
	ref5bf418e8.flags, cflags_allocs = (C.VkSparseMemoryBindFlags)(x.Flags), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cflags_allocs)

	x.ref5bf418e8 = ref5bf418e8
	x.allocs5bf418e8 = allocs5bf418e8
	return ref5bf418e8, allocs5bf418e8

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SparseMemoryBind) PassValue() (C.VkSparseMemoryBind, *cgoAllocMap) {
	if x == nil {
		x = NewSparseMemoryBindRef(nil)
	} else if x.ref5bf418e8 != nil {
		return *x.ref5bf418e8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SparseMemoryBind) Deref() {
	if x.ref5bf418e8 == nil {
		return
	}
	x.ResourceOffset = (DeviceSize)(x.ref5bf418e8.resourceOffset)
	x.Size = (DeviceSize)(x.ref5bf418e8.size)
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref5bf418e8.memory))
	x.MemoryOffset = (DeviceSize)(x.ref5bf418e8.memoryOffset)
	x.Flags = (SparseMemoryBindFlags)(x.ref5bf418e8.flags)
}

// allocSparseBufferMemoryBindInfoMemory allocates memory for type C.VkSparseBufferMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseBufferMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseBufferMemoryBindInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseBufferMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseBufferMemoryBindInfo{})

// unpackSSparseMemoryBind transforms a sliced Go data structure into plain C format.
func unpackSSparseMemoryBind(x []SparseMemoryBind) (unpacked *C.VkSparseMemoryBind, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseMemoryBind) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseMemoryBindMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseMemoryBind)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseMemoryBind)(unsafe.Pointer(h.Data))
	return
}

const sizeOfSparseMemoryBindValue = unsafe.Sizeof([1]C.VkSparseMemoryBind{})

// packSSparseMemoryBind reads sliced Go data structure out from plain C format.
func packSSparseMemoryBind(v []SparseMemoryBind, ptr0 *C.VkSparseMemoryBind) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseMemoryBindValue]C.VkSparseMemoryBind)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseMemoryBindRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *SparseBufferMemoryBindInfo) Ref() *C.VkSparseBufferMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.refebcaf40c
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SparseBufferMemoryBindInfo) Free() {
	if x != nil && x.allocsebcaf40c != nil {
		x.allocsebcaf40c.(*cgoAllocMap).Free()
		x.refebcaf40c = nil
	}
}

// NewSparseBufferMemoryBindInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewSparseBufferMemoryBindInfoRef(ref *C.VkSparseBufferMemoryBindInfo) *SparseBufferMemoryBindInfo {
	if ref == nil {
		return nil
	}
	obj := new(SparseBufferMemoryBindInfo)
	obj.refebcaf40c = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SparseBufferMemoryBindInfo) PassRef() (*C.VkSparseBufferMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refebcaf40c != nil {
		return x.refebcaf40c, nil
	}
	memebcaf40c := allocSparseBufferMemoryBindInfoMemory(1)
	refebcaf40c := (*C.VkSparseBufferMemoryBindInfo)(memebcaf40c)
	allocsebcaf40c := new(cgoAllocMap)
	var cbuffer_allocs *cgoAllocMap
	refebcaf40c.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsebcaf40c.Borrow(cbuffer_allocs)

	var cbindCount_allocs *cgoAllocMap
	refebcaf40c.bindCount, cbindCount_allocs = (C.uint32_t)(x.BindCount), cgoAllocsUnknown
	allocsebcaf40c.Borrow(cbindCount_allocs)

	var cpBinds_allocs *cgoAllocMap
	refebcaf40c.pBinds, cpBinds_allocs = unpackSSparseMemoryBind(x.PBinds)
	allocsebcaf40c.Borrow(cpBinds_allocs)

	x.refebcaf40c = refebcaf40c
	x.allocsebcaf40c = allocsebcaf40c
	return refebcaf40c, allocsebcaf40c

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SparseBufferMemoryBindInfo) PassValue() (C.VkSparseBufferMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		x = NewSparseBufferMemoryBindInfoRef(nil)
	} else if x.refebcaf40c != nil {
		return *x.refebcaf40c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SparseBufferMemoryBindInfo) Deref() {
	if x.refebcaf40c == nil {
		return
	}
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refebcaf40c.buffer))
	x.BindCount = (uint32)(x.refebcaf40c.bindCount)
	packSSparseMemoryBind(x.PBinds, x.refebcaf40c.pBinds)
}

// allocSparseImageOpaqueMemoryBindInfoMemory allocates memory for type C.VkSparseImageOpaqueMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageOpaqueMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageOpaqueMemoryBindInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageOpaqueMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseImageOpaqueMemoryBindInfo{})

// Ref returns a reference.
func (x *SparseImageOpaqueMemoryBindInfo) Ref() *C.VkSparseImageOpaqueMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.reffb1b3d56
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SparseImageOpaqueMemoryBindInfo) Free() {
	if x != nil && x.allocsfb1b3d56 != nil {
		x.allocsfb1b3d56.(*cgoAllocMap).Free()
		x.reffb1b3d56 = nil
	}
}

// NewSparseImageOpaqueMemoryBindInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewSparseImageOpaqueMemoryBindInfoRef(ref *C.VkSparseImageOpaqueMemoryBindInfo) *SparseImageOpaqueMemoryBindInfo {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageOpaqueMemoryBindInfo)
	obj.reffb1b3d56 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SparseImageOpaqueMemoryBindInfo) PassRef() (*C.VkSparseImageOpaqueMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffb1b3d56 != nil {
		return x.reffb1b3d56, nil
	}
	memfb1b3d56 := allocSparseImageOpaqueMemoryBindInfoMemory(1)
	reffb1b3d56 := (*C.VkSparseImageOpaqueMemoryBindInfo)(memfb1b3d56)
	allocsfb1b3d56 := new(cgoAllocMap)
	var cimage_allocs *cgoAllocMap
	reffb1b3d56.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocsfb1b3d56.Borrow(cimage_allocs)

	var cbindCount_allocs *cgoAllocMap
	reffb1b3d56.bindCount, cbindCount_allocs = (C.uint32_t)(x.BindCount), cgoAllocsUnknown
	allocsfb1b3d56.Borrow(cbindCount_allocs)

	var cpBinds_allocs *cgoAllocMap
	reffb1b3d56.pBinds, cpBinds_allocs = unpackSSparseMemoryBind(x.PBinds)
	allocsfb1b3d56.Borrow(cpBinds_allocs)

	x.reffb1b3d56 = reffb1b3d56
	x.allocsfb1b3d56 = allocsfb1b3d56
	return reffb1b3d56, allocsfb1b3d56

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SparseImageOpaqueMemoryBindInfo) PassValue() (C.VkSparseImageOpaqueMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		x = NewSparseImageOpaqueMemoryBindInfoRef(nil)
	} else if x.reffb1b3d56 != nil {
		return *x.reffb1b3d56, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SparseImageOpaqueMemoryBindInfo) Deref() {
	if x.reffb1b3d56 == nil {
		return
	}
	x.Image = *(*Image)(unsafe.Pointer(&x.reffb1b3d56.image))
	x.BindCount = (uint32)(x.reffb1b3d56.bindCount)
	packSSparseMemoryBind(x.PBinds, x.reffb1b3d56.pBinds)
}

// allocImageSubresourceMemory allocates memory for type C.VkImageSubresource in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSubresourceValue = unsafe.Sizeof([1]C.VkImageSubresource{})

// Ref returns a reference.
func (x *ImageSubresource) Ref() *C.VkImageSubresource {
	if x == nil {
		return nil
	}
	return x.reffeaa0d8a
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageSubresource) Free() {
	if x != nil && x.allocsfeaa0d8a != nil {
		x.allocsfeaa0d8a.(*cgoAllocMap).Free()
		x.reffeaa0d8a = nil
	}
}

// NewImageSubresourceRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageSubresourceRef(ref *C.VkImageSubresource) *ImageSubresource {
	if ref == nil {
		return nil
	}
	obj := new(ImageSubresource)
	obj.reffeaa0d8a = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageSubresource) PassRef() (*C.VkImageSubresource, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffeaa0d8a != nil {
		return x.reffeaa0d8a, nil
	}
	memfeaa0d8a := allocImageSubresourceMemory(1)
	reffeaa0d8a := (*C.VkImageSubresource)(memfeaa0d8a)
	allocsfeaa0d8a := new(cgoAllocMap)
	var caspectMask_allocs *cgoAllocMap
	reffeaa0d8a.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocsfeaa0d8a.Borrow(caspectMask_allocs)

	var cmipLevel_allocs *cgoAllocMap
	reffeaa0d8a.mipLevel, cmipLevel_allocs = (C.uint32_t)(x.MipLevel), cgoAllocsUnknown
	allocsfeaa0d8a.Borrow(cmipLevel_allocs)

	var carrayLayer_allocs *cgoAllocMap
	reffeaa0d8a.arrayLayer, carrayLayer_allocs = (C.uint32_t)(x.ArrayLayer), cgoAllocsUnknown
	allocsfeaa0d8a.Borrow(carrayLayer_allocs)

	x.reffeaa0d8a = reffeaa0d8a
	x.allocsfeaa0d8a = allocsfeaa0d8a
	return reffeaa0d8a, allocsfeaa0d8a

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ImageSubresource) PassValue() (C.VkImageSubresource, *cgoAllocMap) {
	if x == nil {
		x = NewImageSubresourceRef(nil)
	} else if x.reffeaa0d8a != nil {
		return *x.reffeaa0d8a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageSubresource) Deref() {
	if x.reffeaa0d8a == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.reffeaa0d8a.aspectMask)
	x.MipLevel = (uint32)(x.reffeaa0d8a.mipLevel)
	x.ArrayLayer = (uint32)(x.reffeaa0d8a.arrayLayer)
}

// allocOffset3DMemory allocates memory for type C.VkOffset3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOffset3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOffset3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOffset3DValue = unsafe.Sizeof([1]C.VkOffset3D{})

// Ref returns a reference.
func (x *Offset3D) Ref() *C.VkOffset3D {
	if x == nil {
		return nil
	}
	return x.ref2b6879c2
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Offset3D) Free() {
	if x != nil && x.allocs2b6879c2 != nil {
		x.allocs2b6879c2.(*cgoAllocMap).Free()
		x.ref2b6879c2 = nil
	}
}

// NewOffset3DRef initialises a new struct holding the reference to the originaitng C struct.
func NewOffset3DRef(ref *C.VkOffset3D) *Offset3D {
	if ref == nil {
		return nil
	}
	obj := new(Offset3D)
	obj.ref2b6879c2 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Offset3D) PassRef() (*C.VkOffset3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2b6879c2 != nil {
		return x.ref2b6879c2, nil
	}
	mem2b6879c2 := allocOffset3DMemory(1)
	ref2b6879c2 := (*C.VkOffset3D)(mem2b6879c2)
	allocs2b6879c2 := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	ref2b6879c2.x, cx_allocs = (C.int32_t)(x.X), cgoAllocsUnknown
	allocs2b6879c2.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref2b6879c2.y, cy_allocs = (C.int32_t)(x.Y), cgoAllocsUnknown
	allocs2b6879c2.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	ref2b6879c2.z, cz_allocs = (C.int32_t)(x.Z), cgoAllocsUnknown
	allocs2b6879c2.Borrow(cz_allocs)

	x.ref2b6879c2 = ref2b6879c2
	x.allocs2b6879c2 = allocs2b6879c2
	return ref2b6879c2, allocs2b6879c2

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Offset3D) PassValue() (C.VkOffset3D, *cgoAllocMap) {
	if x == nil {
		x = NewOffset3DRef(nil)
	} else if x.ref2b6879c2 != nil {
		return *x.ref2b6879c2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Offset3D) Deref() {
	if x.ref2b6879c2 == nil {
		return
	}
	x.X = (int32)(x.ref2b6879c2.x)
	x.Y = (int32)(x.ref2b6879c2.y)
	x.Z = (int32)(x.ref2b6879c2.z)
}

// allocSparseImageMemoryBindMemory allocates memory for type C.VkSparseImageMemoryBind in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryBindMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryBindValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageMemoryBindValue = unsafe.Sizeof([1]C.VkSparseImageMemoryBind{})

// Ref returns a reference.
func (x *SparseImageMemoryBind) Ref() *C.VkSparseImageMemoryBind {
	if x == nil {
		return nil
	}
	return x.ref41b516d7
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SparseImageMemoryBind) Free() {
	if x != nil && x.allocs41b516d7 != nil {
		x.allocs41b516d7.(*cgoAllocMap).Free()
		x.ref41b516d7 = nil
	}
}

// NewSparseImageMemoryBindRef initialises a new struct holding the reference to the originaitng C struct.
func NewSparseImageMemoryBindRef(ref *C.VkSparseImageMemoryBind) *SparseImageMemoryBind {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryBind)
	obj.ref41b516d7 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SparseImageMemoryBind) PassRef() (*C.VkSparseImageMemoryBind, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref41b516d7 != nil {
		return x.ref41b516d7, nil
	}
	mem41b516d7 := allocSparseImageMemoryBindMemory(1)
	ref41b516d7 := (*C.VkSparseImageMemoryBind)(mem41b516d7)
	allocs41b516d7 := new(cgoAllocMap)
	var csubresource_allocs *cgoAllocMap
	ref41b516d7.subresource, csubresource_allocs = x.Subresource.PassValue()
	allocs41b516d7.Borrow(csubresource_allocs)

	var coffset_allocs *cgoAllocMap
	ref41b516d7.offset, coffset_allocs = x.Offset.PassValue()
	allocs41b516d7.Borrow(coffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref41b516d7.extent, cextent_allocs = x.Extent.PassValue()
	allocs41b516d7.Borrow(cextent_allocs)

	var cmemory_allocs *cgoAllocMap
	ref41b516d7.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs41b516d7.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	ref41b516d7.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocs41b516d7.Borrow(cmemoryOffset_allocs)

	var cflags_allocs *cgoAllocMap
	ref41b516d7.flags, cflags_allocs = (C.VkSparseMemoryBindFlags)(x.Flags), cgoAllocsUnknown
	allocs41b516d7.Borrow(cflags_allocs)

	x.ref41b516d7 = ref41b516d7
	x.allocs41b516d7 = allocs41b516d7
	return ref41b516d7, allocs41b516d7

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SparseImageMemoryBind) PassValue() (C.VkSparseImageMemoryBind, *cgoAllocMap) {
	if x == nil {
		x = NewSparseImageMemoryBindRef(nil)
	} else if x.ref41b516d7 != nil {
		return *x.ref41b516d7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SparseImageMemoryBind) Deref() {
	if x.ref41b516d7 == nil {
		return
	}
	x.Subresource = *NewImageSubresourceRef(&x.ref41b516d7.subresource)
	x.Offset = *NewOffset3DRef(&x.ref41b516d7.offset)
	x.Extent = *NewExtent3DRef(&x.ref41b516d7.extent)
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref41b516d7.memory))
	x.MemoryOffset = (DeviceSize)(x.ref41b516d7.memoryOffset)
	x.Flags = (SparseMemoryBindFlags)(x.ref41b516d7.flags)
}

// allocSparseImageMemoryBindInfoMemory allocates memory for type C.VkSparseImageMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryBindInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseImageMemoryBindInfo{})

// unpackSSparseImageMemoryBind transforms a sliced Go data structure into plain C format.
func unpackSSparseImageMemoryBind(x []SparseImageMemoryBind) (unpacked *C.VkSparseImageMemoryBind, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageMemoryBind) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryBindMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryBind)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryBind)(unsafe.Pointer(h.Data))
	return
}

// packSSparseImageMemoryBind reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryBind(v []SparseImageMemoryBind, ptr0 *C.VkSparseImageMemoryBind) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryBindValue]C.VkSparseImageMemoryBind)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryBindRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *SparseImageMemoryBindInfo) Ref() *C.VkSparseImageMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.ref50faeb70
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SparseImageMemoryBindInfo) Free() {
	if x != nil && x.allocs50faeb70 != nil {
		x.allocs50faeb70.(*cgoAllocMap).Free()
		x.ref50faeb70 = nil
	}
}

// NewSparseImageMemoryBindInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewSparseImageMemoryBindInfoRef(ref *C.VkSparseImageMemoryBindInfo) *SparseImageMemoryBindInfo {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryBindInfo)
	obj.ref50faeb70 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SparseImageMemoryBindInfo) PassRef() (*C.VkSparseImageMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50faeb70 != nil {
		return x.ref50faeb70, nil
	}
	mem50faeb70 := allocSparseImageMemoryBindInfoMemory(1)
	ref50faeb70 := (*C.VkSparseImageMemoryBindInfo)(mem50faeb70)
	allocs50faeb70 := new(cgoAllocMap)
	var cimage_allocs *cgoAllocMap
	ref50faeb70.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs50faeb70.Borrow(cimage_allocs)

	var cbindCount_allocs *cgoAllocMap
	ref50faeb70.bindCount, cbindCount_allocs = (C.uint32_t)(x.BindCount), cgoAllocsUnknown
	allocs50faeb70.Borrow(cbindCount_allocs)

	var cpBinds_allocs *cgoAllocMap
	ref50faeb70.pBinds, cpBinds_allocs = unpackSSparseImageMemoryBind(x.PBinds)
	allocs50faeb70.Borrow(cpBinds_allocs)

	x.ref50faeb70 = ref50faeb70
	x.allocs50faeb70 = allocs50faeb70
	return ref50faeb70, allocs50faeb70

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SparseImageMemoryBindInfo) PassValue() (C.VkSparseImageMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		x = NewSparseImageMemoryBindInfoRef(nil)
	} else if x.ref50faeb70 != nil {
		return *x.ref50faeb70, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SparseImageMemoryBindInfo) Deref() {
	if x.ref50faeb70 == nil {
		return
	}
	x.Image = *(*Image)(unsafe.Pointer(&x.ref50faeb70.image))
	x.BindCount = (uint32)(x.ref50faeb70.bindCount)
	packSSparseImageMemoryBind(x.PBinds, x.ref50faeb70.pBinds)
}

// allocBindSparseInfoMemory allocates memory for type C.VkBindSparseInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindSparseInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindSparseInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindSparseInfoValue = unsafe.Sizeof([1]C.VkBindSparseInfo{})

// unpackSSparseBufferMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseBufferMemoryBindInfo(x []SparseBufferMemoryBindInfo) (unpacked *C.VkSparseBufferMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseBufferMemoryBindInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseBufferMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSSparseImageOpaqueMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseImageOpaqueMemoryBindInfo(x []SparseImageOpaqueMemoryBindInfo) (unpacked *C.VkSparseImageOpaqueMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageOpaqueMemoryBindInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageOpaqueMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSSparseImageMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseImageMemoryBindInfo(x []SparseImageMemoryBindInfo) (unpacked *C.VkSparseImageMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageMemoryBindInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(h.Data))
	return
}

// packSSparseBufferMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseBufferMemoryBindInfo(v []SparseBufferMemoryBindInfo, ptr0 *C.VkSparseBufferMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseBufferMemoryBindInfoValue]C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseBufferMemoryBindInfoRef(&ptr1)
	}
}

// packSSparseImageOpaqueMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseImageOpaqueMemoryBindInfo(v []SparseImageOpaqueMemoryBindInfo, ptr0 *C.VkSparseImageOpaqueMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageOpaqueMemoryBindInfoValue]C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageOpaqueMemoryBindInfoRef(&ptr1)
	}
}

// packSSparseImageMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryBindInfo(v []SparseImageMemoryBindInfo, ptr0 *C.VkSparseImageMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryBindInfoValue]C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryBindInfoRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *BindSparseInfo) Ref() *C.VkBindSparseInfo {
	if x == nil {
		return nil
	}
	return x.refb0cbe910
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *BindSparseInfo) Free() {
	if x != nil && x.allocsb0cbe910 != nil {
		x.allocsb0cbe910.(*cgoAllocMap).Free()
		x.refb0cbe910 = nil
	}
}

// NewBindSparseInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewBindSparseInfoRef(ref *C.VkBindSparseInfo) *BindSparseInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindSparseInfo)
	obj.refb0cbe910 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *BindSparseInfo) PassRef() (*C.VkBindSparseInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0cbe910 != nil {
		return x.refb0cbe910, nil
	}
	memb0cbe910 := allocBindSparseInfoMemory(1)
	refb0cbe910 := (*C.VkBindSparseInfo)(memb0cbe910)
	allocsb0cbe910 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refb0cbe910.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb0cbe910.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb0cbe910.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	refb0cbe910.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphores_allocs *cgoAllocMap
	refb0cbe910.pWaitSemaphores, cpWaitSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)).Data)), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cpWaitSemaphores_allocs)

	var cbufferBindCount_allocs *cgoAllocMap
	refb0cbe910.bufferBindCount, cbufferBindCount_allocs = (C.uint32_t)(x.BufferBindCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cbufferBindCount_allocs)

	var cpBufferBinds_allocs *cgoAllocMap
	refb0cbe910.pBufferBinds, cpBufferBinds_allocs = unpackSSparseBufferMemoryBindInfo(x.PBufferBinds)
	allocsb0cbe910.Borrow(cpBufferBinds_allocs)

	var cimageOpaqueBindCount_allocs *cgoAllocMap
	refb0cbe910.imageOpaqueBindCount, cimageOpaqueBindCount_allocs = (C.uint32_t)(x.ImageOpaqueBindCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cimageOpaqueBindCount_allocs)

	var cpImageOpaqueBinds_allocs *cgoAllocMap
	refb0cbe910.pImageOpaqueBinds, cpImageOpaqueBinds_allocs = unpackSSparseImageOpaqueMemoryBindInfo(x.PImageOpaqueBinds)
	allocsb0cbe910.Borrow(cpImageOpaqueBinds_allocs)

	var cimageBindCount_allocs *cgoAllocMap
	refb0cbe910.imageBindCount, cimageBindCount_allocs = (C.uint32_t)(x.ImageBindCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cimageBindCount_allocs)

	var cpImageBinds_allocs *cgoAllocMap
	refb0cbe910.pImageBinds, cpImageBinds_allocs = unpackSSparseImageMemoryBindInfo(x.PImageBinds)
	allocsb0cbe910.Borrow(cpImageBinds_allocs)

	var csignalSemaphoreCount_allocs *cgoAllocMap
	refb0cbe910.signalSemaphoreCount, csignalSemaphoreCount_allocs = (C.uint32_t)(x.SignalSemaphoreCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(csignalSemaphoreCount_allocs)

	var cpSignalSemaphores_allocs *cgoAllocMap
	refb0cbe910.pSignalSemaphores, cpSignalSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores)).Data)), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cpSignalSemaphores_allocs)

	x.refb0cbe910 = refb0cbe910
	x.allocsb0cbe910 = allocsb0cbe910
	return refb0cbe910, allocsb0cbe910

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *BindSparseInfo) PassValue() (C.VkBindSparseInfo, *cgoAllocMap) {
	if x == nil {
		x = NewBindSparseInfoRef(nil)
	} else if x.refb0cbe910 != nil {
		return *x.refb0cbe910, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *BindSparseInfo) Deref() {
	if x.refb0cbe910 == nil {
		return
	}
	x.SType = (StructureType)(x.refb0cbe910.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb0cbe910.pNext))
	x.WaitSemaphoreCount = (uint32)(x.refb0cbe910.waitSemaphoreCount)
	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxfa3f05c.Data = uintptr(unsafe.Pointer(x.refb0cbe910.pWaitSemaphores))
	hxfa3f05c.Cap = 0x7fffffff
	// hxfa3f05c.Len = ?

	x.BufferBindCount = (uint32)(x.refb0cbe910.bufferBindCount)
	packSSparseBufferMemoryBindInfo(x.PBufferBinds, x.refb0cbe910.pBufferBinds)
	x.ImageOpaqueBindCount = (uint32)(x.refb0cbe910.imageOpaqueBindCount)
	packSSparseImageOpaqueMemoryBindInfo(x.PImageOpaqueBinds, x.refb0cbe910.pImageOpaqueBinds)
	x.ImageBindCount = (uint32)(x.refb0cbe910.imageBindCount)
	packSSparseImageMemoryBindInfo(x.PImageBinds, x.refb0cbe910.pImageBinds)
	x.SignalSemaphoreCount = (uint32)(x.refb0cbe910.signalSemaphoreCount)
	hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores))
	hxf0d18b7.Data = uintptr(unsafe.Pointer(x.refb0cbe910.pSignalSemaphores))
	hxf0d18b7.Cap = 0x7fffffff
	// hxf0d18b7.Len = ?

}

// allocFenceCreateInfoMemory allocates memory for type C.VkFenceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFenceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFenceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFenceCreateInfoValue = unsafe.Sizeof([1]C.VkFenceCreateInfo{})

// Ref returns a reference.
func (x *FenceCreateInfo) Ref() *C.VkFenceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb8ff4840
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *FenceCreateInfo) Free() {
	if x != nil && x.allocsb8ff4840 != nil {
		x.allocsb8ff4840.(*cgoAllocMap).Free()
		x.refb8ff4840 = nil
	}
}

// NewFenceCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewFenceCreateInfoRef(ref *C.VkFenceCreateInfo) *FenceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(FenceCreateInfo)
	obj.refb8ff4840 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *FenceCreateInfo) PassRef() (*C.VkFenceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8ff4840 != nil {
		return x.refb8ff4840, nil
	}
	memb8ff4840 := allocFenceCreateInfoMemory(1)
	refb8ff4840 := (*C.VkFenceCreateInfo)(memb8ff4840)
	allocsb8ff4840 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refb8ff4840.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb8ff4840.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb8ff4840.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb8ff4840.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refb8ff4840.flags, cflags_allocs = (C.VkFenceCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsb8ff4840.Borrow(cflags_allocs)

	x.refb8ff4840 = refb8ff4840
	x.allocsb8ff4840 = allocsb8ff4840
	return refb8ff4840, allocsb8ff4840

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *FenceCreateInfo) PassValue() (C.VkFenceCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewFenceCreateInfoRef(nil)
	} else if x.refb8ff4840 != nil {
		return *x.refb8ff4840, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *FenceCreateInfo) Deref() {
	if x.refb8ff4840 == nil {
		return
	}
	x.SType = (StructureType)(x.refb8ff4840.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb8ff4840.pNext))
	x.Flags = (FenceCreateFlags)(x.refb8ff4840.flags)
}

// allocSemaphoreCreateInfoMemory allocates memory for type C.VkSemaphoreCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSemaphoreCreateInfoValue = unsafe.Sizeof([1]C.VkSemaphoreCreateInfo{})

// Ref returns a reference.
func (x *SemaphoreCreateInfo) Ref() *C.VkSemaphoreCreateInfo {
	if x == nil {
		return nil
	}
	return x.reff130cd2b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SemaphoreCreateInfo) Free() {
	if x != nil && x.allocsf130cd2b != nil {
		x.allocsf130cd2b.(*cgoAllocMap).Free()
		x.reff130cd2b = nil
	}
}

// NewSemaphoreCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewSemaphoreCreateInfoRef(ref *C.VkSemaphoreCreateInfo) *SemaphoreCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SemaphoreCreateInfo)
	obj.reff130cd2b = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SemaphoreCreateInfo) PassRef() (*C.VkSemaphoreCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff130cd2b != nil {
		return x.reff130cd2b, nil
	}
	memf130cd2b := allocSemaphoreCreateInfoMemory(1)
	reff130cd2b := (*C.VkSemaphoreCreateInfo)(memf130cd2b)
	allocsf130cd2b := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	reff130cd2b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf130cd2b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff130cd2b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf130cd2b.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reff130cd2b.flags, cflags_allocs = (C.VkSemaphoreCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsf130cd2b.Borrow(cflags_allocs)

	x.reff130cd2b = reff130cd2b
	x.allocsf130cd2b = allocsf130cd2b
	return reff130cd2b, allocsf130cd2b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SemaphoreCreateInfo) PassValue() (C.VkSemaphoreCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewSemaphoreCreateInfoRef(nil)
	} else if x.reff130cd2b != nil {
		return *x.reff130cd2b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SemaphoreCreateInfo) Deref() {
	if x.reff130cd2b == nil {
		return
	}
	x.SType = (StructureType)(x.reff130cd2b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff130cd2b.pNext))
	x.Flags = (SemaphoreCreateFlags)(x.reff130cd2b.flags)
}

// allocEventCreateInfoMemory allocates memory for type C.VkEventCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventCreateInfoValue = unsafe.Sizeof([1]C.VkEventCreateInfo{})

// Ref returns a reference.
func (x *EventCreateInfo) Ref() *C.VkEventCreateInfo {
	if x == nil {
		return nil
	}
	return x.refa54f9ec8
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *EventCreateInfo) Free() {
	if x != nil && x.allocsa54f9ec8 != nil {
		x.allocsa54f9ec8.(*cgoAllocMap).Free()
		x.refa54f9ec8 = nil
	}
}

// NewEventCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewEventCreateInfoRef(ref *C.VkEventCreateInfo) *EventCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(EventCreateInfo)
	obj.refa54f9ec8 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *EventCreateInfo) PassRef() (*C.VkEventCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa54f9ec8 != nil {
		return x.refa54f9ec8, nil
	}
	mema54f9ec8 := allocEventCreateInfoMemory(1)
	refa54f9ec8 := (*C.VkEventCreateInfo)(mema54f9ec8)
	allocsa54f9ec8 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refa54f9ec8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa54f9ec8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa54f9ec8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa54f9ec8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refa54f9ec8.flags, cflags_allocs = (C.VkEventCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsa54f9ec8.Borrow(cflags_allocs)

	x.refa54f9ec8 = refa54f9ec8
	x.allocsa54f9ec8 = allocsa54f9ec8
	return refa54f9ec8, allocsa54f9ec8

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *EventCreateInfo) PassValue() (C.VkEventCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewEventCreateInfoRef(nil)
	} else if x.refa54f9ec8 != nil {
		return *x.refa54f9ec8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *EventCreateInfo) Deref() {
	if x.refa54f9ec8 == nil {
		return
	}
	x.SType = (StructureType)(x.refa54f9ec8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa54f9ec8.pNext))
	x.Flags = (EventCreateFlags)(x.refa54f9ec8.flags)
}

// allocQueryPoolCreateInfoMemory allocates memory for type C.VkQueryPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueryPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueryPoolCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfQueryPoolCreateInfoValue = unsafe.Sizeof([1]C.VkQueryPoolCreateInfo{})

// Ref returns a reference.
func (x *QueryPoolCreateInfo) Ref() *C.VkQueryPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref85dfcd4a
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *QueryPoolCreateInfo) Free() {
	if x != nil && x.allocs85dfcd4a != nil {
		x.allocs85dfcd4a.(*cgoAllocMap).Free()
		x.ref85dfcd4a = nil
	}
}

// NewQueryPoolCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewQueryPoolCreateInfoRef(ref *C.VkQueryPoolCreateInfo) *QueryPoolCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(QueryPoolCreateInfo)
	obj.ref85dfcd4a = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *QueryPoolCreateInfo) PassRef() (*C.VkQueryPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85dfcd4a != nil {
		return x.ref85dfcd4a, nil
	}
	mem85dfcd4a := allocQueryPoolCreateInfoMemory(1)
	ref85dfcd4a := (*C.VkQueryPoolCreateInfo)(mem85dfcd4a)
	allocs85dfcd4a := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref85dfcd4a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref85dfcd4a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref85dfcd4a.flags, cflags_allocs = (C.VkQueryPoolCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cflags_allocs)

	var cqueryType_allocs *cgoAllocMap
	ref85dfcd4a.queryType, cqueryType_allocs = (C.VkQueryType)(x.QueryType), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cqueryType_allocs)

	var cqueryCount_allocs *cgoAllocMap
	ref85dfcd4a.queryCount, cqueryCount_allocs = (C.uint32_t)(x.QueryCount), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cqueryCount_allocs)

	var cpipelineStatistics_allocs *cgoAllocMap
	ref85dfcd4a.pipelineStatistics, cpipelineStatistics_allocs = (C.VkQueryPipelineStatisticFlags)(x.PipelineStatistics), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cpipelineStatistics_allocs)

	x.ref85dfcd4a = ref85dfcd4a
	x.allocs85dfcd4a = allocs85dfcd4a
	return ref85dfcd4a, allocs85dfcd4a

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *QueryPoolCreateInfo) PassValue() (C.VkQueryPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewQueryPoolCreateInfoRef(nil)
	} else if x.ref85dfcd4a != nil {
		return *x.ref85dfcd4a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *QueryPoolCreateInfo) Deref() {
	if x.ref85dfcd4a == nil {
		return
	}
	x.SType = (StructureType)(x.ref85dfcd4a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref85dfcd4a.pNext))
	x.Flags = (QueryPoolCreateFlags)(x.ref85dfcd4a.flags)
	x.QueryType = (QueryType)(x.ref85dfcd4a.queryType)
	x.QueryCount = (uint32)(x.ref85dfcd4a.queryCount)
	x.PipelineStatistics = (QueryPipelineStatisticFlags)(x.ref85dfcd4a.pipelineStatistics)
}

// allocBufferCreateInfoMemory allocates memory for type C.VkBufferCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferCreateInfoValue = unsafe.Sizeof([1]C.VkBufferCreateInfo{})

// Ref returns a reference.
func (x *BufferCreateInfo) Ref() *C.VkBufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.reffe19d2cd
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *BufferCreateInfo) Free() {
	if x != nil && x.allocsfe19d2cd != nil {
		x.allocsfe19d2cd.(*cgoAllocMap).Free()
		x.reffe19d2cd = nil
	}
}

// NewBufferCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewBufferCreateInfoRef(ref *C.VkBufferCreateInfo) *BufferCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(BufferCreateInfo)
	obj.reffe19d2cd = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *BufferCreateInfo) PassRef() (*C.VkBufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe19d2cd != nil {
		return x.reffe19d2cd, nil
	}
	memfe19d2cd := allocBufferCreateInfoMemory(1)
	reffe19d2cd := (*C.VkBufferCreateInfo)(memfe19d2cd)
	allocsfe19d2cd := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	reffe19d2cd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe19d2cd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reffe19d2cd.flags, cflags_allocs = (C.VkBufferCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cflags_allocs)

	var csize_allocs *cgoAllocMap
	reffe19d2cd.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(csize_allocs)

	var cusage_allocs *cgoAllocMap
	reffe19d2cd.usage, cusage_allocs = (C.VkBufferUsageFlags)(x.Usage), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cusage_allocs)

	var csharingMode_allocs *cgoAllocMap
	reffe19d2cd.sharingMode, csharingMode_allocs = (C.VkSharingMode)(x.SharingMode), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(csharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	reffe19d2cd.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	reffe19d2cd.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)).Data)), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cpQueueFamilyIndices_allocs)

	x.reffe19d2cd = reffe19d2cd
	x.allocsfe19d2cd = allocsfe19d2cd
	return reffe19d2cd, allocsfe19d2cd

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *BufferCreateInfo) PassValue() (C.VkBufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewBufferCreateInfoRef(nil)
	} else if x.reffe19d2cd != nil {
		return *x.reffe19d2cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *BufferCreateInfo) Deref() {
	if x.reffe19d2cd == nil {
		return
	}
	x.SType = (StructureType)(x.reffe19d2cd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe19d2cd.pNext))
	x.Flags = (BufferCreateFlags)(x.reffe19d2cd.flags)
	x.Size = (DeviceSize)(x.reffe19d2cd.size)
	x.Usage = (BufferUsageFlags)(x.reffe19d2cd.usage)
	x.SharingMode = (SharingMode)(x.reffe19d2cd.sharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.reffe19d2cd.queueFamilyIndexCount)
	hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf2fab0d.Data = uintptr(unsafe.Pointer(x.reffe19d2cd.pQueueFamilyIndices))
	hxf2fab0d.Cap = 0x7fffffff
	// hxf2fab0d.Len = ?

}

// allocBufferViewCreateInfoMemory allocates memory for type C.VkBufferViewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferViewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferViewCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferViewCreateInfoValue = unsafe.Sizeof([1]C.VkBufferViewCreateInfo{})

// Ref returns a reference.
func (x *BufferViewCreateInfo) Ref() *C.VkBufferViewCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref49b97027
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *BufferViewCreateInfo) Free() {
	if x != nil && x.allocs49b97027 != nil {
		x.allocs49b97027.(*cgoAllocMap).Free()
		x.ref49b97027 = nil
	}
}

// NewBufferViewCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewBufferViewCreateInfoRef(ref *C.VkBufferViewCreateInfo) *BufferViewCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(BufferViewCreateInfo)
	obj.ref49b97027 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *BufferViewCreateInfo) PassRef() (*C.VkBufferViewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref49b97027 != nil {
		return x.ref49b97027, nil
	}
	mem49b97027 := allocBufferViewCreateInfoMemory(1)
	ref49b97027 := (*C.VkBufferViewCreateInfo)(mem49b97027)
	allocs49b97027 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref49b97027.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs49b97027.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref49b97027.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs49b97027.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref49b97027.flags, cflags_allocs = (C.VkBufferViewCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs49b97027.Borrow(cflags_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref49b97027.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs49b97027.Borrow(cbuffer_allocs)

	var cformat_allocs *cgoAllocMap
	ref49b97027.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs49b97027.Borrow(cformat_allocs)

	var coffset_allocs *cgoAllocMap
	ref49b97027.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs49b97027.Borrow(coffset_allocs)

	var c_range_allocs *cgoAllocMap
	ref49b97027._range, c_range_allocs = (C.VkDeviceSize)(x._range), cgoAllocsUnknown
	allocs49b97027.Borrow(c_range_allocs)

	x.ref49b97027 = ref49b97027
	x.allocs49b97027 = allocs49b97027
	return ref49b97027, allocs49b97027

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *BufferViewCreateInfo) PassValue() (C.VkBufferViewCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewBufferViewCreateInfoRef(nil)
	} else if x.ref49b97027 != nil {
		return *x.ref49b97027, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *BufferViewCreateInfo) Deref() {
	if x.ref49b97027 == nil {
		return
	}
	x.SType = (StructureType)(x.ref49b97027.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref49b97027.pNext))
	x.Flags = (BufferViewCreateFlags)(x.ref49b97027.flags)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref49b97027.buffer))
	x.Format = (Format)(x.ref49b97027.format)
	x.Offset = (DeviceSize)(x.ref49b97027.offset)
	x._range = (DeviceSize)(x.ref49b97027._range)
}

// allocImageCreateInfoMemory allocates memory for type C.VkImageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageCreateInfoValue = unsafe.Sizeof([1]C.VkImageCreateInfo{})

// Ref returns a reference.
func (x *ImageCreateInfo) Ref() *C.VkImageCreateInfo {
	if x == nil {
		return nil
	}
	return x.reffb587ba1
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageCreateInfo) Free() {
	if x != nil && x.allocsfb587ba1 != nil {
		x.allocsfb587ba1.(*cgoAllocMap).Free()
		x.reffb587ba1 = nil
	}
}

// NewImageCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageCreateInfoRef(ref *C.VkImageCreateInfo) *ImageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageCreateInfo)
	obj.reffb587ba1 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageCreateInfo) PassRef() (*C.VkImageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffb587ba1 != nil {
		return x.reffb587ba1, nil
	}
	memfb587ba1 := allocImageCreateInfoMemory(1)
	reffb587ba1 := (*C.VkImageCreateInfo)(memfb587ba1)
	allocsfb587ba1 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	reffb587ba1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfb587ba1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffb587ba1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reffb587ba1.flags, cflags_allocs = (C.VkImageCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cflags_allocs)

	var cimageType_allocs *cgoAllocMap
	reffb587ba1.imageType, cimageType_allocs = (C.VkImageType)(x.ImageType), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cimageType_allocs)

	var cformat_allocs *cgoAllocMap
	reffb587ba1.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cformat_allocs)

	var cextent_allocs *cgoAllocMap
	reffb587ba1.extent, cextent_allocs = x.Extent.PassValue()
	allocsfb587ba1.Borrow(cextent_allocs)

	var cmipLevels_allocs *cgoAllocMap
	reffb587ba1.mipLevels, cmipLevels_allocs = (C.uint32_t)(x.MipLevels), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cmipLevels_allocs)

	var carrayLayers_allocs *cgoAllocMap
	reffb587ba1.arrayLayers, carrayLayers_allocs = (C.uint32_t)(x.ArrayLayers), cgoAllocsUnknown
	allocsfb587ba1.Borrow(carrayLayers_allocs)

	var csamples_allocs *cgoAllocMap
	reffb587ba1.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocsfb587ba1.Borrow(csamples_allocs)

	var ctiling_allocs *cgoAllocMap
	reffb587ba1.tiling, ctiling_allocs = (C.VkImageTiling)(x.Tiling), cgoAllocsUnknown
	allocsfb587ba1.Borrow(ctiling_allocs)

	var cusage_allocs *cgoAllocMap
	reffb587ba1.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cusage_allocs)

	var csharingMode_allocs *cgoAllocMap
	reffb587ba1.sharingMode, csharingMode_allocs = (C.VkSharingMode)(x.SharingMode), cgoAllocsUnknown
	allocsfb587ba1.Borrow(csharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	reffb587ba1.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	reffb587ba1.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)).Data)), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cpQueueFamilyIndices_allocs)

	var cinitialLayout_allocs *cgoAllocMap
	reffb587ba1.initialLayout, cinitialLayout_allocs = (C.VkImageLayout)(x.InitialLayout), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cinitialLayout_allocs)

	x.reffb587ba1 = reffb587ba1
	x.allocsfb587ba1 = allocsfb587ba1
	return reffb587ba1, allocsfb587ba1

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ImageCreateInfo) PassValue() (C.VkImageCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewImageCreateInfoRef(nil)
	} else if x.reffb587ba1 != nil {
		return *x.reffb587ba1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageCreateInfo) Deref() {
	if x.reffb587ba1 == nil {
		return
	}
	x.SType = (StructureType)(x.reffb587ba1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffb587ba1.pNext))
	x.Flags = (ImageCreateFlags)(x.reffb587ba1.flags)
	x.ImageType = (ImageType)(x.reffb587ba1.imageType)
	x.Format = (Format)(x.reffb587ba1.format)
	x.Extent = *NewExtent3DRef(&x.reffb587ba1.extent)
	x.MipLevels = (uint32)(x.reffb587ba1.mipLevels)
	x.ArrayLayers = (uint32)(x.reffb587ba1.arrayLayers)
	x.Samples = (SampleCountFlagBits)(x.reffb587ba1.samples)
	x.Tiling = (ImageTiling)(x.reffb587ba1.tiling)
	x.Usage = (ImageUsageFlags)(x.reffb587ba1.usage)
	x.SharingMode = (SharingMode)(x.reffb587ba1.sharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.reffb587ba1.queueFamilyIndexCount)
	hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf69fe70.Data = uintptr(unsafe.Pointer(x.reffb587ba1.pQueueFamilyIndices))
	hxf69fe70.Cap = 0x7fffffff
	// hxf69fe70.Len = ?

	x.InitialLayout = (ImageLayout)(x.reffb587ba1.initialLayout)
}

// allocSubresourceLayoutMemory allocates memory for type C.VkSubresourceLayout in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubresourceLayoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubresourceLayoutValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubresourceLayoutValue = unsafe.Sizeof([1]C.VkSubresourceLayout{})

// Ref returns a reference.
func (x *SubresourceLayout) Ref() *C.VkSubresourceLayout {
	if x == nil {
		return nil
	}
	return x.ref182612ad
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SubresourceLayout) Free() {
	if x != nil && x.allocs182612ad != nil {
		x.allocs182612ad.(*cgoAllocMap).Free()
		x.ref182612ad = nil
	}
}

// NewSubresourceLayoutRef initialises a new struct holding the reference to the originaitng C struct.
func NewSubresourceLayoutRef(ref *C.VkSubresourceLayout) *SubresourceLayout {
	if ref == nil {
		return nil
	}
	obj := new(SubresourceLayout)
	obj.ref182612ad = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SubresourceLayout) PassRef() (*C.VkSubresourceLayout, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref182612ad != nil {
		return x.ref182612ad, nil
	}
	mem182612ad := allocSubresourceLayoutMemory(1)
	ref182612ad := (*C.VkSubresourceLayout)(mem182612ad)
	allocs182612ad := new(cgoAllocMap)
	var coffset_allocs *cgoAllocMap
	ref182612ad.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs182612ad.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref182612ad.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs182612ad.Borrow(csize_allocs)

	var crowPitch_allocs *cgoAllocMap
	ref182612ad.rowPitch, crowPitch_allocs = (C.VkDeviceSize)(x.RowPitch), cgoAllocsUnknown
	allocs182612ad.Borrow(crowPitch_allocs)

	var carrayPitch_allocs *cgoAllocMap
	ref182612ad.arrayPitch, carrayPitch_allocs = (C.VkDeviceSize)(x.ArrayPitch), cgoAllocsUnknown
	allocs182612ad.Borrow(carrayPitch_allocs)

	var cdepthPitch_allocs *cgoAllocMap
	ref182612ad.depthPitch, cdepthPitch_allocs = (C.VkDeviceSize)(x.DepthPitch), cgoAllocsUnknown
	allocs182612ad.Borrow(cdepthPitch_allocs)

	x.ref182612ad = ref182612ad
	x.allocs182612ad = allocs182612ad
	return ref182612ad, allocs182612ad

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SubresourceLayout) PassValue() (C.VkSubresourceLayout, *cgoAllocMap) {
	if x == nil {
		x = NewSubresourceLayoutRef(nil)
	} else if x.ref182612ad != nil {
		return *x.ref182612ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SubresourceLayout) Deref() {
	if x.ref182612ad == nil {
		return
	}
	x.Offset = (DeviceSize)(x.ref182612ad.offset)
	x.Size = (DeviceSize)(x.ref182612ad.size)
	x.RowPitch = (DeviceSize)(x.ref182612ad.rowPitch)
	x.ArrayPitch = (DeviceSize)(x.ref182612ad.arrayPitch)
	x.DepthPitch = (DeviceSize)(x.ref182612ad.depthPitch)
}

// allocComponentMappingMemory allocates memory for type C.VkComponentMapping in C.
// The caller is responsible for freeing the this memory via C.free.
func allocComponentMappingMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfComponentMappingValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfComponentMappingValue = unsafe.Sizeof([1]C.VkComponentMapping{})

// Ref returns a reference.
func (x *ComponentMapping) Ref() *C.VkComponentMapping {
	if x == nil {
		return nil
	}
	return x.ref63d3d563
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ComponentMapping) Free() {
	if x != nil && x.allocs63d3d563 != nil {
		x.allocs63d3d563.(*cgoAllocMap).Free()
		x.ref63d3d563 = nil
	}
}

// NewComponentMappingRef initialises a new struct holding the reference to the originaitng C struct.
func NewComponentMappingRef(ref *C.VkComponentMapping) *ComponentMapping {
	if ref == nil {
		return nil
	}
	obj := new(ComponentMapping)
	obj.ref63d3d563 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ComponentMapping) PassRef() (*C.VkComponentMapping, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref63d3d563 != nil {
		return x.ref63d3d563, nil
	}
	mem63d3d563 := allocComponentMappingMemory(1)
	ref63d3d563 := (*C.VkComponentMapping)(mem63d3d563)
	allocs63d3d563 := new(cgoAllocMap)
	var cr_allocs *cgoAllocMap
	ref63d3d563.r, cr_allocs = (C.VkComponentSwizzle)(x.R), cgoAllocsUnknown
	allocs63d3d563.Borrow(cr_allocs)

	var cg_allocs *cgoAllocMap
	ref63d3d563.g, cg_allocs = (C.VkComponentSwizzle)(x.G), cgoAllocsUnknown
	allocs63d3d563.Borrow(cg_allocs)

	var cb_allocs *cgoAllocMap
	ref63d3d563.b, cb_allocs = (C.VkComponentSwizzle)(x.B), cgoAllocsUnknown
	allocs63d3d563.Borrow(cb_allocs)

	var ca_allocs *cgoAllocMap
	ref63d3d563.a, ca_allocs = (C.VkComponentSwizzle)(x.A), cgoAllocsUnknown
	allocs63d3d563.Borrow(ca_allocs)

	x.ref63d3d563 = ref63d3d563
	x.allocs63d3d563 = allocs63d3d563
	return ref63d3d563, allocs63d3d563

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ComponentMapping) PassValue() (C.VkComponentMapping, *cgoAllocMap) {
	if x == nil {
		x = NewComponentMappingRef(nil)
	} else if x.ref63d3d563 != nil {
		return *x.ref63d3d563, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ComponentMapping) Deref() {
	if x.ref63d3d563 == nil {
		return
	}
	x.R = (ComponentSwizzle)(x.ref63d3d563.r)
	x.G = (ComponentSwizzle)(x.ref63d3d563.g)
	x.B = (ComponentSwizzle)(x.ref63d3d563.b)
	x.A = (ComponentSwizzle)(x.ref63d3d563.a)
}

// allocImageSubresourceRangeMemory allocates memory for type C.VkImageSubresourceRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceRangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSubresourceRangeValue = unsafe.Sizeof([1]C.VkImageSubresourceRange{})

// Ref returns a reference.
func (x *ImageSubresourceRange) Ref() *C.VkImageSubresourceRange {
	if x == nil {
		return nil
	}
	return x.ref5aa1126
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageSubresourceRange) Free() {
	if x != nil && x.allocs5aa1126 != nil {
		x.allocs5aa1126.(*cgoAllocMap).Free()
		x.ref5aa1126 = nil
	}
}

// NewImageSubresourceRangeRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageSubresourceRangeRef(ref *C.VkImageSubresourceRange) *ImageSubresourceRange {
	if ref == nil {
		return nil
	}
	obj := new(ImageSubresourceRange)
	obj.ref5aa1126 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageSubresourceRange) PassRef() (*C.VkImageSubresourceRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5aa1126 != nil {
		return x.ref5aa1126, nil
	}
	mem5aa1126 := allocImageSubresourceRangeMemory(1)
	ref5aa1126 := (*C.VkImageSubresourceRange)(mem5aa1126)
	allocs5aa1126 := new(cgoAllocMap)
	var caspectMask_allocs *cgoAllocMap
	ref5aa1126.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs5aa1126.Borrow(caspectMask_allocs)

	var cbaseMipLevel_allocs *cgoAllocMap
	ref5aa1126.baseMipLevel, cbaseMipLevel_allocs = (C.uint32_t)(x.BaseMipLevel), cgoAllocsUnknown
	allocs5aa1126.Borrow(cbaseMipLevel_allocs)

	var clevelCount_allocs *cgoAllocMap
	ref5aa1126.levelCount, clevelCount_allocs = (C.uint32_t)(x.LevelCount), cgoAllocsUnknown
	allocs5aa1126.Borrow(clevelCount_allocs)

	var cbaseArrayLayer_allocs *cgoAllocMap
	ref5aa1126.baseArrayLayer, cbaseArrayLayer_allocs = (C.uint32_t)(x.BaseArrayLayer), cgoAllocsUnknown
	allocs5aa1126.Borrow(cbaseArrayLayer_allocs)

	var clayerCount_allocs *cgoAllocMap
	ref5aa1126.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocs5aa1126.Borrow(clayerCount_allocs)

	x.ref5aa1126 = ref5aa1126
	x.allocs5aa1126 = allocs5aa1126
	return ref5aa1126, allocs5aa1126

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ImageSubresourceRange) PassValue() (C.VkImageSubresourceRange, *cgoAllocMap) {
	if x == nil {
		x = NewImageSubresourceRangeRef(nil)
	} else if x.ref5aa1126 != nil {
		return *x.ref5aa1126, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageSubresourceRange) Deref() {
	if x.ref5aa1126 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.ref5aa1126.aspectMask)
	x.BaseMipLevel = (uint32)(x.ref5aa1126.baseMipLevel)
	x.LevelCount = (uint32)(x.ref5aa1126.levelCount)
	x.BaseArrayLayer = (uint32)(x.ref5aa1126.baseArrayLayer)
	x.LayerCount = (uint32)(x.ref5aa1126.layerCount)
}

// allocImageViewCreateInfoMemory allocates memory for type C.VkImageViewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageViewCreateInfoValue = unsafe.Sizeof([1]C.VkImageViewCreateInfo{})

// Ref returns a reference.
func (x *ImageViewCreateInfo) Ref() *C.VkImageViewCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref77e8d4b8
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageViewCreateInfo) Free() {
	if x != nil && x.allocs77e8d4b8 != nil {
		x.allocs77e8d4b8.(*cgoAllocMap).Free()
		x.ref77e8d4b8 = nil
	}
}

// NewImageViewCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageViewCreateInfoRef(ref *C.VkImageViewCreateInfo) *ImageViewCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageViewCreateInfo)
	obj.ref77e8d4b8 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageViewCreateInfo) PassRef() (*C.VkImageViewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref77e8d4b8 != nil {
		return x.ref77e8d4b8, nil
	}
	mem77e8d4b8 := allocImageViewCreateInfoMemory(1)
	ref77e8d4b8 := (*C.VkImageViewCreateInfo)(mem77e8d4b8)
	allocs77e8d4b8 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref77e8d4b8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref77e8d4b8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref77e8d4b8.flags, cflags_allocs = (C.VkImageViewCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cflags_allocs)

	var cimage_allocs *cgoAllocMap
	ref77e8d4b8.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cimage_allocs)

	var cviewType_allocs *cgoAllocMap
	ref77e8d4b8.viewType, cviewType_allocs = (C.VkImageViewType)(x.ViewType), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cviewType_allocs)

	var cformat_allocs *cgoAllocMap
	ref77e8d4b8.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cformat_allocs)

	var ccomponents_allocs *cgoAllocMap
	ref77e8d4b8.components, ccomponents_allocs = x.Components.PassValue()
	allocs77e8d4b8.Borrow(ccomponents_allocs)

	var csubresourceRange_allocs *cgoAllocMap
	ref77e8d4b8.subresourceRange, csubresourceRange_allocs = x.SubresourceRange.PassValue()
	allocs77e8d4b8.Borrow(csubresourceRange_allocs)

	x.ref77e8d4b8 = ref77e8d4b8
	x.allocs77e8d4b8 = allocs77e8d4b8
	return ref77e8d4b8, allocs77e8d4b8

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ImageViewCreateInfo) PassValue() (C.VkImageViewCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewImageViewCreateInfoRef(nil)
	} else if x.ref77e8d4b8 != nil {
		return *x.ref77e8d4b8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageViewCreateInfo) Deref() {
	if x.ref77e8d4b8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref77e8d4b8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref77e8d4b8.pNext))
	x.Flags = (ImageViewCreateFlags)(x.ref77e8d4b8.flags)
	x.Image = *(*Image)(unsafe.Pointer(&x.ref77e8d4b8.image))
	x.ViewType = (ImageViewType)(x.ref77e8d4b8.viewType)
	x.Format = (Format)(x.ref77e8d4b8.format)
	x.Components = *NewComponentMappingRef(&x.ref77e8d4b8.components)
	x.SubresourceRange = *NewImageSubresourceRangeRef(&x.ref77e8d4b8.subresourceRange)
}

// allocShaderModuleCreateInfoMemory allocates memory for type C.VkShaderModuleCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderModuleCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderModuleCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderModuleCreateInfoValue = unsafe.Sizeof([1]C.VkShaderModuleCreateInfo{})

// Ref returns a reference.
func (x *ShaderModuleCreateInfo) Ref() *C.VkShaderModuleCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc663d23e
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ShaderModuleCreateInfo) Free() {
	if x != nil && x.allocsc663d23e != nil {
		x.allocsc663d23e.(*cgoAllocMap).Free()
		x.refc663d23e = nil
	}
}

// NewShaderModuleCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewShaderModuleCreateInfoRef(ref *C.VkShaderModuleCreateInfo) *ShaderModuleCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ShaderModuleCreateInfo)
	obj.refc663d23e = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ShaderModuleCreateInfo) PassRef() (*C.VkShaderModuleCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc663d23e != nil {
		return x.refc663d23e, nil
	}
	memc663d23e := allocShaderModuleCreateInfoMemory(1)
	refc663d23e := (*C.VkShaderModuleCreateInfo)(memc663d23e)
	allocsc663d23e := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refc663d23e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc663d23e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc663d23e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc663d23e.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc663d23e.flags, cflags_allocs = (C.VkShaderModuleCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsc663d23e.Borrow(cflags_allocs)

	var ccodeSize_allocs *cgoAllocMap
	refc663d23e.codeSize, ccodeSize_allocs = (C.size_t)(x.CodeSize), cgoAllocsUnknown
	allocsc663d23e.Borrow(ccodeSize_allocs)

	var cpCode_allocs *cgoAllocMap
	refc663d23e.pCode, cpCode_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCode)).Data)), cgoAllocsUnknown
	allocsc663d23e.Borrow(cpCode_allocs)

	x.refc663d23e = refc663d23e
	x.allocsc663d23e = allocsc663d23e
	return refc663d23e, allocsc663d23e

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ShaderModuleCreateInfo) PassValue() (C.VkShaderModuleCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewShaderModuleCreateInfoRef(nil)
	} else if x.refc663d23e != nil {
		return *x.refc663d23e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ShaderModuleCreateInfo) Deref() {
	if x.refc663d23e == nil {
		return
	}
	x.SType = (StructureType)(x.refc663d23e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc663d23e.pNext))
	x.Flags = (ShaderModuleCreateFlags)(x.refc663d23e.flags)
	x.CodeSize = (uint)(x.refc663d23e.codeSize)
	hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&x.PCode))
	hxf65bf54.Data = uintptr(unsafe.Pointer(x.refc663d23e.pCode))
	hxf65bf54.Cap = 0x7fffffff
	// hxf65bf54.Len = ?

}

// allocPipelineCacheCreateInfoMemory allocates memory for type C.VkPipelineCacheCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCacheCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCacheCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineCacheCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineCacheCreateInfo{})

// Ref returns a reference.
func (x *PipelineCacheCreateInfo) Ref() *C.VkPipelineCacheCreateInfo {
	if x == nil {
		return nil
	}
	return x.reff11e7dd1
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineCacheCreateInfo) Free() {
	if x != nil && x.allocsf11e7dd1 != nil {
		x.allocsf11e7dd1.(*cgoAllocMap).Free()
		x.reff11e7dd1 = nil
	}
}

// NewPipelineCacheCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineCacheCreateInfoRef(ref *C.VkPipelineCacheCreateInfo) *PipelineCacheCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCacheCreateInfo)
	obj.reff11e7dd1 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineCacheCreateInfo) PassRef() (*C.VkPipelineCacheCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff11e7dd1 != nil {
		return x.reff11e7dd1, nil
	}
	memf11e7dd1 := allocPipelineCacheCreateInfoMemory(1)
	reff11e7dd1 := (*C.VkPipelineCacheCreateInfo)(memf11e7dd1)
	allocsf11e7dd1 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	reff11e7dd1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff11e7dd1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reff11e7dd1.flags, cflags_allocs = (C.VkPipelineCacheCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cflags_allocs)

	var cinitialDataSize_allocs *cgoAllocMap
	reff11e7dd1.initialDataSize, cinitialDataSize_allocs = (C.size_t)(x.InitialDataSize), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cinitialDataSize_allocs)

	var cpInitialData_allocs *cgoAllocMap
	reff11e7dd1.pInitialData, cpInitialData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PInitialData)), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cpInitialData_allocs)

	x.reff11e7dd1 = reff11e7dd1
	x.allocsf11e7dd1 = allocsf11e7dd1
	return reff11e7dd1, allocsf11e7dd1

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PipelineCacheCreateInfo) PassValue() (C.VkPipelineCacheCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewPipelineCacheCreateInfoRef(nil)
	} else if x.reff11e7dd1 != nil {
		return *x.reff11e7dd1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineCacheCreateInfo) Deref() {
	if x.reff11e7dd1 == nil {
		return
	}
	x.SType = (StructureType)(x.reff11e7dd1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff11e7dd1.pNext))
	x.Flags = (PipelineCacheCreateFlags)(x.reff11e7dd1.flags)
	x.InitialDataSize = (uint)(x.reff11e7dd1.initialDataSize)
	x.PInitialData = (unsafe.Pointer)(unsafe.Pointer(x.reff11e7dd1.pInitialData))
}

// allocSpecializationMapEntryMemory allocates memory for type C.VkSpecializationMapEntry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSpecializationMapEntryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSpecializationMapEntryValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSpecializationMapEntryValue = unsafe.Sizeof([1]C.VkSpecializationMapEntry{})

// Ref returns a reference.
func (x *SpecializationMapEntry) Ref() *C.VkSpecializationMapEntry {
	if x == nil {
		return nil
	}
	return x.ref2fd815d1
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SpecializationMapEntry) Free() {
	if x != nil && x.allocs2fd815d1 != nil {
		x.allocs2fd815d1.(*cgoAllocMap).Free()
		x.ref2fd815d1 = nil
	}
}

// NewSpecializationMapEntryRef initialises a new struct holding the reference to the originaitng C struct.
func NewSpecializationMapEntryRef(ref *C.VkSpecializationMapEntry) *SpecializationMapEntry {
	if ref == nil {
		return nil
	}
	obj := new(SpecializationMapEntry)
	obj.ref2fd815d1 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SpecializationMapEntry) PassRef() (*C.VkSpecializationMapEntry, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2fd815d1 != nil {
		return x.ref2fd815d1, nil
	}
	mem2fd815d1 := allocSpecializationMapEntryMemory(1)
	ref2fd815d1 := (*C.VkSpecializationMapEntry)(mem2fd815d1)
	allocs2fd815d1 := new(cgoAllocMap)
	var cconstantID_allocs *cgoAllocMap
	ref2fd815d1.constantID, cconstantID_allocs = (C.uint32_t)(x.ConstantID), cgoAllocsUnknown
	allocs2fd815d1.Borrow(cconstantID_allocs)

	var coffset_allocs *cgoAllocMap
	ref2fd815d1.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocs2fd815d1.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref2fd815d1.size, csize_allocs = (C.size_t)(x.Size), cgoAllocsUnknown
	allocs2fd815d1.Borrow(csize_allocs)

	x.ref2fd815d1 = ref2fd815d1
	x.allocs2fd815d1 = allocs2fd815d1
	return ref2fd815d1, allocs2fd815d1

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SpecializationMapEntry) PassValue() (C.VkSpecializationMapEntry, *cgoAllocMap) {
	if x == nil {
		x = NewSpecializationMapEntryRef(nil)
	} else if x.ref2fd815d1 != nil {
		return *x.ref2fd815d1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SpecializationMapEntry) Deref() {
	if x.ref2fd815d1 == nil {
		return
	}
	x.ConstantID = (uint32)(x.ref2fd815d1.constantID)
	x.Offset = (uint32)(x.ref2fd815d1.offset)
	x.Size = (uint)(x.ref2fd815d1.size)
}

// allocSpecializationInfoMemory allocates memory for type C.VkSpecializationInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSpecializationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSpecializationInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSpecializationInfoValue = unsafe.Sizeof([1]C.VkSpecializationInfo{})

// unpackSSpecializationMapEntry transforms a sliced Go data structure into plain C format.
func unpackSSpecializationMapEntry(x []SpecializationMapEntry) (unpacked *C.VkSpecializationMapEntry, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSpecializationMapEntry) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSpecializationMapEntryMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSpecializationMapEntry)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSpecializationMapEntry)(unsafe.Pointer(h.Data))
	return
}

// packSSpecializationMapEntry reads sliced Go data structure out from plain C format.
func packSSpecializationMapEntry(v []SpecializationMapEntry, ptr0 *C.VkSpecializationMapEntry) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSpecializationMapEntryValue]C.VkSpecializationMapEntry)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSpecializationMapEntryRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *SpecializationInfo) Ref() *C.VkSpecializationInfo {
	if x == nil {
		return nil
	}
	return x.ref6bc395a3
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SpecializationInfo) Free() {
	if x != nil && x.allocs6bc395a3 != nil {
		x.allocs6bc395a3.(*cgoAllocMap).Free()
		x.ref6bc395a3 = nil
	}
}

// NewSpecializationInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewSpecializationInfoRef(ref *C.VkSpecializationInfo) *SpecializationInfo {
	if ref == nil {
		return nil
	}
	obj := new(SpecializationInfo)
	obj.ref6bc395a3 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SpecializationInfo) PassRef() (*C.VkSpecializationInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6bc395a3 != nil {
		return x.ref6bc395a3, nil
	}
	mem6bc395a3 := allocSpecializationInfoMemory(1)
	ref6bc395a3 := (*C.VkSpecializationInfo)(mem6bc395a3)
	allocs6bc395a3 := new(cgoAllocMap)
	var cmapEntryCount_allocs *cgoAllocMap
	ref6bc395a3.mapEntryCount, cmapEntryCount_allocs = (C.uint32_t)(x.MapEntryCount), cgoAllocsUnknown
	allocs6bc395a3.Borrow(cmapEntryCount_allocs)

	var cpMapEntries_allocs *cgoAllocMap
	ref6bc395a3.pMapEntries, cpMapEntries_allocs = unpackSSpecializationMapEntry(x.PMapEntries)
	allocs6bc395a3.Borrow(cpMapEntries_allocs)

	var cdataSize_allocs *cgoAllocMap
	ref6bc395a3.dataSize, cdataSize_allocs = (C.size_t)(x.DataSize), cgoAllocsUnknown
	allocs6bc395a3.Borrow(cdataSize_allocs)

	var cpData_allocs *cgoAllocMap
	ref6bc395a3.pData, cpData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocs6bc395a3.Borrow(cpData_allocs)

	x.ref6bc395a3 = ref6bc395a3
	x.allocs6bc395a3 = allocs6bc395a3
	return ref6bc395a3, allocs6bc395a3

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SpecializationInfo) PassValue() (C.VkSpecializationInfo, *cgoAllocMap) {
	if x == nil {
		x = NewSpecializationInfoRef(nil)
	} else if x.ref6bc395a3 != nil {
		return *x.ref6bc395a3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SpecializationInfo) Deref() {
	if x.ref6bc395a3 == nil {
		return
	}
	x.MapEntryCount = (uint32)(x.ref6bc395a3.mapEntryCount)
	packSSpecializationMapEntry(x.PMapEntries, x.ref6bc395a3.pMapEntries)
	x.DataSize = (uint)(x.ref6bc395a3.dataSize)
	x.PData = (unsafe.Pointer)(unsafe.Pointer(x.ref6bc395a3.pData))
}

// allocPipelineShaderStageCreateInfoMemory allocates memory for type C.VkPipelineShaderStageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineShaderStageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineShaderStageCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineShaderStageCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineShaderStageCreateInfo{})

// unpackSSpecializationInfo transforms a sliced Go data structure into plain C format.
func unpackSSpecializationInfo(x []SpecializationInfo) (unpacked *C.VkSpecializationInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSpecializationInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSpecializationInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSpecializationInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSpecializationInfo)(unsafe.Pointer(h.Data))
	return
}

// packSSpecializationInfo reads sliced Go data structure out from plain C format.
func packSSpecializationInfo(v []SpecializationInfo, ptr0 *C.VkSpecializationInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSpecializationInfoValue]C.VkSpecializationInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSpecializationInfoRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *PipelineShaderStageCreateInfo) Ref() *C.VkPipelineShaderStageCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref50ba8b60
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineShaderStageCreateInfo) Free() {
	if x != nil && x.allocs50ba8b60 != nil {
		x.allocs50ba8b60.(*cgoAllocMap).Free()
		x.ref50ba8b60 = nil
	}
}

// NewPipelineShaderStageCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineShaderStageCreateInfoRef(ref *C.VkPipelineShaderStageCreateInfo) *PipelineShaderStageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineShaderStageCreateInfo)
	obj.ref50ba8b60 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineShaderStageCreateInfo) PassRef() (*C.VkPipelineShaderStageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50ba8b60 != nil {
		return x.ref50ba8b60, nil
	}
	mem50ba8b60 := allocPipelineShaderStageCreateInfoMemory(1)
	ref50ba8b60 := (*C.VkPipelineShaderStageCreateInfo)(mem50ba8b60)
	allocs50ba8b60 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref50ba8b60.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs50ba8b60.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref50ba8b60.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref50ba8b60.flags, cflags_allocs = (C.VkPipelineShaderStageCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cflags_allocs)

	var cstage_allocs *cgoAllocMap
	ref50ba8b60.stage, cstage_allocs = (C.VkShaderStageFlagBits)(x.Stage), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cstage_allocs)

	var cmodule_allocs *cgoAllocMap
	ref50ba8b60.module, cmodule_allocs = *(*C.VkShaderModule)(unsafe.Pointer(&x.Module)), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cmodule_allocs)

	var cpName_allocs *cgoAllocMap
	ref50ba8b60.pName, cpName_allocs = unpackPCharString(x.PName)
	allocs50ba8b60.Borrow(cpName_allocs)

	var cpSpecializationInfo_allocs *cgoAllocMap
	ref50ba8b60.pSpecializationInfo, cpSpecializationInfo_allocs = unpackSSpecializationInfo(x.PSpecializationInfo)
	allocs50ba8b60.Borrow(cpSpecializationInfo_allocs)

	x.ref50ba8b60 = ref50ba8b60
	x.allocs50ba8b60 = allocs50ba8b60
	return ref50ba8b60, allocs50ba8b60

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PipelineShaderStageCreateInfo) PassValue() (C.VkPipelineShaderStageCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewPipelineShaderStageCreateInfoRef(nil)
	} else if x.ref50ba8b60 != nil {
		return *x.ref50ba8b60, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineShaderStageCreateInfo) Deref() {
	if x.ref50ba8b60 == nil {
		return
	}
	x.SType = (StructureType)(x.ref50ba8b60.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref50ba8b60.pNext))
	x.Flags = (PipelineShaderStageCreateFlags)(x.ref50ba8b60.flags)
	x.Stage = (ShaderStageFlagBits)(x.ref50ba8b60.stage)
	x.Module = *(*ShaderModule)(unsafe.Pointer(&x.ref50ba8b60.module))
	x.PName = packPCharString(x.ref50ba8b60.pName)
	packSSpecializationInfo(x.PSpecializationInfo, x.ref50ba8b60.pSpecializationInfo)
}

// allocVertexInputBindingDescriptionMemory allocates memory for type C.VkVertexInputBindingDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputBindingDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputBindingDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVertexInputBindingDescriptionValue = unsafe.Sizeof([1]C.VkVertexInputBindingDescription{})

// Ref returns a reference.
func (x *VertexInputBindingDescription) Ref() *C.VkVertexInputBindingDescription {
	if x == nil {
		return nil
	}
	return x.ref5c9d8c23
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *VertexInputBindingDescription) Free() {
	if x != nil && x.allocs5c9d8c23 != nil {
		x.allocs5c9d8c23.(*cgoAllocMap).Free()
		x.ref5c9d8c23 = nil
	}
}

// NewVertexInputBindingDescriptionRef initialises a new struct holding the reference to the originaitng C struct.
func NewVertexInputBindingDescriptionRef(ref *C.VkVertexInputBindingDescription) *VertexInputBindingDescription {
	if ref == nil {
		return nil
	}
	obj := new(VertexInputBindingDescription)
	obj.ref5c9d8c23 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *VertexInputBindingDescription) PassRef() (*C.VkVertexInputBindingDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5c9d8c23 != nil {
		return x.ref5c9d8c23, nil
	}
	mem5c9d8c23 := allocVertexInputBindingDescriptionMemory(1)
	ref5c9d8c23 := (*C.VkVertexInputBindingDescription)(mem5c9d8c23)
	allocs5c9d8c23 := new(cgoAllocMap)
	var cbinding_allocs *cgoAllocMap
	ref5c9d8c23.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocs5c9d8c23.Borrow(cbinding_allocs)

	var cstride_allocs *cgoAllocMap
	ref5c9d8c23.stride, cstride_allocs = (C.uint32_t)(x.Stride), cgoAllocsUnknown
	allocs5c9d8c23.Borrow(cstride_allocs)

	var cinputRate_allocs *cgoAllocMap
	ref5c9d8c23.inputRate, cinputRate_allocs = (C.VkVertexInputRate)(x.InputRate), cgoAllocsUnknown
	allocs5c9d8c23.Borrow(cinputRate_allocs)

	x.ref5c9d8c23 = ref5c9d8c23
	x.allocs5c9d8c23 = allocs5c9d8c23
	return ref5c9d8c23, allocs5c9d8c23

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *VertexInputBindingDescription) PassValue() (C.VkVertexInputBindingDescription, *cgoAllocMap) {
	if x == nil {
		x = NewVertexInputBindingDescriptionRef(nil)
	} else if x.ref5c9d8c23 != nil {
		return *x.ref5c9d8c23, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *VertexInputBindingDescription) Deref() {
	if x.ref5c9d8c23 == nil {
		return
	}
	x.Binding = (uint32)(x.ref5c9d8c23.binding)
	x.Stride = (uint32)(x.ref5c9d8c23.stride)
	x.InputRate = (VertexInputRate)(x.ref5c9d8c23.inputRate)
}

// allocVertexInputAttributeDescriptionMemory allocates memory for type C.VkVertexInputAttributeDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputAttributeDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputAttributeDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVertexInputAttributeDescriptionValue = unsafe.Sizeof([1]C.VkVertexInputAttributeDescription{})

// Ref returns a reference.
func (x *VertexInputAttributeDescription) Ref() *C.VkVertexInputAttributeDescription {
	if x == nil {
		return nil
	}
	return x.refdc4635ff
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *VertexInputAttributeDescription) Free() {
	if x != nil && x.allocsdc4635ff != nil {
		x.allocsdc4635ff.(*cgoAllocMap).Free()
		x.refdc4635ff = nil
	}
}

// NewVertexInputAttributeDescriptionRef initialises a new struct holding the reference to the originaitng C struct.
func NewVertexInputAttributeDescriptionRef(ref *C.VkVertexInputAttributeDescription) *VertexInputAttributeDescription {
	if ref == nil {
		return nil
	}
	obj := new(VertexInputAttributeDescription)
	obj.refdc4635ff = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *VertexInputAttributeDescription) PassRef() (*C.VkVertexInputAttributeDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdc4635ff != nil {
		return x.refdc4635ff, nil
	}
	memdc4635ff := allocVertexInputAttributeDescriptionMemory(1)
	refdc4635ff := (*C.VkVertexInputAttributeDescription)(memdc4635ff)
	allocsdc4635ff := new(cgoAllocMap)
	var clocation_allocs *cgoAllocMap
	refdc4635ff.location, clocation_allocs = (C.uint32_t)(x.Location), cgoAllocsUnknown
	allocsdc4635ff.Borrow(clocation_allocs)

	var cbinding_allocs *cgoAllocMap
	refdc4635ff.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocsdc4635ff.Borrow(cbinding_allocs)

	var cformat_allocs *cgoAllocMap
	refdc4635ff.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsdc4635ff.Borrow(cformat_allocs)

	var coffset_allocs *cgoAllocMap
	refdc4635ff.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocsdc4635ff.Borrow(coffset_allocs)

	x.refdc4635ff = refdc4635ff
	x.allocsdc4635ff = allocsdc4635ff
	return refdc4635ff, allocsdc4635ff

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *VertexInputAttributeDescription) PassValue() (C.VkVertexInputAttributeDescription, *cgoAllocMap) {
	if x == nil {
		x = NewVertexInputAttributeDescriptionRef(nil)
	} else if x.refdc4635ff != nil {
		return *x.refdc4635ff, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *VertexInputAttributeDescription) Deref() {
	if x.refdc4635ff == nil {
		return
	}
	x.Location = (uint32)(x.refdc4635ff.location)
	x.Binding = (uint32)(x.refdc4635ff.binding)
	x.Format = (Format)(x.refdc4635ff.format)
	x.Offset = (uint32)(x.refdc4635ff.offset)
}

// allocPipelineVertexInputStateCreateInfoMemory allocates memory for type C.VkPipelineVertexInputStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineVertexInputStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineVertexInputStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineVertexInputStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineVertexInputStateCreateInfo{})

// unpackSVertexInputBindingDescription transforms a sliced Go data structure into plain C format.
func unpackSVertexInputBindingDescription(x []VertexInputBindingDescription) (unpacked *C.VkVertexInputBindingDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkVertexInputBindingDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVertexInputBindingDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkVertexInputBindingDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkVertexInputBindingDescription)(unsafe.Pointer(h.Data))
	return
}

// unpackSVertexInputAttributeDescription transforms a sliced Go data structure into plain C format.
func unpackSVertexInputAttributeDescription(x []VertexInputAttributeDescription) (unpacked *C.VkVertexInputAttributeDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkVertexInputAttributeDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVertexInputAttributeDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkVertexInputAttributeDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkVertexInputAttributeDescription)(unsafe.Pointer(h.Data))
	return
}

// packSVertexInputBindingDescription reads sliced Go data structure out from plain C format.
func packSVertexInputBindingDescription(v []VertexInputBindingDescription, ptr0 *C.VkVertexInputBindingDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVertexInputBindingDescriptionValue]C.VkVertexInputBindingDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVertexInputBindingDescriptionRef(&ptr1)
	}
}

// packSVertexInputAttributeDescription reads sliced Go data structure out from plain C format.
func packSVertexInputAttributeDescription(v []VertexInputAttributeDescription, ptr0 *C.VkVertexInputAttributeDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVertexInputAttributeDescriptionValue]C.VkVertexInputAttributeDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVertexInputAttributeDescriptionRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *PipelineVertexInputStateCreateInfo) Ref() *C.VkPipelineVertexInputStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5fe4aa50
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineVertexInputStateCreateInfo) Free() {
	if x != nil && x.allocs5fe4aa50 != nil {
		x.allocs5fe4aa50.(*cgoAllocMap).Free()
		x.ref5fe4aa50 = nil
	}
}

// NewPipelineVertexInputStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineVertexInputStateCreateInfoRef(ref *C.VkPipelineVertexInputStateCreateInfo) *PipelineVertexInputStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineVertexInputStateCreateInfo)
	obj.ref5fe4aa50 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineVertexInputStateCreateInfo) PassRef() (*C.VkPipelineVertexInputStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fe4aa50 != nil {
		return x.ref5fe4aa50, nil
	}
	mem5fe4aa50 := allocPipelineVertexInputStateCreateInfoMemory(1)
	ref5fe4aa50 := (*C.VkPipelineVertexInputStateCreateInfo)(mem5fe4aa50)
	allocs5fe4aa50 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref5fe4aa50.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5fe4aa50.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5fe4aa50.flags, cflags_allocs = (C.VkPipelineVertexInputStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cflags_allocs)

	var cvertexBindingDescriptionCount_allocs *cgoAllocMap
	ref5fe4aa50.vertexBindingDescriptionCount, cvertexBindingDescriptionCount_allocs = (C.uint32_t)(x.VertexBindingDescriptionCount), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cvertexBindingDescriptionCount_allocs)

	var cpVertexBindingDescriptions_allocs *cgoAllocMap
	ref5fe4aa50.pVertexBindingDescriptions, cpVertexBindingDescriptions_allocs = unpackSVertexInputBindingDescription(x.PVertexBindingDescriptions)
	allocs5fe4aa50.Borrow(cpVertexBindingDescriptions_allocs)

	var cvertexAttributeDescriptionCount_allocs *cgoAllocMap
	ref5fe4aa50.vertexAttributeDescriptionCount, cvertexAttributeDescriptionCount_allocs = (C.uint32_t)(x.VertexAttributeDescriptionCount), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cvertexAttributeDescriptionCount_allocs)

	var cpVertexAttributeDescriptions_allocs *cgoAllocMap
	ref5fe4aa50.pVertexAttributeDescriptions, cpVertexAttributeDescriptions_allocs = unpackSVertexInputAttributeDescription(x.PVertexAttributeDescriptions)
	allocs5fe4aa50.Borrow(cpVertexAttributeDescriptions_allocs)

	x.ref5fe4aa50 = ref5fe4aa50
	x.allocs5fe4aa50 = allocs5fe4aa50
	return ref5fe4aa50, allocs5fe4aa50

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PipelineVertexInputStateCreateInfo) PassValue() (C.VkPipelineVertexInputStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewPipelineVertexInputStateCreateInfoRef(nil)
	} else if x.ref5fe4aa50 != nil {
		return *x.ref5fe4aa50, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineVertexInputStateCreateInfo) Deref() {
	if x.ref5fe4aa50 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5fe4aa50.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5fe4aa50.pNext))
	x.Flags = (PipelineVertexInputStateCreateFlags)(x.ref5fe4aa50.flags)
	x.VertexBindingDescriptionCount = (uint32)(x.ref5fe4aa50.vertexBindingDescriptionCount)
	packSVertexInputBindingDescription(x.PVertexBindingDescriptions, x.ref5fe4aa50.pVertexBindingDescriptions)
	x.VertexAttributeDescriptionCount = (uint32)(x.ref5fe4aa50.vertexAttributeDescriptionCount)
	packSVertexInputAttributeDescription(x.PVertexAttributeDescriptions, x.ref5fe4aa50.pVertexAttributeDescriptions)
}

// allocPipelineInputAssemblyStateCreateInfoMemory allocates memory for type C.VkPipelineInputAssemblyStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineInputAssemblyStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineInputAssemblyStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineInputAssemblyStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineInputAssemblyStateCreateInfo{})

// Ref returns a reference.
func (x *PipelineInputAssemblyStateCreateInfo) Ref() *C.VkPipelineInputAssemblyStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref22e1691d
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineInputAssemblyStateCreateInfo) Free() {
	if x != nil && x.allocs22e1691d != nil {
		x.allocs22e1691d.(*cgoAllocMap).Free()
		x.ref22e1691d = nil
	}
}

// NewPipelineInputAssemblyStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineInputAssemblyStateCreateInfoRef(ref *C.VkPipelineInputAssemblyStateCreateInfo) *PipelineInputAssemblyStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineInputAssemblyStateCreateInfo)
	obj.ref22e1691d = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineInputAssemblyStateCreateInfo) PassRef() (*C.VkPipelineInputAssemblyStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref22e1691d != nil {
		return x.ref22e1691d, nil
	}
	mem22e1691d := allocPipelineInputAssemblyStateCreateInfoMemory(1)
	ref22e1691d := (*C.VkPipelineInputAssemblyStateCreateInfo)(mem22e1691d)
	allocs22e1691d := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref22e1691d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs22e1691d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref22e1691d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs22e1691d.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref22e1691d.flags, cflags_allocs = (C.VkPipelineInputAssemblyStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs22e1691d.Borrow(cflags_allocs)

	var ctopology_allocs *cgoAllocMap
	ref22e1691d.topology, ctopology_allocs = (C.VkPrimitiveTopology)(x.Topology), cgoAllocsUnknown
	allocs22e1691d.Borrow(ctopology_allocs)

	var cprimitiveRestartEnable_allocs *cgoAllocMap
	ref22e1691d.primitiveRestartEnable, cprimitiveRestartEnable_allocs = (C.VkBool32)(x.PrimitiveRestartEnable), cgoAllocsUnknown
	allocs22e1691d.Borrow(cprimitiveRestartEnable_allocs)

	x.ref22e1691d = ref22e1691d
	x.allocs22e1691d = allocs22e1691d
	return ref22e1691d, allocs22e1691d

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PipelineInputAssemblyStateCreateInfo) PassValue() (C.VkPipelineInputAssemblyStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewPipelineInputAssemblyStateCreateInfoRef(nil)
	} else if x.ref22e1691d != nil {
		return *x.ref22e1691d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineInputAssemblyStateCreateInfo) Deref() {
	if x.ref22e1691d == nil {
		return
	}
	x.SType = (StructureType)(x.ref22e1691d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref22e1691d.pNext))
	x.Flags = (PipelineInputAssemblyStateCreateFlags)(x.ref22e1691d.flags)
	x.Topology = (PrimitiveTopology)(x.ref22e1691d.topology)
	x.PrimitiveRestartEnable = (Bool32)(x.ref22e1691d.primitiveRestartEnable)
}

// allocPipelineTessellationStateCreateInfoMemory allocates memory for type C.VkPipelineTessellationStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineTessellationStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineTessellationStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineTessellationStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineTessellationStateCreateInfo{})

// Ref returns a reference.
func (x *PipelineTessellationStateCreateInfo) Ref() *C.VkPipelineTessellationStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref4ef3997a
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineTessellationStateCreateInfo) Free() {
	if x != nil && x.allocs4ef3997a != nil {
		x.allocs4ef3997a.(*cgoAllocMap).Free()
		x.ref4ef3997a = nil
	}
}

// NewPipelineTessellationStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineTessellationStateCreateInfoRef(ref *C.VkPipelineTessellationStateCreateInfo) *PipelineTessellationStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineTessellationStateCreateInfo)
	obj.ref4ef3997a = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineTessellationStateCreateInfo) PassRef() (*C.VkPipelineTessellationStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4ef3997a != nil {
		return x.ref4ef3997a, nil
	}
	mem4ef3997a := allocPipelineTessellationStateCreateInfoMemory(1)
	ref4ef3997a := (*C.VkPipelineTessellationStateCreateInfo)(mem4ef3997a)
	allocs4ef3997a := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref4ef3997a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4ef3997a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4ef3997a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4ef3997a.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref4ef3997a.flags, cflags_allocs = (C.VkPipelineTessellationStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs4ef3997a.Borrow(cflags_allocs)

	var cpatchControlPoints_allocs *cgoAllocMap
	ref4ef3997a.patchControlPoints, cpatchControlPoints_allocs = (C.uint32_t)(x.PatchControlPoints), cgoAllocsUnknown
	allocs4ef3997a.Borrow(cpatchControlPoints_allocs)

	x.ref4ef3997a = ref4ef3997a
	x.allocs4ef3997a = allocs4ef3997a
	return ref4ef3997a, allocs4ef3997a

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PipelineTessellationStateCreateInfo) PassValue() (C.VkPipelineTessellationStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewPipelineTessellationStateCreateInfoRef(nil)
	} else if x.ref4ef3997a != nil {
		return *x.ref4ef3997a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineTessellationStateCreateInfo) Deref() {
	if x.ref4ef3997a == nil {
		return
	}
	x.SType = (StructureType)(x.ref4ef3997a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4ef3997a.pNext))
	x.Flags = (PipelineTessellationStateCreateFlags)(x.ref4ef3997a.flags)
	x.PatchControlPoints = (uint32)(x.ref4ef3997a.patchControlPoints)
}

// allocViewportMemory allocates memory for type C.VkViewport in C.
// The caller is responsible for freeing the this memory via C.free.
func allocViewportMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfViewportValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfViewportValue = unsafe.Sizeof([1]C.VkViewport{})

// Ref returns a reference.
func (x *Viewport) Ref() *C.VkViewport {
	if x == nil {
		return nil
	}
	return x.ref75cf5291
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Viewport) Free() {
	if x != nil && x.allocs75cf5291 != nil {
		x.allocs75cf5291.(*cgoAllocMap).Free()
		x.ref75cf5291 = nil
	}
}

// NewViewportRef initialises a new struct holding the reference to the originaitng C struct.
func NewViewportRef(ref *C.VkViewport) *Viewport {
	if ref == nil {
		return nil
	}
	obj := new(Viewport)
	obj.ref75cf5291 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Viewport) PassRef() (*C.VkViewport, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75cf5291 != nil {
		return x.ref75cf5291, nil
	}
	mem75cf5291 := allocViewportMemory(1)
	ref75cf5291 := (*C.VkViewport)(mem75cf5291)
	allocs75cf5291 := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	ref75cf5291.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs75cf5291.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref75cf5291.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs75cf5291.Borrow(cy_allocs)

	var cwidth_allocs *cgoAllocMap
	ref75cf5291.width, cwidth_allocs = (C.float)(x.Width), cgoAllocsUnknown
	allocs75cf5291.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref75cf5291.height, cheight_allocs = (C.float)(x.Height), cgoAllocsUnknown
	allocs75cf5291.Borrow(cheight_allocs)

	var cminDepth_allocs *cgoAllocMap
	ref75cf5291.minDepth, cminDepth_allocs = (C.float)(x.MinDepth), cgoAllocsUnknown
	allocs75cf5291.Borrow(cminDepth_allocs)

	var cmaxDepth_allocs *cgoAllocMap
	ref75cf5291.maxDepth, cmaxDepth_allocs = (C.float)(x.MaxDepth), cgoAllocsUnknown
	allocs75cf5291.Borrow(cmaxDepth_allocs)

	x.ref75cf5291 = ref75cf5291
	x.allocs75cf5291 = allocs75cf5291
	return ref75cf5291, allocs75cf5291

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Viewport) PassValue() (C.VkViewport, *cgoAllocMap) {
	if x == nil {
		x = NewViewportRef(nil)
	} else if x.ref75cf5291 != nil {
		return *x.ref75cf5291, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Viewport) Deref() {
	if x.ref75cf5291 == nil {
		return
	}
	x.X = (float32)(x.ref75cf5291.x)
	x.Y = (float32)(x.ref75cf5291.y)
	x.Width = (float32)(x.ref75cf5291.width)
	x.Height = (float32)(x.ref75cf5291.height)
	x.MinDepth = (float32)(x.ref75cf5291.minDepth)
	x.MaxDepth = (float32)(x.ref75cf5291.maxDepth)
}

// allocOffset2DMemory allocates memory for type C.VkOffset2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOffset2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOffset2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOffset2DValue = unsafe.Sizeof([1]C.VkOffset2D{})

// Ref returns a reference.
func (x *Offset2D) Ref() *C.VkOffset2D {
	if x == nil {
		return nil
	}
	return x.ref32734883
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Offset2D) Free() {
	if x != nil && x.allocs32734883 != nil {
		x.allocs32734883.(*cgoAllocMap).Free()
		x.ref32734883 = nil
	}
}

// NewOffset2DRef initialises a new struct holding the reference to the originaitng C struct.
func NewOffset2DRef(ref *C.VkOffset2D) *Offset2D {
	if ref == nil {
		return nil
	}
	obj := new(Offset2D)
	obj.ref32734883 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Offset2D) PassRef() (*C.VkOffset2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref32734883 != nil {
		return x.ref32734883, nil
	}
	mem32734883 := allocOffset2DMemory(1)
	ref32734883 := (*C.VkOffset2D)(mem32734883)
	allocs32734883 := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	ref32734883.x, cx_allocs = (C.int32_t)(x.X), cgoAllocsUnknown
	allocs32734883.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref32734883.y, cy_allocs = (C.int32_t)(x.Y), cgoAllocsUnknown
	allocs32734883.Borrow(cy_allocs)

	x.ref32734883 = ref32734883
	x.allocs32734883 = allocs32734883
	return ref32734883, allocs32734883

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Offset2D) PassValue() (C.VkOffset2D, *cgoAllocMap) {
	if x == nil {
		x = NewOffset2DRef(nil)
	} else if x.ref32734883 != nil {
		return *x.ref32734883, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Offset2D) Deref() {
	if x.ref32734883 == nil {
		return
	}
	x.X = (int32)(x.ref32734883.x)
	x.Y = (int32)(x.ref32734883.y)
}

// allocExtent2DMemory allocates memory for type C.VkExtent2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtent2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtent2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExtent2DValue = unsafe.Sizeof([1]C.VkExtent2D{})

// Ref returns a reference.
func (x *Extent2D) Ref() *C.VkExtent2D {
	if x == nil {
		return nil
	}
	return x.refe2edf56b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Extent2D) Free() {
	if x != nil && x.allocse2edf56b != nil {
		x.allocse2edf56b.(*cgoAllocMap).Free()
		x.refe2edf56b = nil
	}
}

// NewExtent2DRef initialises a new struct holding the reference to the originaitng C struct.
func NewExtent2DRef(ref *C.VkExtent2D) *Extent2D {
	if ref == nil {
		return nil
	}
	obj := new(Extent2D)
	obj.refe2edf56b = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Extent2D) PassRef() (*C.VkExtent2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe2edf56b != nil {
		return x.refe2edf56b, nil
	}
	meme2edf56b := allocExtent2DMemory(1)
	refe2edf56b := (*C.VkExtent2D)(meme2edf56b)
	allocse2edf56b := new(cgoAllocMap)
	var cwidth_allocs *cgoAllocMap
	refe2edf56b.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocse2edf56b.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refe2edf56b.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocse2edf56b.Borrow(cheight_allocs)

	x.refe2edf56b = refe2edf56b
	x.allocse2edf56b = allocse2edf56b
	return refe2edf56b, allocse2edf56b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Extent2D) PassValue() (C.VkExtent2D, *cgoAllocMap) {
	if x == nil {
		x = NewExtent2DRef(nil)
	} else if x.refe2edf56b != nil {
		return *x.refe2edf56b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Extent2D) Deref() {
	if x.refe2edf56b == nil {
		return
	}
	x.Width = (uint32)(x.refe2edf56b.width)
	x.Height = (uint32)(x.refe2edf56b.height)
}

// allocRect2DMemory allocates memory for type C.VkRect2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRect2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRect2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRect2DValue = unsafe.Sizeof([1]C.VkRect2D{})

// Ref returns a reference.
func (x *Rect2D) Ref() *C.VkRect2D {
	if x == nil {
		return nil
	}
	return x.ref89e4256f
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Rect2D) Free() {
	if x != nil && x.allocs89e4256f != nil {
		x.allocs89e4256f.(*cgoAllocMap).Free()
		x.ref89e4256f = nil
	}
}

// NewRect2DRef initialises a new struct holding the reference to the originaitng C struct.
func NewRect2DRef(ref *C.VkRect2D) *Rect2D {
	if ref == nil {
		return nil
	}
	obj := new(Rect2D)
	obj.ref89e4256f = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Rect2D) PassRef() (*C.VkRect2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref89e4256f != nil {
		return x.ref89e4256f, nil
	}
	mem89e4256f := allocRect2DMemory(1)
	ref89e4256f := (*C.VkRect2D)(mem89e4256f)
	allocs89e4256f := new(cgoAllocMap)
	var coffset_allocs *cgoAllocMap
	ref89e4256f.offset, coffset_allocs = x.Offset.PassValue()
	allocs89e4256f.Borrow(coffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref89e4256f.extent, cextent_allocs = x.Extent.PassValue()
	allocs89e4256f.Borrow(cextent_allocs)

	x.ref89e4256f = ref89e4256f
	x.allocs89e4256f = allocs89e4256f
	return ref89e4256f, allocs89e4256f

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Rect2D) PassValue() (C.VkRect2D, *cgoAllocMap) {
	if x == nil {
		x = NewRect2DRef(nil)
	} else if x.ref89e4256f != nil {
		return *x.ref89e4256f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Rect2D) Deref() {
	if x.ref89e4256f == nil {
		return
	}
	x.Offset = *NewOffset2DRef(&x.ref89e4256f.offset)
	x.Extent = *NewExtent2DRef(&x.ref89e4256f.extent)
}

// allocPipelineViewportStateCreateInfoMemory allocates memory for type C.VkPipelineViewportStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineViewportStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineViewportStateCreateInfo{})

// unpackSViewport transforms a sliced Go data structure into plain C format.
func unpackSViewport(x []Viewport) (unpacked *C.VkViewport, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkViewport) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocViewportMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewport)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewport)(unsafe.Pointer(h.Data))
	return
}

// unpackSRect2D transforms a sliced Go data structure into plain C format.
func unpackSRect2D(x []Rect2D) (unpacked *C.VkRect2D, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkRect2D) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRect2DMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRect2D)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRect2D)(unsafe.Pointer(h.Data))
	return
}

// packSViewport reads sliced Go data structure out from plain C format.
func packSViewport(v []Viewport, ptr0 *C.VkViewport) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfViewportValue]C.VkViewport)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewViewportRef(&ptr1)
	}
}

// packSRect2D reads sliced Go data structure out from plain C format.
func packSRect2D(v []Rect2D, ptr0 *C.VkRect2D) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRect2DValue]C.VkRect2D)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRect2DRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *PipelineViewportStateCreateInfo) Ref() *C.VkPipelineViewportStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc4705791
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineViewportStateCreateInfo) Free() {
	if x != nil && x.allocsc4705791 != nil {
		x.allocsc4705791.(*cgoAllocMap).Free()
		x.refc4705791 = nil
	}
}

// NewPipelineViewportStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineViewportStateCreateInfoRef(ref *C.VkPipelineViewportStateCreateInfo) *PipelineViewportStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportStateCreateInfo)
	obj.refc4705791 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineViewportStateCreateInfo) PassRef() (*C.VkPipelineViewportStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc4705791 != nil {
		return x.refc4705791, nil
	}
	memc4705791 := allocPipelineViewportStateCreateInfoMemory(1)
	refc4705791 := (*C.VkPipelineViewportStateCreateInfo)(memc4705791)
	allocsc4705791 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refc4705791.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc4705791.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc4705791.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc4705791.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc4705791.flags, cflags_allocs = (C.VkPipelineViewportStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsc4705791.Borrow(cflags_allocs)

	var cviewportCount_allocs *cgoAllocMap
	refc4705791.viewportCount, cviewportCount_allocs = (C.uint32_t)(x.ViewportCount), cgoAllocsUnknown
	allocsc4705791.Borrow(cviewportCount_allocs)

	var cpViewports_allocs *cgoAllocMap
	refc4705791.pViewports, cpViewports_allocs = unpackSViewport(x.PViewports)
	allocsc4705791.Borrow(cpViewports_allocs)

	var cscissorCount_allocs *cgoAllocMap
	refc4705791.scissorCount, cscissorCount_allocs = (C.uint32_t)(x.ScissorCount), cgoAllocsUnknown
	allocsc4705791.Borrow(cscissorCount_allocs)

	var cpScissors_allocs *cgoAllocMap
	refc4705791.pScissors, cpScissors_allocs = unpackSRect2D(x.PScissors)
	allocsc4705791.Borrow(cpScissors_allocs)

	x.refc4705791 = refc4705791
	x.allocsc4705791 = allocsc4705791
	return refc4705791, allocsc4705791

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PipelineViewportStateCreateInfo) PassValue() (C.VkPipelineViewportStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewPipelineViewportStateCreateInfoRef(nil)
	} else if x.refc4705791 != nil {
		return *x.refc4705791, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineViewportStateCreateInfo) Deref() {
	if x.refc4705791 == nil {
		return
	}
	x.SType = (StructureType)(x.refc4705791.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc4705791.pNext))
	x.Flags = (PipelineViewportStateCreateFlags)(x.refc4705791.flags)
	x.ViewportCount = (uint32)(x.refc4705791.viewportCount)
	packSViewport(x.PViewports, x.refc4705791.pViewports)
	x.ScissorCount = (uint32)(x.refc4705791.scissorCount)
	packSRect2D(x.PScissors, x.refc4705791.pScissors)
}

// allocPipelineRasterizationStateCreateInfoMemory allocates memory for type C.VkPipelineRasterizationStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineRasterizationStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineRasterizationStateCreateInfo{})

// Ref returns a reference.
func (x *PipelineRasterizationStateCreateInfo) Ref() *C.VkPipelineRasterizationStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref48cb9fad
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineRasterizationStateCreateInfo) Free() {
	if x != nil && x.allocs48cb9fad != nil {
		x.allocs48cb9fad.(*cgoAllocMap).Free()
		x.ref48cb9fad = nil
	}
}

// NewPipelineRasterizationStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineRasterizationStateCreateInfoRef(ref *C.VkPipelineRasterizationStateCreateInfo) *PipelineRasterizationStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationStateCreateInfo)
	obj.ref48cb9fad = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineRasterizationStateCreateInfo) PassRef() (*C.VkPipelineRasterizationStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref48cb9fad != nil {
		return x.ref48cb9fad, nil
	}
	mem48cb9fad := allocPipelineRasterizationStateCreateInfoMemory(1)
	ref48cb9fad := (*C.VkPipelineRasterizationStateCreateInfo)(mem48cb9fad)
	allocs48cb9fad := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref48cb9fad.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs48cb9fad.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref48cb9fad.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref48cb9fad.flags, cflags_allocs = (C.VkPipelineRasterizationStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cflags_allocs)

	var cdepthClampEnable_allocs *cgoAllocMap
	ref48cb9fad.depthClampEnable, cdepthClampEnable_allocs = (C.VkBool32)(x.DepthClampEnable), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthClampEnable_allocs)

	var crasterizerDiscardEnable_allocs *cgoAllocMap
	ref48cb9fad.rasterizerDiscardEnable, crasterizerDiscardEnable_allocs = (C.VkBool32)(x.RasterizerDiscardEnable), cgoAllocsUnknown
	allocs48cb9fad.Borrow(crasterizerDiscardEnable_allocs)

	var cpolygonMode_allocs *cgoAllocMap
	ref48cb9fad.polygonMode, cpolygonMode_allocs = (C.VkPolygonMode)(x.PolygonMode), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cpolygonMode_allocs)

	var ccullMode_allocs *cgoAllocMap
	ref48cb9fad.cullMode, ccullMode_allocs = (C.VkCullModeFlags)(x.CullMode), cgoAllocsUnknown
	allocs48cb9fad.Borrow(ccullMode_allocs)

	var cfrontFace_allocs *cgoAllocMap
	ref48cb9fad.frontFace, cfrontFace_allocs = (C.VkFrontFace)(x.FrontFace), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cfrontFace_allocs)

	var cdepthBiasEnable_allocs *cgoAllocMap
	ref48cb9fad.depthBiasEnable, cdepthBiasEnable_allocs = (C.VkBool32)(x.DepthBiasEnable), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasEnable_allocs)

	var cdepthBiasConstantFactor_allocs *cgoAllocMap
	ref48cb9fad.depthBiasConstantFactor, cdepthBiasConstantFactor_allocs = (C.float)(x.DepthBiasConstantFactor), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasConstantFactor_allocs)

	var cdepthBiasClamp_allocs *cgoAllocMap
	ref48cb9fad.depthBiasClamp, cdepthBiasClamp_allocs = (C.float)(x.DepthBiasClamp), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasClamp_allocs)

	var cdepthBiasSlopeFactor_allocs *cgoAllocMap
	ref48cb9fad.depthBiasSlopeFactor, cdepthBiasSlopeFactor_allocs = (C.float)(x.DepthBiasSlopeFactor), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasSlopeFactor_allocs)

	var clineWidth_allocs *cgoAllocMap
	ref48cb9fad.lineWidth, clineWidth_allocs = (C.float)(x.LineWidth), cgoAllocsUnknown
	allocs48cb9fad.Borrow(clineWidth_allocs)

	x.ref48cb9fad = ref48cb9fad
	x.allocs48cb9fad = allocs48cb9fad
	return ref48cb9fad, allocs48cb9fad

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PipelineRasterizationStateCreateInfo) PassValue() (C.VkPipelineRasterizationStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewPipelineRasterizationStateCreateInfoRef(nil)
	} else if x.ref48cb9fad != nil {
		return *x.ref48cb9fad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineRasterizationStateCreateInfo) Deref() {
	if x.ref48cb9fad == nil {
		return
	}
	x.SType = (StructureType)(x.ref48cb9fad.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref48cb9fad.pNext))
	x.Flags = (PipelineRasterizationStateCreateFlags)(x.ref48cb9fad.flags)
	x.DepthClampEnable = (Bool32)(x.ref48cb9fad.depthClampEnable)
	x.RasterizerDiscardEnable = (Bool32)(x.ref48cb9fad.rasterizerDiscardEnable)
	x.PolygonMode = (PolygonMode)(x.ref48cb9fad.polygonMode)
	x.CullMode = (CullModeFlags)(x.ref48cb9fad.cullMode)
	x.FrontFace = (FrontFace)(x.ref48cb9fad.frontFace)
	x.DepthBiasEnable = (Bool32)(x.ref48cb9fad.depthBiasEnable)
	x.DepthBiasConstantFactor = (float32)(x.ref48cb9fad.depthBiasConstantFactor)
	x.DepthBiasClamp = (float32)(x.ref48cb9fad.depthBiasClamp)
	x.DepthBiasSlopeFactor = (float32)(x.ref48cb9fad.depthBiasSlopeFactor)
	x.LineWidth = (float32)(x.ref48cb9fad.lineWidth)
}

// allocPipelineMultisampleStateCreateInfoMemory allocates memory for type C.VkPipelineMultisampleStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineMultisampleStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineMultisampleStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineMultisampleStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineMultisampleStateCreateInfo{})

// Ref returns a reference.
func (x *PipelineMultisampleStateCreateInfo) Ref() *C.VkPipelineMultisampleStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb6538bfb
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineMultisampleStateCreateInfo) Free() {
	if x != nil && x.allocsb6538bfb != nil {
		x.allocsb6538bfb.(*cgoAllocMap).Free()
		x.refb6538bfb = nil
	}
}

// NewPipelineMultisampleStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineMultisampleStateCreateInfoRef(ref *C.VkPipelineMultisampleStateCreateInfo) *PipelineMultisampleStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineMultisampleStateCreateInfo)
	obj.refb6538bfb = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineMultisampleStateCreateInfo) PassRef() (*C.VkPipelineMultisampleStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb6538bfb != nil {
		return x.refb6538bfb, nil
	}
	memb6538bfb := allocPipelineMultisampleStateCreateInfoMemory(1)
	refb6538bfb := (*C.VkPipelineMultisampleStateCreateInfo)(memb6538bfb)
	allocsb6538bfb := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refb6538bfb.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb6538bfb.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb6538bfb.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refb6538bfb.flags, cflags_allocs = (C.VkPipelineMultisampleStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cflags_allocs)

	var crasterizationSamples_allocs *cgoAllocMap
	refb6538bfb.rasterizationSamples, crasterizationSamples_allocs = (C.VkSampleCountFlagBits)(x.RasterizationSamples), cgoAllocsUnknown
	allocsb6538bfb.Borrow(crasterizationSamples_allocs)

	var csampleShadingEnable_allocs *cgoAllocMap
	refb6538bfb.sampleShadingEnable, csampleShadingEnable_allocs = (C.VkBool32)(x.SampleShadingEnable), cgoAllocsUnknown
	allocsb6538bfb.Borrow(csampleShadingEnable_allocs)

	var cminSampleShading_allocs *cgoAllocMap
	refb6538bfb.minSampleShading, cminSampleShading_allocs = (C.float)(x.MinSampleShading), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cminSampleShading_allocs)

	var cpSampleMask_allocs *cgoAllocMap
	refb6538bfb.pSampleMask, cpSampleMask_allocs = (*C.VkSampleMask)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSampleMask)).Data)), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cpSampleMask_allocs)

	var calphaToCoverageEnable_allocs *cgoAllocMap
	refb6538bfb.alphaToCoverageEnable, calphaToCoverageEnable_allocs = (C.VkBool32)(x.AlphaToCoverageEnable), cgoAllocsUnknown
	allocsb6538bfb.Borrow(calphaToCoverageEnable_allocs)

	var calphaToOneEnable_allocs *cgoAllocMap
	refb6538bfb.alphaToOneEnable, calphaToOneEnable_allocs = (C.VkBool32)(x.AlphaToOneEnable), cgoAllocsUnknown
	allocsb6538bfb.Borrow(calphaToOneEnable_allocs)

	x.refb6538bfb = refb6538bfb
	x.allocsb6538bfb = allocsb6538bfb
	return refb6538bfb, allocsb6538bfb

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PipelineMultisampleStateCreateInfo) PassValue() (C.VkPipelineMultisampleStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewPipelineMultisampleStateCreateInfoRef(nil)
	} else if x.refb6538bfb != nil {
		return *x.refb6538bfb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineMultisampleStateCreateInfo) Deref() {
	if x.refb6538bfb == nil {
		return
	}
	x.SType = (StructureType)(x.refb6538bfb.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb6538bfb.pNext))
	x.Flags = (PipelineMultisampleStateCreateFlags)(x.refb6538bfb.flags)
	x.RasterizationSamples = (SampleCountFlagBits)(x.refb6538bfb.rasterizationSamples)
	x.SampleShadingEnable = (Bool32)(x.refb6538bfb.sampleShadingEnable)
	x.MinSampleShading = (float32)(x.refb6538bfb.minSampleShading)
	hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&x.PSampleMask))
	hxf3b8dbd.Data = uintptr(unsafe.Pointer(x.refb6538bfb.pSampleMask))
	hxf3b8dbd.Cap = 0x7fffffff
	// hxf3b8dbd.Len = ?

	x.AlphaToCoverageEnable = (Bool32)(x.refb6538bfb.alphaToCoverageEnable)
	x.AlphaToOneEnable = (Bool32)(x.refb6538bfb.alphaToOneEnable)
}

// allocStencilOpStateMemory allocates memory for type C.VkStencilOpState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStencilOpStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStencilOpStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStencilOpStateValue = unsafe.Sizeof([1]C.VkStencilOpState{})

// Ref returns a reference.
func (x *StencilOpState) Ref() *C.VkStencilOpState {
	if x == nil {
		return nil
	}
	return x.ref28886871
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *StencilOpState) Free() {
	if x != nil && x.allocs28886871 != nil {
		x.allocs28886871.(*cgoAllocMap).Free()
		x.ref28886871 = nil
	}
}

// NewStencilOpStateRef initialises a new struct holding the reference to the originaitng C struct.
func NewStencilOpStateRef(ref *C.VkStencilOpState) *StencilOpState {
	if ref == nil {
		return nil
	}
	obj := new(StencilOpState)
	obj.ref28886871 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *StencilOpState) PassRef() (*C.VkStencilOpState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref28886871 != nil {
		return x.ref28886871, nil
	}
	mem28886871 := allocStencilOpStateMemory(1)
	ref28886871 := (*C.VkStencilOpState)(mem28886871)
	allocs28886871 := new(cgoAllocMap)
	var cfailOp_allocs *cgoAllocMap
	ref28886871.failOp, cfailOp_allocs = (C.VkStencilOp)(x.FailOp), cgoAllocsUnknown
	allocs28886871.Borrow(cfailOp_allocs)

	var cpassOp_allocs *cgoAllocMap
	ref28886871.passOp, cpassOp_allocs = (C.VkStencilOp)(x.PassOp), cgoAllocsUnknown
	allocs28886871.Borrow(cpassOp_allocs)

	var cdepthFailOp_allocs *cgoAllocMap
	ref28886871.depthFailOp, cdepthFailOp_allocs = (C.VkStencilOp)(x.DepthFailOp), cgoAllocsUnknown
	allocs28886871.Borrow(cdepthFailOp_allocs)

	var ccompareOp_allocs *cgoAllocMap
	ref28886871.compareOp, ccompareOp_allocs = (C.VkCompareOp)(x.CompareOp), cgoAllocsUnknown
	allocs28886871.Borrow(ccompareOp_allocs)

	var ccompareMask_allocs *cgoAllocMap
	ref28886871.compareMask, ccompareMask_allocs = (C.uint32_t)(x.CompareMask), cgoAllocsUnknown
	allocs28886871.Borrow(ccompareMask_allocs)

	var cwriteMask_allocs *cgoAllocMap
	ref28886871.writeMask, cwriteMask_allocs = (C.uint32_t)(x.WriteMask), cgoAllocsUnknown
	allocs28886871.Borrow(cwriteMask_allocs)

	var creference_allocs *cgoAllocMap
	ref28886871.reference, creference_allocs = (C.uint32_t)(x.Reference), cgoAllocsUnknown
	allocs28886871.Borrow(creference_allocs)

	x.ref28886871 = ref28886871
	x.allocs28886871 = allocs28886871
	return ref28886871, allocs28886871

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *StencilOpState) PassValue() (C.VkStencilOpState, *cgoAllocMap) {
	if x == nil {
		x = NewStencilOpStateRef(nil)
	} else if x.ref28886871 != nil {
		return *x.ref28886871, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *StencilOpState) Deref() {
	if x.ref28886871 == nil {
		return
	}
	x.FailOp = (StencilOp)(x.ref28886871.failOp)
	x.PassOp = (StencilOp)(x.ref28886871.passOp)
	x.DepthFailOp = (StencilOp)(x.ref28886871.depthFailOp)
	x.CompareOp = (CompareOp)(x.ref28886871.compareOp)
	x.CompareMask = (uint32)(x.ref28886871.compareMask)
	x.WriteMask = (uint32)(x.ref28886871.writeMask)
	x.Reference = (uint32)(x.ref28886871.reference)
}

// allocPipelineDepthStencilStateCreateInfoMemory allocates memory for type C.VkPipelineDepthStencilStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineDepthStencilStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineDepthStencilStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineDepthStencilStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineDepthStencilStateCreateInfo{})

// Ref returns a reference.
func (x *PipelineDepthStencilStateCreateInfo) Ref() *C.VkPipelineDepthStencilStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refeabfcf1
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineDepthStencilStateCreateInfo) Free() {
	if x != nil && x.allocseabfcf1 != nil {
		x.allocseabfcf1.(*cgoAllocMap).Free()
		x.refeabfcf1 = nil
	}
}

// NewPipelineDepthStencilStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineDepthStencilStateCreateInfoRef(ref *C.VkPipelineDepthStencilStateCreateInfo) *PipelineDepthStencilStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineDepthStencilStateCreateInfo)
	obj.refeabfcf1 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineDepthStencilStateCreateInfo) PassRef() (*C.VkPipelineDepthStencilStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeabfcf1 != nil {
		return x.refeabfcf1, nil
	}
	memeabfcf1 := allocPipelineDepthStencilStateCreateInfoMemory(1)
	refeabfcf1 := (*C.VkPipelineDepthStencilStateCreateInfo)(memeabfcf1)
	allocseabfcf1 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refeabfcf1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseabfcf1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeabfcf1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseabfcf1.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refeabfcf1.flags, cflags_allocs = (C.VkPipelineDepthStencilStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocseabfcf1.Borrow(cflags_allocs)

	var cdepthTestEnable_allocs *cgoAllocMap
	refeabfcf1.depthTestEnable, cdepthTestEnable_allocs = (C.VkBool32)(x.DepthTestEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthTestEnable_allocs)

	var cdepthWriteEnable_allocs *cgoAllocMap
	refeabfcf1.depthWriteEnable, cdepthWriteEnable_allocs = (C.VkBool32)(x.DepthWriteEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthWriteEnable_allocs)

	var cdepthCompareOp_allocs *cgoAllocMap
	refeabfcf1.depthCompareOp, cdepthCompareOp_allocs = (C.VkCompareOp)(x.DepthCompareOp), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthCompareOp_allocs)

	var cdepthBoundsTestEnable_allocs *cgoAllocMap
	refeabfcf1.depthBoundsTestEnable, cdepthBoundsTestEnable_allocs = (C.VkBool32)(x.DepthBoundsTestEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthBoundsTestEnable_allocs)

	var cstencilTestEnable_allocs *cgoAllocMap
	refeabfcf1.stencilTestEnable, cstencilTestEnable_allocs = (C.VkBool32)(x.StencilTestEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cstencilTestEnable_allocs)

	var cfront_allocs *cgoAllocMap
	refeabfcf1.front, cfront_allocs = x.Front.PassValue()
	allocseabfcf1.Borrow(cfront_allocs)

	var cback_allocs *cgoAllocMap
	refeabfcf1.back, cback_allocs = x.Back.PassValue()
	allocseabfcf1.Borrow(cback_allocs)

	var cminDepthBounds_allocs *cgoAllocMap
	refeabfcf1.minDepthBounds, cminDepthBounds_allocs = (C.float)(x.MinDepthBounds), cgoAllocsUnknown
	allocseabfcf1.Borrow(cminDepthBounds_allocs)

	var cmaxDepthBounds_allocs *cgoAllocMap
	refeabfcf1.maxDepthBounds, cmaxDepthBounds_allocs = (C.float)(x.MaxDepthBounds), cgoAllocsUnknown
	allocseabfcf1.Borrow(cmaxDepthBounds_allocs)

	x.refeabfcf1 = refeabfcf1
	x.allocseabfcf1 = allocseabfcf1
	return refeabfcf1, allocseabfcf1

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PipelineDepthStencilStateCreateInfo) PassValue() (C.VkPipelineDepthStencilStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewPipelineDepthStencilStateCreateInfoRef(nil)
	} else if x.refeabfcf1 != nil {
		return *x.refeabfcf1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineDepthStencilStateCreateInfo) Deref() {
	if x.refeabfcf1 == nil {
		return
	}
	x.SType = (StructureType)(x.refeabfcf1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeabfcf1.pNext))
	x.Flags = (PipelineDepthStencilStateCreateFlags)(x.refeabfcf1.flags)
	x.DepthTestEnable = (Bool32)(x.refeabfcf1.depthTestEnable)
	x.DepthWriteEnable = (Bool32)(x.refeabfcf1.depthWriteEnable)
	x.DepthCompareOp = (CompareOp)(x.refeabfcf1.depthCompareOp)
	x.DepthBoundsTestEnable = (Bool32)(x.refeabfcf1.depthBoundsTestEnable)
	x.StencilTestEnable = (Bool32)(x.refeabfcf1.stencilTestEnable)
	x.Front = *NewStencilOpStateRef(&x.refeabfcf1.front)
	x.Back = *NewStencilOpStateRef(&x.refeabfcf1.back)
	x.MinDepthBounds = (float32)(x.refeabfcf1.minDepthBounds)
	x.MaxDepthBounds = (float32)(x.refeabfcf1.maxDepthBounds)
}

// allocPipelineColorBlendAttachmentStateMemory allocates memory for type C.VkPipelineColorBlendAttachmentState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorBlendAttachmentStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorBlendAttachmentStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineColorBlendAttachmentStateValue = unsafe.Sizeof([1]C.VkPipelineColorBlendAttachmentState{})

// Ref returns a reference.
func (x *PipelineColorBlendAttachmentState) Ref() *C.VkPipelineColorBlendAttachmentState {
	if x == nil {
		return nil
	}
	return x.ref9e889477
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineColorBlendAttachmentState) Free() {
	if x != nil && x.allocs9e889477 != nil {
		x.allocs9e889477.(*cgoAllocMap).Free()
		x.ref9e889477 = nil
	}
}

// NewPipelineColorBlendAttachmentStateRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineColorBlendAttachmentStateRef(ref *C.VkPipelineColorBlendAttachmentState) *PipelineColorBlendAttachmentState {
	if ref == nil {
		return nil
	}
	obj := new(PipelineColorBlendAttachmentState)
	obj.ref9e889477 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineColorBlendAttachmentState) PassRef() (*C.VkPipelineColorBlendAttachmentState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9e889477 != nil {
		return x.ref9e889477, nil
	}
	mem9e889477 := allocPipelineColorBlendAttachmentStateMemory(1)
	ref9e889477 := (*C.VkPipelineColorBlendAttachmentState)(mem9e889477)
	allocs9e889477 := new(cgoAllocMap)
	var cblendEnable_allocs *cgoAllocMap
	ref9e889477.blendEnable, cblendEnable_allocs = (C.VkBool32)(x.BlendEnable), cgoAllocsUnknown
	allocs9e889477.Borrow(cblendEnable_allocs)

	var csrcColorBlendFactor_allocs *cgoAllocMap
	ref9e889477.srcColorBlendFactor, csrcColorBlendFactor_allocs = (C.VkBlendFactor)(x.SrcColorBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(csrcColorBlendFactor_allocs)

	var cdstColorBlendFactor_allocs *cgoAllocMap
	ref9e889477.dstColorBlendFactor, cdstColorBlendFactor_allocs = (C.VkBlendFactor)(x.DstColorBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(cdstColorBlendFactor_allocs)

	var ccolorBlendOp_allocs *cgoAllocMap
	ref9e889477.colorBlendOp, ccolorBlendOp_allocs = (C.VkBlendOp)(x.ColorBlendOp), cgoAllocsUnknown
	allocs9e889477.Borrow(ccolorBlendOp_allocs)

	var csrcAlphaBlendFactor_allocs *cgoAllocMap
	ref9e889477.srcAlphaBlendFactor, csrcAlphaBlendFactor_allocs = (C.VkBlendFactor)(x.SrcAlphaBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(csrcAlphaBlendFactor_allocs)

	var cdstAlphaBlendFactor_allocs *cgoAllocMap
	ref9e889477.dstAlphaBlendFactor, cdstAlphaBlendFactor_allocs = (C.VkBlendFactor)(x.DstAlphaBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(cdstAlphaBlendFactor_allocs)

	var calphaBlendOp_allocs *cgoAllocMap
	ref9e889477.alphaBlendOp, calphaBlendOp_allocs = (C.VkBlendOp)(x.AlphaBlendOp), cgoAllocsUnknown
	allocs9e889477.Borrow(calphaBlendOp_allocs)

	var ccolorWriteMask_allocs *cgoAllocMap
	ref9e889477.colorWriteMask, ccolorWriteMask_allocs = (C.VkColorComponentFlags)(x.ColorWriteMask), cgoAllocsUnknown
	allocs9e889477.Borrow(ccolorWriteMask_allocs)

	x.ref9e889477 = ref9e889477
	x.allocs9e889477 = allocs9e889477
	return ref9e889477, allocs9e889477

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PipelineColorBlendAttachmentState) PassValue() (C.VkPipelineColorBlendAttachmentState, *cgoAllocMap) {
	if x == nil {
		x = NewPipelineColorBlendAttachmentStateRef(nil)
	} else if x.ref9e889477 != nil {
		return *x.ref9e889477, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineColorBlendAttachmentState) Deref() {
	if x.ref9e889477 == nil {
		return
	}
	x.BlendEnable = (Bool32)(x.ref9e889477.blendEnable)
	x.SrcColorBlendFactor = (BlendFactor)(x.ref9e889477.srcColorBlendFactor)
	x.DstColorBlendFactor = (BlendFactor)(x.ref9e889477.dstColorBlendFactor)
	x.ColorBlendOp = (BlendOp)(x.ref9e889477.colorBlendOp)
	x.SrcAlphaBlendFactor = (BlendFactor)(x.ref9e889477.srcAlphaBlendFactor)
	x.DstAlphaBlendFactor = (BlendFactor)(x.ref9e889477.dstAlphaBlendFactor)
	x.AlphaBlendOp = (BlendOp)(x.ref9e889477.alphaBlendOp)
	x.ColorWriteMask = (ColorComponentFlags)(x.ref9e889477.colorWriteMask)
}

// allocPipelineColorBlendStateCreateInfoMemory allocates memory for type C.VkPipelineColorBlendStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorBlendStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorBlendStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineColorBlendStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineColorBlendStateCreateInfo{})

// unpackSPipelineColorBlendAttachmentState transforms a sliced Go data structure into plain C format.
func unpackSPipelineColorBlendAttachmentState(x []PipelineColorBlendAttachmentState) (unpacked *C.VkPipelineColorBlendAttachmentState, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineColorBlendAttachmentState) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineColorBlendAttachmentStateMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(h.Data))
	return
}

// packSPipelineColorBlendAttachmentState reads sliced Go data structure out from plain C format.
func packSPipelineColorBlendAttachmentState(v []PipelineColorBlendAttachmentState, ptr0 *C.VkPipelineColorBlendAttachmentState) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineColorBlendAttachmentStateValue]C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineColorBlendAttachmentStateRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *PipelineColorBlendStateCreateInfo) Ref() *C.VkPipelineColorBlendStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref2a9b490b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineColorBlendStateCreateInfo) Free() {
	if x != nil && x.allocs2a9b490b != nil {
		x.allocs2a9b490b.(*cgoAllocMap).Free()
		x.ref2a9b490b = nil
	}
}

// NewPipelineColorBlendStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineColorBlendStateCreateInfoRef(ref *C.VkPipelineColorBlendStateCreateInfo) *PipelineColorBlendStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineColorBlendStateCreateInfo)
	obj.ref2a9b490b = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineColorBlendStateCreateInfo) PassRef() (*C.VkPipelineColorBlendStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2a9b490b != nil {
		return x.ref2a9b490b, nil
	}
	mem2a9b490b := allocPipelineColorBlendStateCreateInfoMemory(1)
	ref2a9b490b := (*C.VkPipelineColorBlendStateCreateInfo)(mem2a9b490b)
	allocs2a9b490b := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref2a9b490b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2a9b490b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2a9b490b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref2a9b490b.flags, cflags_allocs = (C.VkPipelineColorBlendStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cflags_allocs)

	var clogicOpEnable_allocs *cgoAllocMap
	ref2a9b490b.logicOpEnable, clogicOpEnable_allocs = (C.VkBool32)(x.LogicOpEnable), cgoAllocsUnknown
	allocs2a9b490b.Borrow(clogicOpEnable_allocs)

	var clogicOp_allocs *cgoAllocMap
	ref2a9b490b.logicOp, clogicOp_allocs = (C.VkLogicOp)(x.LogicOp), cgoAllocsUnknown
	allocs2a9b490b.Borrow(clogicOp_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	ref2a9b490b.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	ref2a9b490b.pAttachments, cpAttachments_allocs = unpackSPipelineColorBlendAttachmentState(x.PAttachments)
	allocs2a9b490b.Borrow(cpAttachments_allocs)

	var cblendConstants_allocs *cgoAllocMap
	ref2a9b490b.blendConstants, cblendConstants_allocs = *(*[4]C.float)(unsafe.Pointer(&x.BlendConstants)), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cblendConstants_allocs)

	x.ref2a9b490b = ref2a9b490b
	x.allocs2a9b490b = allocs2a9b490b
	return ref2a9b490b, allocs2a9b490b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PipelineColorBlendStateCreateInfo) PassValue() (C.VkPipelineColorBlendStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewPipelineColorBlendStateCreateInfoRef(nil)
	} else if x.ref2a9b490b != nil {
		return *x.ref2a9b490b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineColorBlendStateCreateInfo) Deref() {
	if x.ref2a9b490b == nil {
		return
	}
	x.SType = (StructureType)(x.ref2a9b490b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2a9b490b.pNext))
	x.Flags = (PipelineColorBlendStateCreateFlags)(x.ref2a9b490b.flags)
	x.LogicOpEnable = (Bool32)(x.ref2a9b490b.logicOpEnable)
	x.LogicOp = (LogicOp)(x.ref2a9b490b.logicOp)
	x.AttachmentCount = (uint32)(x.ref2a9b490b.attachmentCount)
	packSPipelineColorBlendAttachmentState(x.PAttachments, x.ref2a9b490b.pAttachments)
	x.BlendConstants = *(*[4]float32)(unsafe.Pointer(&x.ref2a9b490b.blendConstants))
}

// allocPipelineDynamicStateCreateInfoMemory allocates memory for type C.VkPipelineDynamicStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineDynamicStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineDynamicStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineDynamicStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineDynamicStateCreateInfo{})

// Ref returns a reference.
func (x *PipelineDynamicStateCreateInfo) Ref() *C.VkPipelineDynamicStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref246d7bc8
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineDynamicStateCreateInfo) Free() {
	if x != nil && x.allocs246d7bc8 != nil {
		x.allocs246d7bc8.(*cgoAllocMap).Free()
		x.ref246d7bc8 = nil
	}
}

// NewPipelineDynamicStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineDynamicStateCreateInfoRef(ref *C.VkPipelineDynamicStateCreateInfo) *PipelineDynamicStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineDynamicStateCreateInfo)
	obj.ref246d7bc8 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineDynamicStateCreateInfo) PassRef() (*C.VkPipelineDynamicStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref246d7bc8 != nil {
		return x.ref246d7bc8, nil
	}
	mem246d7bc8 := allocPipelineDynamicStateCreateInfoMemory(1)
	ref246d7bc8 := (*C.VkPipelineDynamicStateCreateInfo)(mem246d7bc8)
	allocs246d7bc8 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref246d7bc8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs246d7bc8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref246d7bc8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref246d7bc8.flags, cflags_allocs = (C.VkPipelineDynamicStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cflags_allocs)

	var cdynamicStateCount_allocs *cgoAllocMap
	ref246d7bc8.dynamicStateCount, cdynamicStateCount_allocs = (C.uint32_t)(x.DynamicStateCount), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cdynamicStateCount_allocs)

	var cpDynamicStates_allocs *cgoAllocMap
	ref246d7bc8.pDynamicStates, cpDynamicStates_allocs = (*C.VkDynamicState)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDynamicStates)).Data)), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cpDynamicStates_allocs)

	x.ref246d7bc8 = ref246d7bc8
	x.allocs246d7bc8 = allocs246d7bc8
	return ref246d7bc8, allocs246d7bc8

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PipelineDynamicStateCreateInfo) PassValue() (C.VkPipelineDynamicStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewPipelineDynamicStateCreateInfoRef(nil)
	} else if x.ref246d7bc8 != nil {
		return *x.ref246d7bc8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineDynamicStateCreateInfo) Deref() {
	if x.ref246d7bc8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref246d7bc8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref246d7bc8.pNext))
	x.Flags = (PipelineDynamicStateCreateFlags)(x.ref246d7bc8.flags)
	x.DynamicStateCount = (uint32)(x.ref246d7bc8.dynamicStateCount)
	hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&x.PDynamicStates))
	hxf7a6dff.Data = uintptr(unsafe.Pointer(x.ref246d7bc8.pDynamicStates))
	hxf7a6dff.Cap = 0x7fffffff
	// hxf7a6dff.Len = ?

}

// allocGraphicsPipelineCreateInfoMemory allocates memory for type C.VkGraphicsPipelineCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGraphicsPipelineCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGraphicsPipelineCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGraphicsPipelineCreateInfoValue = unsafe.Sizeof([1]C.VkGraphicsPipelineCreateInfo{})

// unpackSPipelineShaderStageCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineShaderStageCreateInfo(x []PipelineShaderStageCreateInfo) (unpacked *C.VkPipelineShaderStageCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineShaderStageCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineShaderStageCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineVertexInputStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineVertexInputStateCreateInfo(x []PipelineVertexInputStateCreateInfo) (unpacked *C.VkPipelineVertexInputStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineVertexInputStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineVertexInputStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineInputAssemblyStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineInputAssemblyStateCreateInfo(x []PipelineInputAssemblyStateCreateInfo) (unpacked *C.VkPipelineInputAssemblyStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineInputAssemblyStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineInputAssemblyStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineTessellationStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineTessellationStateCreateInfo(x []PipelineTessellationStateCreateInfo) (unpacked *C.VkPipelineTessellationStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineTessellationStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineTessellationStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineViewportStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineViewportStateCreateInfo(x []PipelineViewportStateCreateInfo) (unpacked *C.VkPipelineViewportStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineViewportStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineViewportStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineViewportStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineViewportStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineRasterizationStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineRasterizationStateCreateInfo(x []PipelineRasterizationStateCreateInfo) (unpacked *C.VkPipelineRasterizationStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineRasterizationStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineRasterizationStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineRasterizationStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineRasterizationStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineMultisampleStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineMultisampleStateCreateInfo(x []PipelineMultisampleStateCreateInfo) (unpacked *C.VkPipelineMultisampleStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineMultisampleStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineMultisampleStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineMultisampleStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineMultisampleStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineDepthStencilStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineDepthStencilStateCreateInfo(x []PipelineDepthStencilStateCreateInfo) (unpacked *C.VkPipelineDepthStencilStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineDepthStencilStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineDepthStencilStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineDepthStencilStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineDepthStencilStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineColorBlendStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineColorBlendStateCreateInfo(x []PipelineColorBlendStateCreateInfo) (unpacked *C.VkPipelineColorBlendStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineColorBlendStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineColorBlendStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineColorBlendStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineColorBlendStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineDynamicStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineDynamicStateCreateInfo(x []PipelineDynamicStateCreateInfo) (unpacked *C.VkPipelineDynamicStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineDynamicStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineDynamicStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// packSPipelineShaderStageCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineShaderStageCreateInfo(v []PipelineShaderStageCreateInfo, ptr0 *C.VkPipelineShaderStageCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineShaderStageCreateInfoValue]C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineShaderStageCreateInfoRef(&ptr1)
	}
}

// packSPipelineVertexInputStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineVertexInputStateCreateInfo(v []PipelineVertexInputStateCreateInfo, ptr0 *C.VkPipelineVertexInputStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineVertexInputStateCreateInfoValue]C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineVertexInputStateCreateInfoRef(&ptr1)
	}
}

// packSPipelineInputAssemblyStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineInputAssemblyStateCreateInfo(v []PipelineInputAssemblyStateCreateInfo, ptr0 *C.VkPipelineInputAssemblyStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineInputAssemblyStateCreateInfoValue]C.VkPipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineInputAssemblyStateCreateInfoRef(&ptr1)
	}
}

// packSPipelineTessellationStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineTessellationStateCreateInfo(v []PipelineTessellationStateCreateInfo, ptr0 *C.VkPipelineTessellationStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineTessellationStateCreateInfoValue]C.VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineTessellationStateCreateInfoRef(&ptr1)
	}
}

// packSPipelineViewportStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineViewportStateCreateInfo(v []PipelineViewportStateCreateInfo, ptr0 *C.VkPipelineViewportStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineViewportStateCreateInfoValue]C.VkPipelineViewportStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineViewportStateCreateInfoRef(&ptr1)
	}
}

// packSPipelineRasterizationStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineRasterizationStateCreateInfo(v []PipelineRasterizationStateCreateInfo, ptr0 *C.VkPipelineRasterizationStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineRasterizationStateCreateInfoValue]C.VkPipelineRasterizationStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineRasterizationStateCreateInfoRef(&ptr1)
	}
}

// packSPipelineMultisampleStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineMultisampleStateCreateInfo(v []PipelineMultisampleStateCreateInfo, ptr0 *C.VkPipelineMultisampleStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineMultisampleStateCreateInfoValue]C.VkPipelineMultisampleStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineMultisampleStateCreateInfoRef(&ptr1)
	}
}

// packSPipelineDepthStencilStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineDepthStencilStateCreateInfo(v []PipelineDepthStencilStateCreateInfo, ptr0 *C.VkPipelineDepthStencilStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineDepthStencilStateCreateInfoValue]C.VkPipelineDepthStencilStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineDepthStencilStateCreateInfoRef(&ptr1)
	}
}

// packSPipelineColorBlendStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineColorBlendStateCreateInfo(v []PipelineColorBlendStateCreateInfo, ptr0 *C.VkPipelineColorBlendStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineColorBlendStateCreateInfoValue]C.VkPipelineColorBlendStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineColorBlendStateCreateInfoRef(&ptr1)
	}
}

// packSPipelineDynamicStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineDynamicStateCreateInfo(v []PipelineDynamicStateCreateInfo, ptr0 *C.VkPipelineDynamicStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineDynamicStateCreateInfoValue]C.VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineDynamicStateCreateInfoRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *GraphicsPipelineCreateInfo) Ref() *C.VkGraphicsPipelineCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref178f88b6
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *GraphicsPipelineCreateInfo) Free() {
	if x != nil && x.allocs178f88b6 != nil {
		x.allocs178f88b6.(*cgoAllocMap).Free()
		x.ref178f88b6 = nil
	}
}

// NewGraphicsPipelineCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewGraphicsPipelineCreateInfoRef(ref *C.VkGraphicsPipelineCreateInfo) *GraphicsPipelineCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(GraphicsPipelineCreateInfo)
	obj.ref178f88b6 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *GraphicsPipelineCreateInfo) PassRef() (*C.VkGraphicsPipelineCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref178f88b6 != nil {
		return x.ref178f88b6, nil
	}
	mem178f88b6 := allocGraphicsPipelineCreateInfoMemory(1)
	ref178f88b6 := (*C.VkGraphicsPipelineCreateInfo)(mem178f88b6)
	allocs178f88b6 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref178f88b6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs178f88b6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref178f88b6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs178f88b6.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref178f88b6.flags, cflags_allocs = (C.VkPipelineCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs178f88b6.Borrow(cflags_allocs)

	var cstageCount_allocs *cgoAllocMap
	ref178f88b6.stageCount, cstageCount_allocs = (C.uint32_t)(x.StageCount), cgoAllocsUnknown
	allocs178f88b6.Borrow(cstageCount_allocs)

	var cpStages_allocs *cgoAllocMap
	ref178f88b6.pStages, cpStages_allocs = unpackSPipelineShaderStageCreateInfo(x.PStages)
	allocs178f88b6.Borrow(cpStages_allocs)

	var cpVertexInputState_allocs *cgoAllocMap
	ref178f88b6.pVertexInputState, cpVertexInputState_allocs = unpackSPipelineVertexInputStateCreateInfo(x.PVertexInputState)
	allocs178f88b6.Borrow(cpVertexInputState_allocs)

	var cpInputAssemblyState_allocs *cgoAllocMap
	ref178f88b6.pInputAssemblyState, cpInputAssemblyState_allocs = unpackSPipelineInputAssemblyStateCreateInfo(x.PInputAssemblyState)
	allocs178f88b6.Borrow(cpInputAssemblyState_allocs)

	var cpTessellationState_allocs *cgoAllocMap
	ref178f88b6.pTessellationState, cpTessellationState_allocs = unpackSPipelineTessellationStateCreateInfo(x.PTessellationState)
	allocs178f88b6.Borrow(cpTessellationState_allocs)

	var cpViewportState_allocs *cgoAllocMap
	ref178f88b6.pViewportState, cpViewportState_allocs = unpackSPipelineViewportStateCreateInfo(x.PViewportState)
	allocs178f88b6.Borrow(cpViewportState_allocs)

	var cpRasterizationState_allocs *cgoAllocMap
	ref178f88b6.pRasterizationState, cpRasterizationState_allocs = unpackSPipelineRasterizationStateCreateInfo(x.PRasterizationState)
	allocs178f88b6.Borrow(cpRasterizationState_allocs)

	var cpMultisampleState_allocs *cgoAllocMap
	ref178f88b6.pMultisampleState, cpMultisampleState_allocs = unpackSPipelineMultisampleStateCreateInfo(x.PMultisampleState)
	allocs178f88b6.Borrow(cpMultisampleState_allocs)

	var cpDepthStencilState_allocs *cgoAllocMap
	ref178f88b6.pDepthStencilState, cpDepthStencilState_allocs = unpackSPipelineDepthStencilStateCreateInfo(x.PDepthStencilState)
	allocs178f88b6.Borrow(cpDepthStencilState_allocs)

	var cpColorBlendState_allocs *cgoAllocMap
	ref178f88b6.pColorBlendState, cpColorBlendState_allocs = unpackSPipelineColorBlendStateCreateInfo(x.PColorBlendState)
	allocs178f88b6.Borrow(cpColorBlendState_allocs)

	var cpDynamicState_allocs *cgoAllocMap
	ref178f88b6.pDynamicState, cpDynamicState_allocs = unpackSPipelineDynamicStateCreateInfo(x.PDynamicState)
	allocs178f88b6.Borrow(cpDynamicState_allocs)

	var clayout_allocs *cgoAllocMap
	ref178f88b6.layout, clayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.Layout)), cgoAllocsUnknown
	allocs178f88b6.Borrow(clayout_allocs)

	var crenderPass_allocs *cgoAllocMap
	ref178f88b6.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocs178f88b6.Borrow(crenderPass_allocs)

	var csubpass_allocs *cgoAllocMap
	ref178f88b6.subpass, csubpass_allocs = (C.uint32_t)(x.Subpass), cgoAllocsUnknown
	allocs178f88b6.Borrow(csubpass_allocs)

	var cbasePipelineHandle_allocs *cgoAllocMap
	ref178f88b6.basePipelineHandle, cbasePipelineHandle_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.BasePipelineHandle)), cgoAllocsUnknown
	allocs178f88b6.Borrow(cbasePipelineHandle_allocs)

	var cbasePipelineIndex_allocs *cgoAllocMap
	ref178f88b6.basePipelineIndex, cbasePipelineIndex_allocs = (C.int32_t)(x.BasePipelineIndex), cgoAllocsUnknown
	allocs178f88b6.Borrow(cbasePipelineIndex_allocs)

	x.ref178f88b6 = ref178f88b6
	x.allocs178f88b6 = allocs178f88b6
	return ref178f88b6, allocs178f88b6

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *GraphicsPipelineCreateInfo) PassValue() (C.VkGraphicsPipelineCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewGraphicsPipelineCreateInfoRef(nil)
	} else if x.ref178f88b6 != nil {
		return *x.ref178f88b6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *GraphicsPipelineCreateInfo) Deref() {
	if x.ref178f88b6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref178f88b6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref178f88b6.pNext))
	x.Flags = (PipelineCreateFlags)(x.ref178f88b6.flags)
	x.StageCount = (uint32)(x.ref178f88b6.stageCount)
	packSPipelineShaderStageCreateInfo(x.PStages, x.ref178f88b6.pStages)
	packSPipelineVertexInputStateCreateInfo(x.PVertexInputState, x.ref178f88b6.pVertexInputState)
	packSPipelineInputAssemblyStateCreateInfo(x.PInputAssemblyState, x.ref178f88b6.pInputAssemblyState)
	packSPipelineTessellationStateCreateInfo(x.PTessellationState, x.ref178f88b6.pTessellationState)
	packSPipelineViewportStateCreateInfo(x.PViewportState, x.ref178f88b6.pViewportState)
	packSPipelineRasterizationStateCreateInfo(x.PRasterizationState, x.ref178f88b6.pRasterizationState)
	packSPipelineMultisampleStateCreateInfo(x.PMultisampleState, x.ref178f88b6.pMultisampleState)
	packSPipelineDepthStencilStateCreateInfo(x.PDepthStencilState, x.ref178f88b6.pDepthStencilState)
	packSPipelineColorBlendStateCreateInfo(x.PColorBlendState, x.ref178f88b6.pColorBlendState)
	packSPipelineDynamicStateCreateInfo(x.PDynamicState, x.ref178f88b6.pDynamicState)
	x.Layout = *(*PipelineLayout)(unsafe.Pointer(&x.ref178f88b6.layout))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref178f88b6.renderPass))
	x.Subpass = (uint32)(x.ref178f88b6.subpass)
	x.BasePipelineHandle = *(*Pipeline)(unsafe.Pointer(&x.ref178f88b6.basePipelineHandle))
	x.BasePipelineIndex = (int32)(x.ref178f88b6.basePipelineIndex)
}

// allocComputePipelineCreateInfoMemory allocates memory for type C.VkComputePipelineCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocComputePipelineCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfComputePipelineCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfComputePipelineCreateInfoValue = unsafe.Sizeof([1]C.VkComputePipelineCreateInfo{})

// Ref returns a reference.
func (x *ComputePipelineCreateInfo) Ref() *C.VkComputePipelineCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref77823220
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ComputePipelineCreateInfo) Free() {
	if x != nil && x.allocs77823220 != nil {
		x.allocs77823220.(*cgoAllocMap).Free()
		x.ref77823220 = nil
	}
}

// NewComputePipelineCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewComputePipelineCreateInfoRef(ref *C.VkComputePipelineCreateInfo) *ComputePipelineCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ComputePipelineCreateInfo)
	obj.ref77823220 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ComputePipelineCreateInfo) PassRef() (*C.VkComputePipelineCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref77823220 != nil {
		return x.ref77823220, nil
	}
	mem77823220 := allocComputePipelineCreateInfoMemory(1)
	ref77823220 := (*C.VkComputePipelineCreateInfo)(mem77823220)
	allocs77823220 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref77823220.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs77823220.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref77823220.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs77823220.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref77823220.flags, cflags_allocs = (C.VkPipelineCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs77823220.Borrow(cflags_allocs)

	var cstage_allocs *cgoAllocMap
	ref77823220.stage, cstage_allocs = x.Stage.PassValue()
	allocs77823220.Borrow(cstage_allocs)

	var clayout_allocs *cgoAllocMap
	ref77823220.layout, clayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.Layout)), cgoAllocsUnknown
	allocs77823220.Borrow(clayout_allocs)

	var cbasePipelineHandle_allocs *cgoAllocMap
	ref77823220.basePipelineHandle, cbasePipelineHandle_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.BasePipelineHandle)), cgoAllocsUnknown
	allocs77823220.Borrow(cbasePipelineHandle_allocs)

	var cbasePipelineIndex_allocs *cgoAllocMap
	ref77823220.basePipelineIndex, cbasePipelineIndex_allocs = (C.int32_t)(x.BasePipelineIndex), cgoAllocsUnknown
	allocs77823220.Borrow(cbasePipelineIndex_allocs)

	x.ref77823220 = ref77823220
	x.allocs77823220 = allocs77823220
	return ref77823220, allocs77823220

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ComputePipelineCreateInfo) PassValue() (C.VkComputePipelineCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewComputePipelineCreateInfoRef(nil)
	} else if x.ref77823220 != nil {
		return *x.ref77823220, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ComputePipelineCreateInfo) Deref() {
	if x.ref77823220 == nil {
		return
	}
	x.SType = (StructureType)(x.ref77823220.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref77823220.pNext))
	x.Flags = (PipelineCreateFlags)(x.ref77823220.flags)
	x.Stage = *NewPipelineShaderStageCreateInfoRef(&x.ref77823220.stage)
	x.Layout = *(*PipelineLayout)(unsafe.Pointer(&x.ref77823220.layout))
	x.BasePipelineHandle = *(*Pipeline)(unsafe.Pointer(&x.ref77823220.basePipelineHandle))
	x.BasePipelineIndex = (int32)(x.ref77823220.basePipelineIndex)
}

// allocPushConstantRangeMemory allocates memory for type C.VkPushConstantRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPushConstantRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPushConstantRangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPushConstantRangeValue = unsafe.Sizeof([1]C.VkPushConstantRange{})

// Ref returns a reference.
func (x *PushConstantRange) Ref() *C.VkPushConstantRange {
	if x == nil {
		return nil
	}
	return x.ref6f025856
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PushConstantRange) Free() {
	if x != nil && x.allocs6f025856 != nil {
		x.allocs6f025856.(*cgoAllocMap).Free()
		x.ref6f025856 = nil
	}
}

// NewPushConstantRangeRef initialises a new struct holding the reference to the originaitng C struct.
func NewPushConstantRangeRef(ref *C.VkPushConstantRange) *PushConstantRange {
	if ref == nil {
		return nil
	}
	obj := new(PushConstantRange)
	obj.ref6f025856 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PushConstantRange) PassRef() (*C.VkPushConstantRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6f025856 != nil {
		return x.ref6f025856, nil
	}
	mem6f025856 := allocPushConstantRangeMemory(1)
	ref6f025856 := (*C.VkPushConstantRange)(mem6f025856)
	allocs6f025856 := new(cgoAllocMap)
	var cstageFlags_allocs *cgoAllocMap
	ref6f025856.stageFlags, cstageFlags_allocs = (C.VkShaderStageFlags)(x.StageFlags), cgoAllocsUnknown
	allocs6f025856.Borrow(cstageFlags_allocs)

	var coffset_allocs *cgoAllocMap
	ref6f025856.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocs6f025856.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref6f025856.size, csize_allocs = (C.uint32_t)(x.Size), cgoAllocsUnknown
	allocs6f025856.Borrow(csize_allocs)

	x.ref6f025856 = ref6f025856
	x.allocs6f025856 = allocs6f025856
	return ref6f025856, allocs6f025856

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PushConstantRange) PassValue() (C.VkPushConstantRange, *cgoAllocMap) {
	if x == nil {
		x = NewPushConstantRangeRef(nil)
	} else if x.ref6f025856 != nil {
		return *x.ref6f025856, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PushConstantRange) Deref() {
	if x.ref6f025856 == nil {
		return
	}
	x.StageFlags = (ShaderStageFlags)(x.ref6f025856.stageFlags)
	x.Offset = (uint32)(x.ref6f025856.offset)
	x.Size = (uint32)(x.ref6f025856.size)
}

// allocPipelineLayoutCreateInfoMemory allocates memory for type C.VkPipelineLayoutCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineLayoutCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineLayoutCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineLayoutCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineLayoutCreateInfo{})

// unpackSPushConstantRange transforms a sliced Go data structure into plain C format.
func unpackSPushConstantRange(x []PushConstantRange) (unpacked *C.VkPushConstantRange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPushConstantRange) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPushConstantRangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPushConstantRange)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPushConstantRange)(unsafe.Pointer(h.Data))
	return
}

// packSPushConstantRange reads sliced Go data structure out from plain C format.
func packSPushConstantRange(v []PushConstantRange, ptr0 *C.VkPushConstantRange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPushConstantRangeValue]C.VkPushConstantRange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPushConstantRangeRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *PipelineLayoutCreateInfo) Ref() *C.VkPipelineLayoutCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref64cc4eed
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineLayoutCreateInfo) Free() {
	if x != nil && x.allocs64cc4eed != nil {
		x.allocs64cc4eed.(*cgoAllocMap).Free()
		x.ref64cc4eed = nil
	}
}

// NewPipelineLayoutCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineLayoutCreateInfoRef(ref *C.VkPipelineLayoutCreateInfo) *PipelineLayoutCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineLayoutCreateInfo)
	obj.ref64cc4eed = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineLayoutCreateInfo) PassRef() (*C.VkPipelineLayoutCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref64cc4eed != nil {
		return x.ref64cc4eed, nil
	}
	mem64cc4eed := allocPipelineLayoutCreateInfoMemory(1)
	ref64cc4eed := (*C.VkPipelineLayoutCreateInfo)(mem64cc4eed)
	allocs64cc4eed := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref64cc4eed.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs64cc4eed.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref64cc4eed.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref64cc4eed.flags, cflags_allocs = (C.VkPipelineLayoutCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cflags_allocs)

	var csetLayoutCount_allocs *cgoAllocMap
	ref64cc4eed.setLayoutCount, csetLayoutCount_allocs = (C.uint32_t)(x.SetLayoutCount), cgoAllocsUnknown
	allocs64cc4eed.Borrow(csetLayoutCount_allocs)

	var cpSetLayouts_allocs *cgoAllocMap
	ref64cc4eed.pSetLayouts, cpSetLayouts_allocs = (*C.VkDescriptorSetLayout)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSetLayouts)).Data)), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cpSetLayouts_allocs)

	var cpushConstantRangeCount_allocs *cgoAllocMap
	ref64cc4eed.pushConstantRangeCount, cpushConstantRangeCount_allocs = (C.uint32_t)(x.PushConstantRangeCount), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cpushConstantRangeCount_allocs)

	var cpPushConstantRanges_allocs *cgoAllocMap
	ref64cc4eed.pPushConstantRanges, cpPushConstantRanges_allocs = unpackSPushConstantRange(x.PPushConstantRanges)
	allocs64cc4eed.Borrow(cpPushConstantRanges_allocs)

	x.ref64cc4eed = ref64cc4eed
	x.allocs64cc4eed = allocs64cc4eed
	return ref64cc4eed, allocs64cc4eed

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PipelineLayoutCreateInfo) PassValue() (C.VkPipelineLayoutCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewPipelineLayoutCreateInfoRef(nil)
	} else if x.ref64cc4eed != nil {
		return *x.ref64cc4eed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineLayoutCreateInfo) Deref() {
	if x.ref64cc4eed == nil {
		return
	}
	x.SType = (StructureType)(x.ref64cc4eed.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref64cc4eed.pNext))
	x.Flags = (PipelineLayoutCreateFlags)(x.ref64cc4eed.flags)
	x.SetLayoutCount = (uint32)(x.ref64cc4eed.setLayoutCount)
	hxfe48d67 := (*sliceHeader)(unsafe.Pointer(&x.PSetLayouts))
	hxfe48d67.Data = uintptr(unsafe.Pointer(x.ref64cc4eed.pSetLayouts))
	hxfe48d67.Cap = 0x7fffffff
	// hxfe48d67.Len = ?

	x.PushConstantRangeCount = (uint32)(x.ref64cc4eed.pushConstantRangeCount)
	packSPushConstantRange(x.PPushConstantRanges, x.ref64cc4eed.pPushConstantRanges)
}

// allocSamplerCreateInfoMemory allocates memory for type C.VkSamplerCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSamplerCreateInfoValue = unsafe.Sizeof([1]C.VkSamplerCreateInfo{})

// Ref returns a reference.
func (x *SamplerCreateInfo) Ref() *C.VkSamplerCreateInfo {
	if x == nil {
		return nil
	}
	return x.refce034abf
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SamplerCreateInfo) Free() {
	if x != nil && x.allocsce034abf != nil {
		x.allocsce034abf.(*cgoAllocMap).Free()
		x.refce034abf = nil
	}
}

// NewSamplerCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewSamplerCreateInfoRef(ref *C.VkSamplerCreateInfo) *SamplerCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerCreateInfo)
	obj.refce034abf = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SamplerCreateInfo) PassRef() (*C.VkSamplerCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refce034abf != nil {
		return x.refce034abf, nil
	}
	memce034abf := allocSamplerCreateInfoMemory(1)
	refce034abf := (*C.VkSamplerCreateInfo)(memce034abf)
	allocsce034abf := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refce034abf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsce034abf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refce034abf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsce034abf.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refce034abf.flags, cflags_allocs = (C.VkSamplerCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsce034abf.Borrow(cflags_allocs)

	var cmagFilter_allocs *cgoAllocMap
	refce034abf.magFilter, cmagFilter_allocs = (C.VkFilter)(x.MagFilter), cgoAllocsUnknown
	allocsce034abf.Borrow(cmagFilter_allocs)

	var cminFilter_allocs *cgoAllocMap
	refce034abf.minFilter, cminFilter_allocs = (C.VkFilter)(x.MinFilter), cgoAllocsUnknown
	allocsce034abf.Borrow(cminFilter_allocs)

	var cmipmapMode_allocs *cgoAllocMap
	refce034abf.mipmapMode, cmipmapMode_allocs = (C.VkSamplerMipmapMode)(x.MipmapMode), cgoAllocsUnknown
	allocsce034abf.Borrow(cmipmapMode_allocs)

	var caddressModeU_allocs *cgoAllocMap
	refce034abf.addressModeU, caddressModeU_allocs = (C.VkSamplerAddressMode)(x.AddressModeU), cgoAllocsUnknown
	allocsce034abf.Borrow(caddressModeU_allocs)

	var caddressModeV_allocs *cgoAllocMap
	refce034abf.addressModeV, caddressModeV_allocs = (C.VkSamplerAddressMode)(x.AddressModeV), cgoAllocsUnknown
	allocsce034abf.Borrow(caddressModeV_allocs)

	var caddressModeW_allocs *cgoAllocMap
	refce034abf.addressModeW, caddressModeW_allocs = (C.VkSamplerAddressMode)(x.AddressModeW), cgoAllocsUnknown
	allocsce034abf.Borrow(caddressModeW_allocs)

	var cmipLodBias_allocs *cgoAllocMap
	refce034abf.mipLodBias, cmipLodBias_allocs = (C.float)(x.MipLodBias), cgoAllocsUnknown
	allocsce034abf.Borrow(cmipLodBias_allocs)

	var canisotropyEnable_allocs *cgoAllocMap
	refce034abf.anisotropyEnable, canisotropyEnable_allocs = (C.VkBool32)(x.AnisotropyEnable), cgoAllocsUnknown
	allocsce034abf.Borrow(canisotropyEnable_allocs)

	var cmaxAnisotropy_allocs *cgoAllocMap
	refce034abf.maxAnisotropy, cmaxAnisotropy_allocs = (C.float)(x.MaxAnisotropy), cgoAllocsUnknown
	allocsce034abf.Borrow(cmaxAnisotropy_allocs)

	var ccompareEnable_allocs *cgoAllocMap
	refce034abf.compareEnable, ccompareEnable_allocs = (C.VkBool32)(x.CompareEnable), cgoAllocsUnknown
	allocsce034abf.Borrow(ccompareEnable_allocs)

	var ccompareOp_allocs *cgoAllocMap
	refce034abf.compareOp, ccompareOp_allocs = (C.VkCompareOp)(x.CompareOp), cgoAllocsUnknown
	allocsce034abf.Borrow(ccompareOp_allocs)

	var cminLod_allocs *cgoAllocMap
	refce034abf.minLod, cminLod_allocs = (C.float)(x.MinLod), cgoAllocsUnknown
	allocsce034abf.Borrow(cminLod_allocs)

	var cmaxLod_allocs *cgoAllocMap
	refce034abf.maxLod, cmaxLod_allocs = (C.float)(x.MaxLod), cgoAllocsUnknown
	allocsce034abf.Borrow(cmaxLod_allocs)

	var cborderColor_allocs *cgoAllocMap
	refce034abf.borderColor, cborderColor_allocs = (C.VkBorderColor)(x.BorderColor), cgoAllocsUnknown
	allocsce034abf.Borrow(cborderColor_allocs)

	var cunnormalizedCoordinates_allocs *cgoAllocMap
	refce034abf.unnormalizedCoordinates, cunnormalizedCoordinates_allocs = (C.VkBool32)(x.UnnormalizedCoordinates), cgoAllocsUnknown
	allocsce034abf.Borrow(cunnormalizedCoordinates_allocs)

	x.refce034abf = refce034abf
	x.allocsce034abf = allocsce034abf
	return refce034abf, allocsce034abf

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SamplerCreateInfo) PassValue() (C.VkSamplerCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewSamplerCreateInfoRef(nil)
	} else if x.refce034abf != nil {
		return *x.refce034abf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SamplerCreateInfo) Deref() {
	if x.refce034abf == nil {
		return
	}
	x.SType = (StructureType)(x.refce034abf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refce034abf.pNext))
	x.Flags = (SamplerCreateFlags)(x.refce034abf.flags)
	x.MagFilter = (Filter)(x.refce034abf.magFilter)
	x.MinFilter = (Filter)(x.refce034abf.minFilter)
	x.MipmapMode = (SamplerMipmapMode)(x.refce034abf.mipmapMode)
	x.AddressModeU = (SamplerAddressMode)(x.refce034abf.addressModeU)
	x.AddressModeV = (SamplerAddressMode)(x.refce034abf.addressModeV)
	x.AddressModeW = (SamplerAddressMode)(x.refce034abf.addressModeW)
	x.MipLodBias = (float32)(x.refce034abf.mipLodBias)
	x.AnisotropyEnable = (Bool32)(x.refce034abf.anisotropyEnable)
	x.MaxAnisotropy = (float32)(x.refce034abf.maxAnisotropy)
	x.CompareEnable = (Bool32)(x.refce034abf.compareEnable)
	x.CompareOp = (CompareOp)(x.refce034abf.compareOp)
	x.MinLod = (float32)(x.refce034abf.minLod)
	x.MaxLod = (float32)(x.refce034abf.maxLod)
	x.BorderColor = (BorderColor)(x.refce034abf.borderColor)
	x.UnnormalizedCoordinates = (Bool32)(x.refce034abf.unnormalizedCoordinates)
}

// allocDescriptorSetLayoutBindingMemory allocates memory for type C.VkDescriptorSetLayoutBinding in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutBindingMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutBindingValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetLayoutBindingValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutBinding{})

// Ref returns a reference.
func (x *DescriptorSetLayoutBinding) Ref() *C.VkDescriptorSetLayoutBinding {
	if x == nil {
		return nil
	}
	return x.ref8b50b4ec
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DescriptorSetLayoutBinding) Free() {
	if x != nil && x.allocs8b50b4ec != nil {
		x.allocs8b50b4ec.(*cgoAllocMap).Free()
		x.ref8b50b4ec = nil
	}
}

// NewDescriptorSetLayoutBindingRef initialises a new struct holding the reference to the originaitng C struct.
func NewDescriptorSetLayoutBindingRef(ref *C.VkDescriptorSetLayoutBinding) *DescriptorSetLayoutBinding {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutBinding)
	obj.ref8b50b4ec = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DescriptorSetLayoutBinding) PassRef() (*C.VkDescriptorSetLayoutBinding, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8b50b4ec != nil {
		return x.ref8b50b4ec, nil
	}
	mem8b50b4ec := allocDescriptorSetLayoutBindingMemory(1)
	ref8b50b4ec := (*C.VkDescriptorSetLayoutBinding)(mem8b50b4ec)
	allocs8b50b4ec := new(cgoAllocMap)
	var cbinding_allocs *cgoAllocMap
	ref8b50b4ec.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cbinding_allocs)

	var cdescriptorType_allocs *cgoAllocMap
	ref8b50b4ec.descriptorType, cdescriptorType_allocs = (C.VkDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cdescriptorType_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	ref8b50b4ec.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cdescriptorCount_allocs)

	var cstageFlags_allocs *cgoAllocMap
	ref8b50b4ec.stageFlags, cstageFlags_allocs = (C.VkShaderStageFlags)(x.StageFlags), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cstageFlags_allocs)

	var cpImmutableSamplers_allocs *cgoAllocMap
	ref8b50b4ec.pImmutableSamplers, cpImmutableSamplers_allocs = (*C.VkSampler)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PImmutableSamplers)).Data)), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cpImmutableSamplers_allocs)

	x.ref8b50b4ec = ref8b50b4ec
	x.allocs8b50b4ec = allocs8b50b4ec
	return ref8b50b4ec, allocs8b50b4ec

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DescriptorSetLayoutBinding) PassValue() (C.VkDescriptorSetLayoutBinding, *cgoAllocMap) {
	if x == nil {
		x = NewDescriptorSetLayoutBindingRef(nil)
	} else if x.ref8b50b4ec != nil {
		return *x.ref8b50b4ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DescriptorSetLayoutBinding) Deref() {
	if x.ref8b50b4ec == nil {
		return
	}
	x.Binding = (uint32)(x.ref8b50b4ec.binding)
	x.DescriptorType = (DescriptorType)(x.ref8b50b4ec.descriptorType)
	x.DescriptorCount = (uint32)(x.ref8b50b4ec.descriptorCount)
	x.StageFlags = (ShaderStageFlags)(x.ref8b50b4ec.stageFlags)
	hxf4171bf := (*sliceHeader)(unsafe.Pointer(&x.PImmutableSamplers))
	hxf4171bf.Data = uintptr(unsafe.Pointer(x.ref8b50b4ec.pImmutableSamplers))
	hxf4171bf.Cap = 0x7fffffff
	// hxf4171bf.Len = ?

}

// allocDescriptorSetLayoutCreateInfoMemory allocates memory for type C.VkDescriptorSetLayoutCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetLayoutCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutCreateInfo{})

// unpackSDescriptorSetLayoutBinding transforms a sliced Go data structure into plain C format.
func unpackSDescriptorSetLayoutBinding(x []DescriptorSetLayoutBinding) (unpacked *C.VkDescriptorSetLayoutBinding, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorSetLayoutBinding) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorSetLayoutBindingMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(h.Data))
	return
}

// packSDescriptorSetLayoutBinding reads sliced Go data structure out from plain C format.
func packSDescriptorSetLayoutBinding(v []DescriptorSetLayoutBinding, ptr0 *C.VkDescriptorSetLayoutBinding) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorSetLayoutBindingValue]C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorSetLayoutBindingRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *DescriptorSetLayoutCreateInfo) Ref() *C.VkDescriptorSetLayoutCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5ee8e0ed
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DescriptorSetLayoutCreateInfo) Free() {
	if x != nil && x.allocs5ee8e0ed != nil {
		x.allocs5ee8e0ed.(*cgoAllocMap).Free()
		x.ref5ee8e0ed = nil
	}
}

// NewDescriptorSetLayoutCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDescriptorSetLayoutCreateInfoRef(ref *C.VkDescriptorSetLayoutCreateInfo) *DescriptorSetLayoutCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutCreateInfo)
	obj.ref5ee8e0ed = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DescriptorSetLayoutCreateInfo) PassRef() (*C.VkDescriptorSetLayoutCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ee8e0ed != nil {
		return x.ref5ee8e0ed, nil
	}
	mem5ee8e0ed := allocDescriptorSetLayoutCreateInfoMemory(1)
	ref5ee8e0ed := (*C.VkDescriptorSetLayoutCreateInfo)(mem5ee8e0ed)
	allocs5ee8e0ed := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref5ee8e0ed.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5ee8e0ed.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5ee8e0ed.flags, cflags_allocs = (C.VkDescriptorSetLayoutCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(cflags_allocs)

	var cbindingCount_allocs *cgoAllocMap
	ref5ee8e0ed.bindingCount, cbindingCount_allocs = (C.uint32_t)(x.BindingCount), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(cbindingCount_allocs)

	var cpBindings_allocs *cgoAllocMap
	ref5ee8e0ed.pBindings, cpBindings_allocs = unpackSDescriptorSetLayoutBinding(x.PBindings)
	allocs5ee8e0ed.Borrow(cpBindings_allocs)

	x.ref5ee8e0ed = ref5ee8e0ed
	x.allocs5ee8e0ed = allocs5ee8e0ed
	return ref5ee8e0ed, allocs5ee8e0ed

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DescriptorSetLayoutCreateInfo) PassValue() (C.VkDescriptorSetLayoutCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewDescriptorSetLayoutCreateInfoRef(nil)
	} else if x.ref5ee8e0ed != nil {
		return *x.ref5ee8e0ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DescriptorSetLayoutCreateInfo) Deref() {
	if x.ref5ee8e0ed == nil {
		return
	}
	x.SType = (StructureType)(x.ref5ee8e0ed.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5ee8e0ed.pNext))
	x.Flags = (DescriptorSetLayoutCreateFlags)(x.ref5ee8e0ed.flags)
	x.BindingCount = (uint32)(x.ref5ee8e0ed.bindingCount)
	packSDescriptorSetLayoutBinding(x.PBindings, x.ref5ee8e0ed.pBindings)
}

// allocDescriptorPoolSizeMemory allocates memory for type C.VkDescriptorPoolSize in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorPoolSizeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorPoolSizeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorPoolSizeValue = unsafe.Sizeof([1]C.VkDescriptorPoolSize{})

// Ref returns a reference.
func (x *DescriptorPoolSize) Ref() *C.VkDescriptorPoolSize {
	if x == nil {
		return nil
	}
	return x.refe15137da
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DescriptorPoolSize) Free() {
	if x != nil && x.allocse15137da != nil {
		x.allocse15137da.(*cgoAllocMap).Free()
		x.refe15137da = nil
	}
}

// NewDescriptorPoolSizeRef initialises a new struct holding the reference to the originaitng C struct.
func NewDescriptorPoolSizeRef(ref *C.VkDescriptorPoolSize) *DescriptorPoolSize {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorPoolSize)
	obj.refe15137da = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DescriptorPoolSize) PassRef() (*C.VkDescriptorPoolSize, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe15137da != nil {
		return x.refe15137da, nil
	}
	meme15137da := allocDescriptorPoolSizeMemory(1)
	refe15137da := (*C.VkDescriptorPoolSize)(meme15137da)
	allocse15137da := new(cgoAllocMap)
	var c_type_allocs *cgoAllocMap
	refe15137da._type, c_type_allocs = (C.VkDescriptorType)(x._type), cgoAllocsUnknown
	allocse15137da.Borrow(c_type_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	refe15137da.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocse15137da.Borrow(cdescriptorCount_allocs)

	x.refe15137da = refe15137da
	x.allocse15137da = allocse15137da
	return refe15137da, allocse15137da

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DescriptorPoolSize) PassValue() (C.VkDescriptorPoolSize, *cgoAllocMap) {
	if x == nil {
		x = NewDescriptorPoolSizeRef(nil)
	} else if x.refe15137da != nil {
		return *x.refe15137da, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DescriptorPoolSize) Deref() {
	if x.refe15137da == nil {
		return
	}
	x._type = (DescriptorType)(x.refe15137da._type)
	x.DescriptorCount = (uint32)(x.refe15137da.descriptorCount)
}

// allocDescriptorPoolCreateInfoMemory allocates memory for type C.VkDescriptorPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorPoolCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorPoolCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorPoolCreateInfo{})

// unpackSDescriptorPoolSize transforms a sliced Go data structure into plain C format.
func unpackSDescriptorPoolSize(x []DescriptorPoolSize) (unpacked *C.VkDescriptorPoolSize, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorPoolSize) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorPoolSizeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorPoolSize)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorPoolSize)(unsafe.Pointer(h.Data))
	return
}

// packSDescriptorPoolSize reads sliced Go data structure out from plain C format.
func packSDescriptorPoolSize(v []DescriptorPoolSize, ptr0 *C.VkDescriptorPoolSize) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorPoolSizeValue]C.VkDescriptorPoolSize)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorPoolSizeRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *DescriptorPoolCreateInfo) Ref() *C.VkDescriptorPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref19868463
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DescriptorPoolCreateInfo) Free() {
	if x != nil && x.allocs19868463 != nil {
		x.allocs19868463.(*cgoAllocMap).Free()
		x.ref19868463 = nil
	}
}

// NewDescriptorPoolCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDescriptorPoolCreateInfoRef(ref *C.VkDescriptorPoolCreateInfo) *DescriptorPoolCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorPoolCreateInfo)
	obj.ref19868463 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DescriptorPoolCreateInfo) PassRef() (*C.VkDescriptorPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref19868463 != nil {
		return x.ref19868463, nil
	}
	mem19868463 := allocDescriptorPoolCreateInfoMemory(1)
	ref19868463 := (*C.VkDescriptorPoolCreateInfo)(mem19868463)
	allocs19868463 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref19868463.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs19868463.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref19868463.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs19868463.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref19868463.flags, cflags_allocs = (C.VkDescriptorPoolCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs19868463.Borrow(cflags_allocs)

	var cmaxSets_allocs *cgoAllocMap
	ref19868463.maxSets, cmaxSets_allocs = (C.uint32_t)(x.MaxSets), cgoAllocsUnknown
	allocs19868463.Borrow(cmaxSets_allocs)

	var cpoolSizeCount_allocs *cgoAllocMap
	ref19868463.poolSizeCount, cpoolSizeCount_allocs = (C.uint32_t)(x.PoolSizeCount), cgoAllocsUnknown
	allocs19868463.Borrow(cpoolSizeCount_allocs)

	var cpPoolSizes_allocs *cgoAllocMap
	ref19868463.pPoolSizes, cpPoolSizes_allocs = unpackSDescriptorPoolSize(x.PPoolSizes)
	allocs19868463.Borrow(cpPoolSizes_allocs)

	x.ref19868463 = ref19868463
	x.allocs19868463 = allocs19868463
	return ref19868463, allocs19868463

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DescriptorPoolCreateInfo) PassValue() (C.VkDescriptorPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewDescriptorPoolCreateInfoRef(nil)
	} else if x.ref19868463 != nil {
		return *x.ref19868463, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DescriptorPoolCreateInfo) Deref() {
	if x.ref19868463 == nil {
		return
	}
	x.SType = (StructureType)(x.ref19868463.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref19868463.pNext))
	x.Flags = (DescriptorPoolCreateFlags)(x.ref19868463.flags)
	x.MaxSets = (uint32)(x.ref19868463.maxSets)
	x.PoolSizeCount = (uint32)(x.ref19868463.poolSizeCount)
	packSDescriptorPoolSize(x.PPoolSizes, x.ref19868463.pPoolSizes)
}

// allocDescriptorSetAllocateInfoMemory allocates memory for type C.VkDescriptorSetAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetAllocateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetAllocateInfo{})

// Ref returns a reference.
func (x *DescriptorSetAllocateInfo) Ref() *C.VkDescriptorSetAllocateInfo {
	if x == nil {
		return nil
	}
	return x.ref2dd6cc22
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DescriptorSetAllocateInfo) Free() {
	if x != nil && x.allocs2dd6cc22 != nil {
		x.allocs2dd6cc22.(*cgoAllocMap).Free()
		x.ref2dd6cc22 = nil
	}
}

// NewDescriptorSetAllocateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDescriptorSetAllocateInfoRef(ref *C.VkDescriptorSetAllocateInfo) *DescriptorSetAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetAllocateInfo)
	obj.ref2dd6cc22 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DescriptorSetAllocateInfo) PassRef() (*C.VkDescriptorSetAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2dd6cc22 != nil {
		return x.ref2dd6cc22, nil
	}
	mem2dd6cc22 := allocDescriptorSetAllocateInfoMemory(1)
	ref2dd6cc22 := (*C.VkDescriptorSetAllocateInfo)(mem2dd6cc22)
	allocs2dd6cc22 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref2dd6cc22.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2dd6cc22.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cpNext_allocs)

	var cdescriptorPool_allocs *cgoAllocMap
	ref2dd6cc22.descriptorPool, cdescriptorPool_allocs = *(*C.VkDescriptorPool)(unsafe.Pointer(&x.DescriptorPool)), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cdescriptorPool_allocs)

	var cdescriptorSetCount_allocs *cgoAllocMap
	ref2dd6cc22.descriptorSetCount, cdescriptorSetCount_allocs = (C.uint32_t)(x.DescriptorSetCount), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cdescriptorSetCount_allocs)

	var cpSetLayouts_allocs *cgoAllocMap
	ref2dd6cc22.pSetLayouts, cpSetLayouts_allocs = (*C.VkDescriptorSetLayout)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSetLayouts)).Data)), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cpSetLayouts_allocs)

	x.ref2dd6cc22 = ref2dd6cc22
	x.allocs2dd6cc22 = allocs2dd6cc22
	return ref2dd6cc22, allocs2dd6cc22

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DescriptorSetAllocateInfo) PassValue() (C.VkDescriptorSetAllocateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewDescriptorSetAllocateInfoRef(nil)
	} else if x.ref2dd6cc22 != nil {
		return *x.ref2dd6cc22, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DescriptorSetAllocateInfo) Deref() {
	if x.ref2dd6cc22 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2dd6cc22.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2dd6cc22.pNext))
	x.DescriptorPool = *(*DescriptorPool)(unsafe.Pointer(&x.ref2dd6cc22.descriptorPool))
	x.DescriptorSetCount = (uint32)(x.ref2dd6cc22.descriptorSetCount)
	hxf058b18 := (*sliceHeader)(unsafe.Pointer(&x.PSetLayouts))
	hxf058b18.Data = uintptr(unsafe.Pointer(x.ref2dd6cc22.pSetLayouts))
	hxf058b18.Cap = 0x7fffffff
	// hxf058b18.Len = ?

}

// allocDescriptorImageInfoMemory allocates memory for type C.VkDescriptorImageInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorImageInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorImageInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorImageInfoValue = unsafe.Sizeof([1]C.VkDescriptorImageInfo{})

// Ref returns a reference.
func (x *DescriptorImageInfo) Ref() *C.VkDescriptorImageInfo {
	if x == nil {
		return nil
	}
	return x.refaf073b07
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DescriptorImageInfo) Free() {
	if x != nil && x.allocsaf073b07 != nil {
		x.allocsaf073b07.(*cgoAllocMap).Free()
		x.refaf073b07 = nil
	}
}

// NewDescriptorImageInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDescriptorImageInfoRef(ref *C.VkDescriptorImageInfo) *DescriptorImageInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorImageInfo)
	obj.refaf073b07 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DescriptorImageInfo) PassRef() (*C.VkDescriptorImageInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaf073b07 != nil {
		return x.refaf073b07, nil
	}
	memaf073b07 := allocDescriptorImageInfoMemory(1)
	refaf073b07 := (*C.VkDescriptorImageInfo)(memaf073b07)
	allocsaf073b07 := new(cgoAllocMap)
	var csampler_allocs *cgoAllocMap
	refaf073b07.sampler, csampler_allocs = *(*C.VkSampler)(unsafe.Pointer(&x.Sampler)), cgoAllocsUnknown
	allocsaf073b07.Borrow(csampler_allocs)

	var cimageView_allocs *cgoAllocMap
	refaf073b07.imageView, cimageView_allocs = *(*C.VkImageView)(unsafe.Pointer(&x.ImageView)), cgoAllocsUnknown
	allocsaf073b07.Borrow(cimageView_allocs)

	var cimageLayout_allocs *cgoAllocMap
	refaf073b07.imageLayout, cimageLayout_allocs = (C.VkImageLayout)(x.ImageLayout), cgoAllocsUnknown
	allocsaf073b07.Borrow(cimageLayout_allocs)

	x.refaf073b07 = refaf073b07
	x.allocsaf073b07 = allocsaf073b07
	return refaf073b07, allocsaf073b07

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DescriptorImageInfo) PassValue() (C.VkDescriptorImageInfo, *cgoAllocMap) {
	if x == nil {
		x = NewDescriptorImageInfoRef(nil)
	} else if x.refaf073b07 != nil {
		return *x.refaf073b07, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DescriptorImageInfo) Deref() {
	if x.refaf073b07 == nil {
		return
	}
	x.Sampler = *(*Sampler)(unsafe.Pointer(&x.refaf073b07.sampler))
	x.ImageView = *(*ImageView)(unsafe.Pointer(&x.refaf073b07.imageView))
	x.ImageLayout = (ImageLayout)(x.refaf073b07.imageLayout)
}

// allocDescriptorBufferInfoMemory allocates memory for type C.VkDescriptorBufferInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorBufferInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorBufferInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorBufferInfoValue = unsafe.Sizeof([1]C.VkDescriptorBufferInfo{})

// Ref returns a reference.
func (x *DescriptorBufferInfo) Ref() *C.VkDescriptorBufferInfo {
	if x == nil {
		return nil
	}
	return x.refe64bec0e
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DescriptorBufferInfo) Free() {
	if x != nil && x.allocse64bec0e != nil {
		x.allocse64bec0e.(*cgoAllocMap).Free()
		x.refe64bec0e = nil
	}
}

// NewDescriptorBufferInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDescriptorBufferInfoRef(ref *C.VkDescriptorBufferInfo) *DescriptorBufferInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorBufferInfo)
	obj.refe64bec0e = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DescriptorBufferInfo) PassRef() (*C.VkDescriptorBufferInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe64bec0e != nil {
		return x.refe64bec0e, nil
	}
	meme64bec0e := allocDescriptorBufferInfoMemory(1)
	refe64bec0e := (*C.VkDescriptorBufferInfo)(meme64bec0e)
	allocse64bec0e := new(cgoAllocMap)
	var cbuffer_allocs *cgoAllocMap
	refe64bec0e.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocse64bec0e.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	refe64bec0e.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocse64bec0e.Borrow(coffset_allocs)

	var c_range_allocs *cgoAllocMap
	refe64bec0e._range, c_range_allocs = (C.VkDeviceSize)(x._range), cgoAllocsUnknown
	allocse64bec0e.Borrow(c_range_allocs)

	x.refe64bec0e = refe64bec0e
	x.allocse64bec0e = allocse64bec0e
	return refe64bec0e, allocse64bec0e

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DescriptorBufferInfo) PassValue() (C.VkDescriptorBufferInfo, *cgoAllocMap) {
	if x == nil {
		x = NewDescriptorBufferInfoRef(nil)
	} else if x.refe64bec0e != nil {
		return *x.refe64bec0e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DescriptorBufferInfo) Deref() {
	if x.refe64bec0e == nil {
		return
	}
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refe64bec0e.buffer))
	x.Offset = (DeviceSize)(x.refe64bec0e.offset)
	x._range = (DeviceSize)(x.refe64bec0e._range)
}

// allocWriteDescriptorSetMemory allocates memory for type C.VkWriteDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWriteDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWriteDescriptorSetValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfWriteDescriptorSetValue = unsafe.Sizeof([1]C.VkWriteDescriptorSet{})

// unpackSDescriptorImageInfo transforms a sliced Go data structure into plain C format.
func unpackSDescriptorImageInfo(x []DescriptorImageInfo) (unpacked *C.VkDescriptorImageInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorImageInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorImageInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorImageInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorImageInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSDescriptorBufferInfo transforms a sliced Go data structure into plain C format.
func unpackSDescriptorBufferInfo(x []DescriptorBufferInfo) (unpacked *C.VkDescriptorBufferInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorBufferInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorBufferInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorBufferInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorBufferInfo)(unsafe.Pointer(h.Data))
	return
}

// packSDescriptorImageInfo reads sliced Go data structure out from plain C format.
func packSDescriptorImageInfo(v []DescriptorImageInfo, ptr0 *C.VkDescriptorImageInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorImageInfoValue]C.VkDescriptorImageInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorImageInfoRef(&ptr1)
	}
}

// packSDescriptorBufferInfo reads sliced Go data structure out from plain C format.
func packSDescriptorBufferInfo(v []DescriptorBufferInfo, ptr0 *C.VkDescriptorBufferInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorBufferInfoValue]C.VkDescriptorBufferInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorBufferInfoRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *WriteDescriptorSet) Ref() *C.VkWriteDescriptorSet {
	if x == nil {
		return nil
	}
	return x.ref3cec3f3f
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *WriteDescriptorSet) Free() {
	if x != nil && x.allocs3cec3f3f != nil {
		x.allocs3cec3f3f.(*cgoAllocMap).Free()
		x.ref3cec3f3f = nil
	}
}

// NewWriteDescriptorSetRef initialises a new struct holding the reference to the originaitng C struct.
func NewWriteDescriptorSetRef(ref *C.VkWriteDescriptorSet) *WriteDescriptorSet {
	if ref == nil {
		return nil
	}
	obj := new(WriteDescriptorSet)
	obj.ref3cec3f3f = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *WriteDescriptorSet) PassRef() (*C.VkWriteDescriptorSet, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3cec3f3f != nil {
		return x.ref3cec3f3f, nil
	}
	mem3cec3f3f := allocWriteDescriptorSetMemory(1)
	ref3cec3f3f := (*C.VkWriteDescriptorSet)(mem3cec3f3f)
	allocs3cec3f3f := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref3cec3f3f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3cec3f3f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cpNext_allocs)

	var cdstSet_allocs *cgoAllocMap
	ref3cec3f3f.dstSet, cdstSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.DstSet)), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdstSet_allocs)

	var cdstBinding_allocs *cgoAllocMap
	ref3cec3f3f.dstBinding, cdstBinding_allocs = (C.uint32_t)(x.DstBinding), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdstBinding_allocs)

	var cdstArrayElement_allocs *cgoAllocMap
	ref3cec3f3f.dstArrayElement, cdstArrayElement_allocs = (C.uint32_t)(x.DstArrayElement), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdstArrayElement_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	ref3cec3f3f.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdescriptorCount_allocs)

	var cdescriptorType_allocs *cgoAllocMap
	ref3cec3f3f.descriptorType, cdescriptorType_allocs = (C.VkDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdescriptorType_allocs)

	var cpImageInfo_allocs *cgoAllocMap
	ref3cec3f3f.pImageInfo, cpImageInfo_allocs = unpackSDescriptorImageInfo(x.PImageInfo)
	allocs3cec3f3f.Borrow(cpImageInfo_allocs)

	var cpBufferInfo_allocs *cgoAllocMap
	ref3cec3f3f.pBufferInfo, cpBufferInfo_allocs = unpackSDescriptorBufferInfo(x.PBufferInfo)
	allocs3cec3f3f.Borrow(cpBufferInfo_allocs)

	var cpTexelBufferView_allocs *cgoAllocMap
	ref3cec3f3f.pTexelBufferView, cpTexelBufferView_allocs = (*C.VkBufferView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PTexelBufferView)).Data)), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cpTexelBufferView_allocs)

	x.ref3cec3f3f = ref3cec3f3f
	x.allocs3cec3f3f = allocs3cec3f3f
	return ref3cec3f3f, allocs3cec3f3f

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *WriteDescriptorSet) PassValue() (C.VkWriteDescriptorSet, *cgoAllocMap) {
	if x == nil {
		x = NewWriteDescriptorSetRef(nil)
	} else if x.ref3cec3f3f != nil {
		return *x.ref3cec3f3f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *WriteDescriptorSet) Deref() {
	if x.ref3cec3f3f == nil {
		return
	}
	x.SType = (StructureType)(x.ref3cec3f3f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3cec3f3f.pNext))
	x.DstSet = *(*DescriptorSet)(unsafe.Pointer(&x.ref3cec3f3f.dstSet))
	x.DstBinding = (uint32)(x.ref3cec3f3f.dstBinding)
	x.DstArrayElement = (uint32)(x.ref3cec3f3f.dstArrayElement)
	x.DescriptorCount = (uint32)(x.ref3cec3f3f.descriptorCount)
	x.DescriptorType = (DescriptorType)(x.ref3cec3f3f.descriptorType)
	packSDescriptorImageInfo(x.PImageInfo, x.ref3cec3f3f.pImageInfo)
	packSDescriptorBufferInfo(x.PBufferInfo, x.ref3cec3f3f.pBufferInfo)
	hxff6bc57 := (*sliceHeader)(unsafe.Pointer(&x.PTexelBufferView))
	hxff6bc57.Data = uintptr(unsafe.Pointer(x.ref3cec3f3f.pTexelBufferView))
	hxff6bc57.Cap = 0x7fffffff
	// hxff6bc57.Len = ?

}

// allocCopyDescriptorSetMemory allocates memory for type C.VkCopyDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyDescriptorSetValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCopyDescriptorSetValue = unsafe.Sizeof([1]C.VkCopyDescriptorSet{})

// Ref returns a reference.
func (x *CopyDescriptorSet) Ref() *C.VkCopyDescriptorSet {
	if x == nil {
		return nil
	}
	return x.reffe237a3a
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *CopyDescriptorSet) Free() {
	if x != nil && x.allocsfe237a3a != nil {
		x.allocsfe237a3a.(*cgoAllocMap).Free()
		x.reffe237a3a = nil
	}
}

// NewCopyDescriptorSetRef initialises a new struct holding the reference to the originaitng C struct.
func NewCopyDescriptorSetRef(ref *C.VkCopyDescriptorSet) *CopyDescriptorSet {
	if ref == nil {
		return nil
	}
	obj := new(CopyDescriptorSet)
	obj.reffe237a3a = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *CopyDescriptorSet) PassRef() (*C.VkCopyDescriptorSet, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe237a3a != nil {
		return x.reffe237a3a, nil
	}
	memfe237a3a := allocCopyDescriptorSetMemory(1)
	reffe237a3a := (*C.VkCopyDescriptorSet)(memfe237a3a)
	allocsfe237a3a := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	reffe237a3a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe237a3a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cpNext_allocs)

	var csrcSet_allocs *cgoAllocMap
	reffe237a3a.srcSet, csrcSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.SrcSet)), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csrcSet_allocs)

	var csrcBinding_allocs *cgoAllocMap
	reffe237a3a.srcBinding, csrcBinding_allocs = (C.uint32_t)(x.SrcBinding), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csrcBinding_allocs)

	var csrcArrayElement_allocs *cgoAllocMap
	reffe237a3a.srcArrayElement, csrcArrayElement_allocs = (C.uint32_t)(x.SrcArrayElement), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csrcArrayElement_allocs)

	var cdstSet_allocs *cgoAllocMap
	reffe237a3a.dstSet, cdstSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.DstSet)), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdstSet_allocs)

	var cdstBinding_allocs *cgoAllocMap
	reffe237a3a.dstBinding, cdstBinding_allocs = (C.uint32_t)(x.DstBinding), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdstBinding_allocs)

	var cdstArrayElement_allocs *cgoAllocMap
	reffe237a3a.dstArrayElement, cdstArrayElement_allocs = (C.uint32_t)(x.DstArrayElement), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdstArrayElement_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	reffe237a3a.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdescriptorCount_allocs)

	x.reffe237a3a = reffe237a3a
	x.allocsfe237a3a = allocsfe237a3a
	return reffe237a3a, allocsfe237a3a

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *CopyDescriptorSet) PassValue() (C.VkCopyDescriptorSet, *cgoAllocMap) {
	if x == nil {
		x = NewCopyDescriptorSetRef(nil)
	} else if x.reffe237a3a != nil {
		return *x.reffe237a3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *CopyDescriptorSet) Deref() {
	if x.reffe237a3a == nil {
		return
	}
	x.SType = (StructureType)(x.reffe237a3a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe237a3a.pNext))
	x.SrcSet = *(*DescriptorSet)(unsafe.Pointer(&x.reffe237a3a.srcSet))
	x.SrcBinding = (uint32)(x.reffe237a3a.srcBinding)
	x.SrcArrayElement = (uint32)(x.reffe237a3a.srcArrayElement)
	x.DstSet = *(*DescriptorSet)(unsafe.Pointer(&x.reffe237a3a.dstSet))
	x.DstBinding = (uint32)(x.reffe237a3a.dstBinding)
	x.DstArrayElement = (uint32)(x.reffe237a3a.dstArrayElement)
	x.DescriptorCount = (uint32)(x.reffe237a3a.descriptorCount)
}

// allocFramebufferCreateInfoMemory allocates memory for type C.VkFramebufferCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFramebufferCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFramebufferCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFramebufferCreateInfoValue = unsafe.Sizeof([1]C.VkFramebufferCreateInfo{})

// Ref returns a reference.
func (x *FramebufferCreateInfo) Ref() *C.VkFramebufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.refa3ad85cc
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *FramebufferCreateInfo) Free() {
	if x != nil && x.allocsa3ad85cc != nil {
		x.allocsa3ad85cc.(*cgoAllocMap).Free()
		x.refa3ad85cc = nil
	}
}

// NewFramebufferCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewFramebufferCreateInfoRef(ref *C.VkFramebufferCreateInfo) *FramebufferCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(FramebufferCreateInfo)
	obj.refa3ad85cc = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *FramebufferCreateInfo) PassRef() (*C.VkFramebufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa3ad85cc != nil {
		return x.refa3ad85cc, nil
	}
	mema3ad85cc := allocFramebufferCreateInfoMemory(1)
	refa3ad85cc := (*C.VkFramebufferCreateInfo)(mema3ad85cc)
	allocsa3ad85cc := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refa3ad85cc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa3ad85cc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refa3ad85cc.flags, cflags_allocs = (C.VkFramebufferCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cflags_allocs)

	var crenderPass_allocs *cgoAllocMap
	refa3ad85cc.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(crenderPass_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	refa3ad85cc.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	refa3ad85cc.pAttachments, cpAttachments_allocs = (*C.VkImageView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PAttachments)).Data)), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cpAttachments_allocs)

	var cwidth_allocs *cgoAllocMap
	refa3ad85cc.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refa3ad85cc.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cheight_allocs)

	var clayers_allocs *cgoAllocMap
	refa3ad85cc.layers, clayers_allocs = (C.uint32_t)(x.Layers), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(clayers_allocs)

	x.refa3ad85cc = refa3ad85cc
	x.allocsa3ad85cc = allocsa3ad85cc
	return refa3ad85cc, allocsa3ad85cc

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *FramebufferCreateInfo) PassValue() (C.VkFramebufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewFramebufferCreateInfoRef(nil)
	} else if x.refa3ad85cc != nil {
		return *x.refa3ad85cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *FramebufferCreateInfo) Deref() {
	if x.refa3ad85cc == nil {
		return
	}
	x.SType = (StructureType)(x.refa3ad85cc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa3ad85cc.pNext))
	x.Flags = (FramebufferCreateFlags)(x.refa3ad85cc.flags)
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.refa3ad85cc.renderPass))
	x.AttachmentCount = (uint32)(x.refa3ad85cc.attachmentCount)
	hxf5fa529 := (*sliceHeader)(unsafe.Pointer(&x.PAttachments))
	hxf5fa529.Data = uintptr(unsafe.Pointer(x.refa3ad85cc.pAttachments))
	hxf5fa529.Cap = 0x7fffffff
	// hxf5fa529.Len = ?

	x.Width = (uint32)(x.refa3ad85cc.width)
	x.Height = (uint32)(x.refa3ad85cc.height)
	x.Layers = (uint32)(x.refa3ad85cc.layers)
}

// allocAttachmentDescriptionMemory allocates memory for type C.VkAttachmentDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAttachmentDescriptionValue = unsafe.Sizeof([1]C.VkAttachmentDescription{})

// Ref returns a reference.
func (x *AttachmentDescription) Ref() *C.VkAttachmentDescription {
	if x == nil {
		return nil
	}
	return x.refa5d685fc
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *AttachmentDescription) Free() {
	if x != nil && x.allocsa5d685fc != nil {
		x.allocsa5d685fc.(*cgoAllocMap).Free()
		x.refa5d685fc = nil
	}
}

// NewAttachmentDescriptionRef initialises a new struct holding the reference to the originaitng C struct.
func NewAttachmentDescriptionRef(ref *C.VkAttachmentDescription) *AttachmentDescription {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentDescription)
	obj.refa5d685fc = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *AttachmentDescription) PassRef() (*C.VkAttachmentDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5d685fc != nil {
		return x.refa5d685fc, nil
	}
	mema5d685fc := allocAttachmentDescriptionMemory(1)
	refa5d685fc := (*C.VkAttachmentDescription)(mema5d685fc)
	allocsa5d685fc := new(cgoAllocMap)
	var cflags_allocs *cgoAllocMap
	refa5d685fc.flags, cflags_allocs = (C.VkAttachmentDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cflags_allocs)

	var cformat_allocs *cgoAllocMap
	refa5d685fc.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cformat_allocs)

	var csamples_allocs *cgoAllocMap
	refa5d685fc.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocsa5d685fc.Borrow(csamples_allocs)

	var cloadOp_allocs *cgoAllocMap
	refa5d685fc.loadOp, cloadOp_allocs = (C.VkAttachmentLoadOp)(x.LoadOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cloadOp_allocs)

	var cstoreOp_allocs *cgoAllocMap
	refa5d685fc.storeOp, cstoreOp_allocs = (C.VkAttachmentStoreOp)(x.StoreOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cstoreOp_allocs)

	var cstencilLoadOp_allocs *cgoAllocMap
	refa5d685fc.stencilLoadOp, cstencilLoadOp_allocs = (C.VkAttachmentLoadOp)(x.StencilLoadOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cstencilLoadOp_allocs)

	var cstencilStoreOp_allocs *cgoAllocMap
	refa5d685fc.stencilStoreOp, cstencilStoreOp_allocs = (C.VkAttachmentStoreOp)(x.StencilStoreOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cstencilStoreOp_allocs)

	var cinitialLayout_allocs *cgoAllocMap
	refa5d685fc.initialLayout, cinitialLayout_allocs = (C.VkImageLayout)(x.InitialLayout), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cinitialLayout_allocs)

	var cfinalLayout_allocs *cgoAllocMap
	refa5d685fc.finalLayout, cfinalLayout_allocs = (C.VkImageLayout)(x.FinalLayout), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cfinalLayout_allocs)

	x.refa5d685fc = refa5d685fc
	x.allocsa5d685fc = allocsa5d685fc
	return refa5d685fc, allocsa5d685fc

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *AttachmentDescription) PassValue() (C.VkAttachmentDescription, *cgoAllocMap) {
	if x == nil {
		x = NewAttachmentDescriptionRef(nil)
	} else if x.refa5d685fc != nil {
		return *x.refa5d685fc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *AttachmentDescription) Deref() {
	if x.refa5d685fc == nil {
		return
	}
	x.Flags = (AttachmentDescriptionFlags)(x.refa5d685fc.flags)
	x.Format = (Format)(x.refa5d685fc.format)
	x.Samples = (SampleCountFlagBits)(x.refa5d685fc.samples)
	x.LoadOp = (AttachmentLoadOp)(x.refa5d685fc.loadOp)
	x.StoreOp = (AttachmentStoreOp)(x.refa5d685fc.storeOp)
	x.StencilLoadOp = (AttachmentLoadOp)(x.refa5d685fc.stencilLoadOp)
	x.StencilStoreOp = (AttachmentStoreOp)(x.refa5d685fc.stencilStoreOp)
	x.InitialLayout = (ImageLayout)(x.refa5d685fc.initialLayout)
	x.FinalLayout = (ImageLayout)(x.refa5d685fc.finalLayout)
}

// allocAttachmentReferenceMemory allocates memory for type C.VkAttachmentReference in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentReferenceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentReferenceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAttachmentReferenceValue = unsafe.Sizeof([1]C.VkAttachmentReference{})

// Ref returns a reference.
func (x *AttachmentReference) Ref() *C.VkAttachmentReference {
	if x == nil {
		return nil
	}
	return x.refef4776de
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *AttachmentReference) Free() {
	if x != nil && x.allocsef4776de != nil {
		x.allocsef4776de.(*cgoAllocMap).Free()
		x.refef4776de = nil
	}
}

// NewAttachmentReferenceRef initialises a new struct holding the reference to the originaitng C struct.
func NewAttachmentReferenceRef(ref *C.VkAttachmentReference) *AttachmentReference {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentReference)
	obj.refef4776de = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *AttachmentReference) PassRef() (*C.VkAttachmentReference, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refef4776de != nil {
		return x.refef4776de, nil
	}
	memef4776de := allocAttachmentReferenceMemory(1)
	refef4776de := (*C.VkAttachmentReference)(memef4776de)
	allocsef4776de := new(cgoAllocMap)
	var cattachment_allocs *cgoAllocMap
	refef4776de.attachment, cattachment_allocs = (C.uint32_t)(x.Attachment), cgoAllocsUnknown
	allocsef4776de.Borrow(cattachment_allocs)

	var clayout_allocs *cgoAllocMap
	refef4776de.layout, clayout_allocs = (C.VkImageLayout)(x.Layout), cgoAllocsUnknown
	allocsef4776de.Borrow(clayout_allocs)

	x.refef4776de = refef4776de
	x.allocsef4776de = allocsef4776de
	return refef4776de, allocsef4776de

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *AttachmentReference) PassValue() (C.VkAttachmentReference, *cgoAllocMap) {
	if x == nil {
		x = NewAttachmentReferenceRef(nil)
	} else if x.refef4776de != nil {
		return *x.refef4776de, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *AttachmentReference) Deref() {
	if x.refef4776de == nil {
		return
	}
	x.Attachment = (uint32)(x.refef4776de.attachment)
	x.Layout = (ImageLayout)(x.refef4776de.layout)
}

// allocSubpassDescriptionMemory allocates memory for type C.VkSubpassDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassDescriptionValue = unsafe.Sizeof([1]C.VkSubpassDescription{})

// unpackSAttachmentReference transforms a sliced Go data structure into plain C format.
func unpackSAttachmentReference(x []AttachmentReference) (unpacked *C.VkAttachmentReference, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAttachmentReference) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentReferenceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentReference)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentReference)(unsafe.Pointer(h.Data))
	return
}

// packSAttachmentReference reads sliced Go data structure out from plain C format.
func packSAttachmentReference(v []AttachmentReference, ptr0 *C.VkAttachmentReference) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentReferenceValue]C.VkAttachmentReference)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentReferenceRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *SubpassDescription) Ref() *C.VkSubpassDescription {
	if x == nil {
		return nil
	}
	return x.refc7bfeda
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SubpassDescription) Free() {
	if x != nil && x.allocsc7bfeda != nil {
		x.allocsc7bfeda.(*cgoAllocMap).Free()
		x.refc7bfeda = nil
	}
}

// NewSubpassDescriptionRef initialises a new struct holding the reference to the originaitng C struct.
func NewSubpassDescriptionRef(ref *C.VkSubpassDescription) *SubpassDescription {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDescription)
	obj.refc7bfeda = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SubpassDescription) PassRef() (*C.VkSubpassDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc7bfeda != nil {
		return x.refc7bfeda, nil
	}
	memc7bfeda := allocSubpassDescriptionMemory(1)
	refc7bfeda := (*C.VkSubpassDescription)(memc7bfeda)
	allocsc7bfeda := new(cgoAllocMap)
	var cflags_allocs *cgoAllocMap
	refc7bfeda.flags, cflags_allocs = (C.VkSubpassDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cflags_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	refc7bfeda.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cpipelineBindPoint_allocs)

	var cinputAttachmentCount_allocs *cgoAllocMap
	refc7bfeda.inputAttachmentCount, cinputAttachmentCount_allocs = (C.uint32_t)(x.InputAttachmentCount), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cinputAttachmentCount_allocs)

	var cpInputAttachments_allocs *cgoAllocMap
	refc7bfeda.pInputAttachments, cpInputAttachments_allocs = unpackSAttachmentReference(x.PInputAttachments)
	allocsc7bfeda.Borrow(cpInputAttachments_allocs)

	var ccolorAttachmentCount_allocs *cgoAllocMap
	refc7bfeda.colorAttachmentCount, ccolorAttachmentCount_allocs = (C.uint32_t)(x.ColorAttachmentCount), cgoAllocsUnknown
	allocsc7bfeda.Borrow(ccolorAttachmentCount_allocs)

	var cpColorAttachments_allocs *cgoAllocMap
	refc7bfeda.pColorAttachments, cpColorAttachments_allocs = unpackSAttachmentReference(x.PColorAttachments)
	allocsc7bfeda.Borrow(cpColorAttachments_allocs)

	var cpResolveAttachments_allocs *cgoAllocMap
	refc7bfeda.pResolveAttachments, cpResolveAttachments_allocs = unpackSAttachmentReference(x.PResolveAttachments)
	allocsc7bfeda.Borrow(cpResolveAttachments_allocs)

	var cpDepthStencilAttachment_allocs *cgoAllocMap
	refc7bfeda.pDepthStencilAttachment, cpDepthStencilAttachment_allocs = unpackSAttachmentReference(x.PDepthStencilAttachment)
	allocsc7bfeda.Borrow(cpDepthStencilAttachment_allocs)

	var cpreserveAttachmentCount_allocs *cgoAllocMap
	refc7bfeda.preserveAttachmentCount, cpreserveAttachmentCount_allocs = (C.uint32_t)(x.PreserveAttachmentCount), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cpreserveAttachmentCount_allocs)

	var cpPreserveAttachments_allocs *cgoAllocMap
	refc7bfeda.pPreserveAttachments, cpPreserveAttachments_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments)).Data)), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cpPreserveAttachments_allocs)

	x.refc7bfeda = refc7bfeda
	x.allocsc7bfeda = allocsc7bfeda
	return refc7bfeda, allocsc7bfeda

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SubpassDescription) PassValue() (C.VkSubpassDescription, *cgoAllocMap) {
	if x == nil {
		x = NewSubpassDescriptionRef(nil)
	} else if x.refc7bfeda != nil {
		return *x.refc7bfeda, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SubpassDescription) Deref() {
	if x.refc7bfeda == nil {
		return
	}
	x.Flags = (SubpassDescriptionFlags)(x.refc7bfeda.flags)
	x.PipelineBindPoint = (PipelineBindPoint)(x.refc7bfeda.pipelineBindPoint)
	x.InputAttachmentCount = (uint32)(x.refc7bfeda.inputAttachmentCount)
	packSAttachmentReference(x.PInputAttachments, x.refc7bfeda.pInputAttachments)
	x.ColorAttachmentCount = (uint32)(x.refc7bfeda.colorAttachmentCount)
	packSAttachmentReference(x.PColorAttachments, x.refc7bfeda.pColorAttachments)
	packSAttachmentReference(x.PResolveAttachments, x.refc7bfeda.pResolveAttachments)
	packSAttachmentReference(x.PDepthStencilAttachment, x.refc7bfeda.pDepthStencilAttachment)
	x.PreserveAttachmentCount = (uint32)(x.refc7bfeda.preserveAttachmentCount)
	hxf21690b := (*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments))
	hxf21690b.Data = uintptr(unsafe.Pointer(x.refc7bfeda.pPreserveAttachments))
	hxf21690b.Cap = 0x7fffffff
	// hxf21690b.Len = ?

}

// allocSubpassDependencyMemory allocates memory for type C.VkSubpassDependency in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDependencyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDependencyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassDependencyValue = unsafe.Sizeof([1]C.VkSubpassDependency{})

// Ref returns a reference.
func (x *SubpassDependency) Ref() *C.VkSubpassDependency {
	if x == nil {
		return nil
	}
	return x.refdb197adb
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SubpassDependency) Free() {
	if x != nil && x.allocsdb197adb != nil {
		x.allocsdb197adb.(*cgoAllocMap).Free()
		x.refdb197adb = nil
	}
}

// NewSubpassDependencyRef initialises a new struct holding the reference to the originaitng C struct.
func NewSubpassDependencyRef(ref *C.VkSubpassDependency) *SubpassDependency {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDependency)
	obj.refdb197adb = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SubpassDependency) PassRef() (*C.VkSubpassDependency, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb197adb != nil {
		return x.refdb197adb, nil
	}
	memdb197adb := allocSubpassDependencyMemory(1)
	refdb197adb := (*C.VkSubpassDependency)(memdb197adb)
	allocsdb197adb := new(cgoAllocMap)
	var csrcSubpass_allocs *cgoAllocMap
	refdb197adb.srcSubpass, csrcSubpass_allocs = (C.uint32_t)(x.SrcSubpass), cgoAllocsUnknown
	allocsdb197adb.Borrow(csrcSubpass_allocs)

	var cdstSubpass_allocs *cgoAllocMap
	refdb197adb.dstSubpass, cdstSubpass_allocs = (C.uint32_t)(x.DstSubpass), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdstSubpass_allocs)

	var csrcStageMask_allocs *cgoAllocMap
	refdb197adb.srcStageMask, csrcStageMask_allocs = (C.VkPipelineStageFlags)(x.SrcStageMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(csrcStageMask_allocs)

	var cdstStageMask_allocs *cgoAllocMap
	refdb197adb.dstStageMask, cdstStageMask_allocs = (C.VkPipelineStageFlags)(x.DstStageMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdstStageMask_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refdb197adb.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refdb197adb.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdstAccessMask_allocs)

	var cdependencyFlags_allocs *cgoAllocMap
	refdb197adb.dependencyFlags, cdependencyFlags_allocs = (C.VkDependencyFlags)(x.DependencyFlags), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdependencyFlags_allocs)

	x.refdb197adb = refdb197adb
	x.allocsdb197adb = allocsdb197adb
	return refdb197adb, allocsdb197adb

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SubpassDependency) PassValue() (C.VkSubpassDependency, *cgoAllocMap) {
	if x == nil {
		x = NewSubpassDependencyRef(nil)
	} else if x.refdb197adb != nil {
		return *x.refdb197adb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SubpassDependency) Deref() {
	if x.refdb197adb == nil {
		return
	}
	x.SrcSubpass = (uint32)(x.refdb197adb.srcSubpass)
	x.DstSubpass = (uint32)(x.refdb197adb.dstSubpass)
	x.SrcStageMask = (PipelineStageFlags)(x.refdb197adb.srcStageMask)
	x.DstStageMask = (PipelineStageFlags)(x.refdb197adb.dstStageMask)
	x.SrcAccessMask = (AccessFlags)(x.refdb197adb.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refdb197adb.dstAccessMask)
	x.DependencyFlags = (DependencyFlags)(x.refdb197adb.dependencyFlags)
}

// allocRenderPassCreateInfoMemory allocates memory for type C.VkRenderPassCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassCreateInfoValue = unsafe.Sizeof([1]C.VkRenderPassCreateInfo{})

// unpackSAttachmentDescription transforms a sliced Go data structure into plain C format.
func unpackSAttachmentDescription(x []AttachmentDescription) (unpacked *C.VkAttachmentDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAttachmentDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentDescription)(unsafe.Pointer(h.Data))
	return
}

// unpackSSubpassDescription transforms a sliced Go data structure into plain C format.
func unpackSSubpassDescription(x []SubpassDescription) (unpacked *C.VkSubpassDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDescription)(unsafe.Pointer(h.Data))
	return
}

// unpackSSubpassDependency transforms a sliced Go data structure into plain C format.
func unpackSSubpassDependency(x []SubpassDependency) (unpacked *C.VkSubpassDependency, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassDependency) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDependencyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDependency)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDependency)(unsafe.Pointer(h.Data))
	return
}

// packSAttachmentDescription reads sliced Go data structure out from plain C format.
func packSAttachmentDescription(v []AttachmentDescription, ptr0 *C.VkAttachmentDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentDescriptionValue]C.VkAttachmentDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentDescriptionRef(&ptr1)
	}
}

// packSSubpassDescription reads sliced Go data structure out from plain C format.
func packSSubpassDescription(v []SubpassDescription, ptr0 *C.VkSubpassDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDescriptionValue]C.VkSubpassDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDescriptionRef(&ptr1)
	}
}

// packSSubpassDependency reads sliced Go data structure out from plain C format.
func packSSubpassDependency(v []SubpassDependency, ptr0 *C.VkSubpassDependency) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDependencyValue]C.VkSubpassDependency)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDependencyRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *RenderPassCreateInfo) Ref() *C.VkRenderPassCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref886d7d86
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *RenderPassCreateInfo) Free() {
	if x != nil && x.allocs886d7d86 != nil {
		x.allocs886d7d86.(*cgoAllocMap).Free()
		x.ref886d7d86 = nil
	}
}

// NewRenderPassCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewRenderPassCreateInfoRef(ref *C.VkRenderPassCreateInfo) *RenderPassCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassCreateInfo)
	obj.ref886d7d86 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *RenderPassCreateInfo) PassRef() (*C.VkRenderPassCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref886d7d86 != nil {
		return x.ref886d7d86, nil
	}
	mem886d7d86 := allocRenderPassCreateInfoMemory(1)
	ref886d7d86 := (*C.VkRenderPassCreateInfo)(mem886d7d86)
	allocs886d7d86 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref886d7d86.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs886d7d86.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref886d7d86.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs886d7d86.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref886d7d86.flags, cflags_allocs = (C.VkRenderPassCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs886d7d86.Borrow(cflags_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	ref886d7d86.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocs886d7d86.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	ref886d7d86.pAttachments, cpAttachments_allocs = unpackSAttachmentDescription(x.PAttachments)
	allocs886d7d86.Borrow(cpAttachments_allocs)

	var csubpassCount_allocs *cgoAllocMap
	ref886d7d86.subpassCount, csubpassCount_allocs = (C.uint32_t)(x.SubpassCount), cgoAllocsUnknown
	allocs886d7d86.Borrow(csubpassCount_allocs)

	var cpSubpasses_allocs *cgoAllocMap
	ref886d7d86.pSubpasses, cpSubpasses_allocs = unpackSSubpassDescription(x.PSubpasses)
	allocs886d7d86.Borrow(cpSubpasses_allocs)

	var cdependencyCount_allocs *cgoAllocMap
	ref886d7d86.dependencyCount, cdependencyCount_allocs = (C.uint32_t)(x.DependencyCount), cgoAllocsUnknown
	allocs886d7d86.Borrow(cdependencyCount_allocs)

	var cpDependencies_allocs *cgoAllocMap
	ref886d7d86.pDependencies, cpDependencies_allocs = unpackSSubpassDependency(x.PDependencies)
	allocs886d7d86.Borrow(cpDependencies_allocs)

	x.ref886d7d86 = ref886d7d86
	x.allocs886d7d86 = allocs886d7d86
	return ref886d7d86, allocs886d7d86

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *RenderPassCreateInfo) PassValue() (C.VkRenderPassCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewRenderPassCreateInfoRef(nil)
	} else if x.ref886d7d86 != nil {
		return *x.ref886d7d86, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *RenderPassCreateInfo) Deref() {
	if x.ref886d7d86 == nil {
		return
	}
	x.SType = (StructureType)(x.ref886d7d86.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref886d7d86.pNext))
	x.Flags = (RenderPassCreateFlags)(x.ref886d7d86.flags)
	x.AttachmentCount = (uint32)(x.ref886d7d86.attachmentCount)
	packSAttachmentDescription(x.PAttachments, x.ref886d7d86.pAttachments)
	x.SubpassCount = (uint32)(x.ref886d7d86.subpassCount)
	packSSubpassDescription(x.PSubpasses, x.ref886d7d86.pSubpasses)
	x.DependencyCount = (uint32)(x.ref886d7d86.dependencyCount)
	packSSubpassDependency(x.PDependencies, x.ref886d7d86.pDependencies)
}

// allocCommandPoolCreateInfoMemory allocates memory for type C.VkCommandPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandPoolCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandPoolCreateInfoValue = unsafe.Sizeof([1]C.VkCommandPoolCreateInfo{})

// Ref returns a reference.
func (x *CommandPoolCreateInfo) Ref() *C.VkCommandPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref73550de0
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *CommandPoolCreateInfo) Free() {
	if x != nil && x.allocs73550de0 != nil {
		x.allocs73550de0.(*cgoAllocMap).Free()
		x.ref73550de0 = nil
	}
}

// NewCommandPoolCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewCommandPoolCreateInfoRef(ref *C.VkCommandPoolCreateInfo) *CommandPoolCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandPoolCreateInfo)
	obj.ref73550de0 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *CommandPoolCreateInfo) PassRef() (*C.VkCommandPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref73550de0 != nil {
		return x.ref73550de0, nil
	}
	mem73550de0 := allocCommandPoolCreateInfoMemory(1)
	ref73550de0 := (*C.VkCommandPoolCreateInfo)(mem73550de0)
	allocs73550de0 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref73550de0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs73550de0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref73550de0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs73550de0.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref73550de0.flags, cflags_allocs = (C.VkCommandPoolCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs73550de0.Borrow(cflags_allocs)

	var cqueueFamilyIndex_allocs *cgoAllocMap
	ref73550de0.queueFamilyIndex, cqueueFamilyIndex_allocs = (C.uint32_t)(x.QueueFamilyIndex), cgoAllocsUnknown
	allocs73550de0.Borrow(cqueueFamilyIndex_allocs)

	x.ref73550de0 = ref73550de0
	x.allocs73550de0 = allocs73550de0
	return ref73550de0, allocs73550de0

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *CommandPoolCreateInfo) PassValue() (C.VkCommandPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewCommandPoolCreateInfoRef(nil)
	} else if x.ref73550de0 != nil {
		return *x.ref73550de0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *CommandPoolCreateInfo) Deref() {
	if x.ref73550de0 == nil {
		return
	}
	x.SType = (StructureType)(x.ref73550de0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref73550de0.pNext))
	x.Flags = (CommandPoolCreateFlags)(x.ref73550de0.flags)
	x.QueueFamilyIndex = (uint32)(x.ref73550de0.queueFamilyIndex)
}

// allocCommandBufferAllocateInfoMemory allocates memory for type C.VkCommandBufferAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandBufferAllocateInfoValue = unsafe.Sizeof([1]C.VkCommandBufferAllocateInfo{})

// Ref returns a reference.
func (x *CommandBufferAllocateInfo) Ref() *C.VkCommandBufferAllocateInfo {
	if x == nil {
		return nil
	}
	return x.refd1a0a7c8
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *CommandBufferAllocateInfo) Free() {
	if x != nil && x.allocsd1a0a7c8 != nil {
		x.allocsd1a0a7c8.(*cgoAllocMap).Free()
		x.refd1a0a7c8 = nil
	}
}

// NewCommandBufferAllocateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewCommandBufferAllocateInfoRef(ref *C.VkCommandBufferAllocateInfo) *CommandBufferAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferAllocateInfo)
	obj.refd1a0a7c8 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *CommandBufferAllocateInfo) PassRef() (*C.VkCommandBufferAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd1a0a7c8 != nil {
		return x.refd1a0a7c8, nil
	}
	memd1a0a7c8 := allocCommandBufferAllocateInfoMemory(1)
	refd1a0a7c8 := (*C.VkCommandBufferAllocateInfo)(memd1a0a7c8)
	allocsd1a0a7c8 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refd1a0a7c8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd1a0a7c8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(cpNext_allocs)

	var ccommandPool_allocs *cgoAllocMap
	refd1a0a7c8.commandPool, ccommandPool_allocs = *(*C.VkCommandPool)(unsafe.Pointer(&x.CommandPool)), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(ccommandPool_allocs)

	var clevel_allocs *cgoAllocMap
	refd1a0a7c8.level, clevel_allocs = (C.VkCommandBufferLevel)(x.Level), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(clevel_allocs)

	var ccommandBufferCount_allocs *cgoAllocMap
	refd1a0a7c8.commandBufferCount, ccommandBufferCount_allocs = (C.uint32_t)(x.CommandBufferCount), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(ccommandBufferCount_allocs)

	x.refd1a0a7c8 = refd1a0a7c8
	x.allocsd1a0a7c8 = allocsd1a0a7c8
	return refd1a0a7c8, allocsd1a0a7c8

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *CommandBufferAllocateInfo) PassValue() (C.VkCommandBufferAllocateInfo, *cgoAllocMap) {
	if x == nil {
		x = NewCommandBufferAllocateInfoRef(nil)
	} else if x.refd1a0a7c8 != nil {
		return *x.refd1a0a7c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *CommandBufferAllocateInfo) Deref() {
	if x.refd1a0a7c8 == nil {
		return
	}
	x.SType = (StructureType)(x.refd1a0a7c8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd1a0a7c8.pNext))
	x.CommandPool = *(*CommandPool)(unsafe.Pointer(&x.refd1a0a7c8.commandPool))
	x.Level = (CommandBufferLevel)(x.refd1a0a7c8.level)
	x.CommandBufferCount = (uint32)(x.refd1a0a7c8.commandBufferCount)
}

// allocCommandBufferInheritanceInfoMemory allocates memory for type C.VkCommandBufferInheritanceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferInheritanceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferInheritanceInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandBufferInheritanceInfoValue = unsafe.Sizeof([1]C.VkCommandBufferInheritanceInfo{})

// Ref returns a reference.
func (x *CommandBufferInheritanceInfo) Ref() *C.VkCommandBufferInheritanceInfo {
	if x == nil {
		return nil
	}
	return x.ref737f8019
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *CommandBufferInheritanceInfo) Free() {
	if x != nil && x.allocs737f8019 != nil {
		x.allocs737f8019.(*cgoAllocMap).Free()
		x.ref737f8019 = nil
	}
}

// NewCommandBufferInheritanceInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewCommandBufferInheritanceInfoRef(ref *C.VkCommandBufferInheritanceInfo) *CommandBufferInheritanceInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferInheritanceInfo)
	obj.ref737f8019 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *CommandBufferInheritanceInfo) PassRef() (*C.VkCommandBufferInheritanceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref737f8019 != nil {
		return x.ref737f8019, nil
	}
	mem737f8019 := allocCommandBufferInheritanceInfoMemory(1)
	ref737f8019 := (*C.VkCommandBufferInheritanceInfo)(mem737f8019)
	allocs737f8019 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref737f8019.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs737f8019.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref737f8019.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs737f8019.Borrow(cpNext_allocs)

	var crenderPass_allocs *cgoAllocMap
	ref737f8019.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocs737f8019.Borrow(crenderPass_allocs)

	var csubpass_allocs *cgoAllocMap
	ref737f8019.subpass, csubpass_allocs = (C.uint32_t)(x.Subpass), cgoAllocsUnknown
	allocs737f8019.Borrow(csubpass_allocs)

	var cframebuffer_allocs *cgoAllocMap
	ref737f8019.framebuffer, cframebuffer_allocs = *(*C.VkFramebuffer)(unsafe.Pointer(&x.Framebuffer)), cgoAllocsUnknown
	allocs737f8019.Borrow(cframebuffer_allocs)

	var cocclusionQueryEnable_allocs *cgoAllocMap
	ref737f8019.occlusionQueryEnable, cocclusionQueryEnable_allocs = (C.VkBool32)(x.OcclusionQueryEnable), cgoAllocsUnknown
	allocs737f8019.Borrow(cocclusionQueryEnable_allocs)

	var cqueryFlags_allocs *cgoAllocMap
	ref737f8019.queryFlags, cqueryFlags_allocs = (C.VkQueryControlFlags)(x.QueryFlags), cgoAllocsUnknown
	allocs737f8019.Borrow(cqueryFlags_allocs)

	var cpipelineStatistics_allocs *cgoAllocMap
	ref737f8019.pipelineStatistics, cpipelineStatistics_allocs = (C.VkQueryPipelineStatisticFlags)(x.PipelineStatistics), cgoAllocsUnknown
	allocs737f8019.Borrow(cpipelineStatistics_allocs)

	x.ref737f8019 = ref737f8019
	x.allocs737f8019 = allocs737f8019
	return ref737f8019, allocs737f8019

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *CommandBufferInheritanceInfo) PassValue() (C.VkCommandBufferInheritanceInfo, *cgoAllocMap) {
	if x == nil {
		x = NewCommandBufferInheritanceInfoRef(nil)
	} else if x.ref737f8019 != nil {
		return *x.ref737f8019, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *CommandBufferInheritanceInfo) Deref() {
	if x.ref737f8019 == nil {
		return
	}
	x.SType = (StructureType)(x.ref737f8019.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref737f8019.pNext))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref737f8019.renderPass))
	x.Subpass = (uint32)(x.ref737f8019.subpass)
	x.Framebuffer = *(*Framebuffer)(unsafe.Pointer(&x.ref737f8019.framebuffer))
	x.OcclusionQueryEnable = (Bool32)(x.ref737f8019.occlusionQueryEnable)
	x.QueryFlags = (QueryControlFlags)(x.ref737f8019.queryFlags)
	x.PipelineStatistics = (QueryPipelineStatisticFlags)(x.ref737f8019.pipelineStatistics)
}

// allocCommandBufferBeginInfoMemory allocates memory for type C.VkCommandBufferBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferBeginInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandBufferBeginInfoValue = unsafe.Sizeof([1]C.VkCommandBufferBeginInfo{})

// unpackSCommandBufferInheritanceInfo transforms a sliced Go data structure into plain C format.
func unpackSCommandBufferInheritanceInfo(x []CommandBufferInheritanceInfo) (unpacked *C.VkCommandBufferInheritanceInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkCommandBufferInheritanceInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCommandBufferInheritanceInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(h.Data))
	return
}

// packSCommandBufferInheritanceInfo reads sliced Go data structure out from plain C format.
func packSCommandBufferInheritanceInfo(v []CommandBufferInheritanceInfo, ptr0 *C.VkCommandBufferInheritanceInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCommandBufferInheritanceInfoValue]C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandBufferInheritanceInfoRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *CommandBufferBeginInfo) Ref() *C.VkCommandBufferBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref266762df
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *CommandBufferBeginInfo) Free() {
	if x != nil && x.allocs266762df != nil {
		x.allocs266762df.(*cgoAllocMap).Free()
		x.ref266762df = nil
	}
}

// NewCommandBufferBeginInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewCommandBufferBeginInfoRef(ref *C.VkCommandBufferBeginInfo) *CommandBufferBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferBeginInfo)
	obj.ref266762df = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *CommandBufferBeginInfo) PassRef() (*C.VkCommandBufferBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref266762df != nil {
		return x.ref266762df, nil
	}
	mem266762df := allocCommandBufferBeginInfoMemory(1)
	ref266762df := (*C.VkCommandBufferBeginInfo)(mem266762df)
	allocs266762df := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref266762df.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs266762df.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref266762df.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs266762df.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref266762df.flags, cflags_allocs = (C.VkCommandBufferUsageFlags)(x.Flags), cgoAllocsUnknown
	allocs266762df.Borrow(cflags_allocs)

	var cpInheritanceInfo_allocs *cgoAllocMap
	ref266762df.pInheritanceInfo, cpInheritanceInfo_allocs = unpackSCommandBufferInheritanceInfo(x.PInheritanceInfo)
	allocs266762df.Borrow(cpInheritanceInfo_allocs)

	x.ref266762df = ref266762df
	x.allocs266762df = allocs266762df
	return ref266762df, allocs266762df

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *CommandBufferBeginInfo) PassValue() (C.VkCommandBufferBeginInfo, *cgoAllocMap) {
	if x == nil {
		x = NewCommandBufferBeginInfoRef(nil)
	} else if x.ref266762df != nil {
		return *x.ref266762df, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *CommandBufferBeginInfo) Deref() {
	if x.ref266762df == nil {
		return
	}
	x.SType = (StructureType)(x.ref266762df.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref266762df.pNext))
	x.Flags = (CommandBufferUsageFlags)(x.ref266762df.flags)
	packSCommandBufferInheritanceInfo(x.PInheritanceInfo, x.ref266762df.pInheritanceInfo)
}

// allocBufferCopyMemory allocates memory for type C.VkBufferCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferCopyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferCopyValue = unsafe.Sizeof([1]C.VkBufferCopy{})

// Ref returns a reference.
func (x *BufferCopy) Ref() *C.VkBufferCopy {
	if x == nil {
		return nil
	}
	return x.ref12184ffd
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *BufferCopy) Free() {
	if x != nil && x.allocs12184ffd != nil {
		x.allocs12184ffd.(*cgoAllocMap).Free()
		x.ref12184ffd = nil
	}
}

// NewBufferCopyRef initialises a new struct holding the reference to the originaitng C struct.
func NewBufferCopyRef(ref *C.VkBufferCopy) *BufferCopy {
	if ref == nil {
		return nil
	}
	obj := new(BufferCopy)
	obj.ref12184ffd = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *BufferCopy) PassRef() (*C.VkBufferCopy, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref12184ffd != nil {
		return x.ref12184ffd, nil
	}
	mem12184ffd := allocBufferCopyMemory(1)
	ref12184ffd := (*C.VkBufferCopy)(mem12184ffd)
	allocs12184ffd := new(cgoAllocMap)
	var csrcOffset_allocs *cgoAllocMap
	ref12184ffd.srcOffset, csrcOffset_allocs = (C.VkDeviceSize)(x.SrcOffset), cgoAllocsUnknown
	allocs12184ffd.Borrow(csrcOffset_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref12184ffd.dstOffset, cdstOffset_allocs = (C.VkDeviceSize)(x.DstOffset), cgoAllocsUnknown
	allocs12184ffd.Borrow(cdstOffset_allocs)

	var csize_allocs *cgoAllocMap
	ref12184ffd.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs12184ffd.Borrow(csize_allocs)

	x.ref12184ffd = ref12184ffd
	x.allocs12184ffd = allocs12184ffd
	return ref12184ffd, allocs12184ffd

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *BufferCopy) PassValue() (C.VkBufferCopy, *cgoAllocMap) {
	if x == nil {
		x = NewBufferCopyRef(nil)
	} else if x.ref12184ffd != nil {
		return *x.ref12184ffd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *BufferCopy) Deref() {
	if x.ref12184ffd == nil {
		return
	}
	x.SrcOffset = (DeviceSize)(x.ref12184ffd.srcOffset)
	x.DstOffset = (DeviceSize)(x.ref12184ffd.dstOffset)
	x.Size = (DeviceSize)(x.ref12184ffd.size)
}

// allocImageSubresourceLayersMemory allocates memory for type C.VkImageSubresourceLayers in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceLayersMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceLayersValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSubresourceLayersValue = unsafe.Sizeof([1]C.VkImageSubresourceLayers{})

// Ref returns a reference.
func (x *ImageSubresourceLayers) Ref() *C.VkImageSubresourceLayers {
	if x == nil {
		return nil
	}
	return x.ref3b13bcd2
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageSubresourceLayers) Free() {
	if x != nil && x.allocs3b13bcd2 != nil {
		x.allocs3b13bcd2.(*cgoAllocMap).Free()
		x.ref3b13bcd2 = nil
	}
}

// NewImageSubresourceLayersRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageSubresourceLayersRef(ref *C.VkImageSubresourceLayers) *ImageSubresourceLayers {
	if ref == nil {
		return nil
	}
	obj := new(ImageSubresourceLayers)
	obj.ref3b13bcd2 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageSubresourceLayers) PassRef() (*C.VkImageSubresourceLayers, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3b13bcd2 != nil {
		return x.ref3b13bcd2, nil
	}
	mem3b13bcd2 := allocImageSubresourceLayersMemory(1)
	ref3b13bcd2 := (*C.VkImageSubresourceLayers)(mem3b13bcd2)
	allocs3b13bcd2 := new(cgoAllocMap)
	var caspectMask_allocs *cgoAllocMap
	ref3b13bcd2.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(caspectMask_allocs)

	var cmipLevel_allocs *cgoAllocMap
	ref3b13bcd2.mipLevel, cmipLevel_allocs = (C.uint32_t)(x.MipLevel), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(cmipLevel_allocs)

	var cbaseArrayLayer_allocs *cgoAllocMap
	ref3b13bcd2.baseArrayLayer, cbaseArrayLayer_allocs = (C.uint32_t)(x.BaseArrayLayer), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(cbaseArrayLayer_allocs)

	var clayerCount_allocs *cgoAllocMap
	ref3b13bcd2.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(clayerCount_allocs)

	x.ref3b13bcd2 = ref3b13bcd2
	x.allocs3b13bcd2 = allocs3b13bcd2
	return ref3b13bcd2, allocs3b13bcd2

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ImageSubresourceLayers) PassValue() (C.VkImageSubresourceLayers, *cgoAllocMap) {
	if x == nil {
		x = NewImageSubresourceLayersRef(nil)
	} else if x.ref3b13bcd2 != nil {
		return *x.ref3b13bcd2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageSubresourceLayers) Deref() {
	if x.ref3b13bcd2 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.ref3b13bcd2.aspectMask)
	x.MipLevel = (uint32)(x.ref3b13bcd2.mipLevel)
	x.BaseArrayLayer = (uint32)(x.ref3b13bcd2.baseArrayLayer)
	x.LayerCount = (uint32)(x.ref3b13bcd2.layerCount)
}

// allocImageCopyMemory allocates memory for type C.VkImageCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCopyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageCopyValue = unsafe.Sizeof([1]C.VkImageCopy{})

// Ref returns a reference.
func (x *ImageCopy) Ref() *C.VkImageCopy {
	if x == nil {
		return nil
	}
	return x.ref4e7a1214
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageCopy) Free() {
	if x != nil && x.allocs4e7a1214 != nil {
		x.allocs4e7a1214.(*cgoAllocMap).Free()
		x.ref4e7a1214 = nil
	}
}

// NewImageCopyRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageCopyRef(ref *C.VkImageCopy) *ImageCopy {
	if ref == nil {
		return nil
	}
	obj := new(ImageCopy)
	obj.ref4e7a1214 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageCopy) PassRef() (*C.VkImageCopy, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4e7a1214 != nil {
		return x.ref4e7a1214, nil
	}
	mem4e7a1214 := allocImageCopyMemory(1)
	ref4e7a1214 := (*C.VkImageCopy)(mem4e7a1214)
	allocs4e7a1214 := new(cgoAllocMap)
	var csrcSubresource_allocs *cgoAllocMap
	ref4e7a1214.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs4e7a1214.Borrow(csrcSubresource_allocs)

	var csrcOffset_allocs *cgoAllocMap
	ref4e7a1214.srcOffset, csrcOffset_allocs = x.SrcOffset.PassValue()
	allocs4e7a1214.Borrow(csrcOffset_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref4e7a1214.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs4e7a1214.Borrow(cdstSubresource_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref4e7a1214.dstOffset, cdstOffset_allocs = x.DstOffset.PassValue()
	allocs4e7a1214.Borrow(cdstOffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref4e7a1214.extent, cextent_allocs = x.Extent.PassValue()
	allocs4e7a1214.Borrow(cextent_allocs)

	x.ref4e7a1214 = ref4e7a1214
	x.allocs4e7a1214 = allocs4e7a1214
	return ref4e7a1214, allocs4e7a1214

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ImageCopy) PassValue() (C.VkImageCopy, *cgoAllocMap) {
	if x == nil {
		x = NewImageCopyRef(nil)
	} else if x.ref4e7a1214 != nil {
		return *x.ref4e7a1214, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageCopy) Deref() {
	if x.ref4e7a1214 == nil {
		return
	}
	x.SrcSubresource = *NewImageSubresourceLayersRef(&x.ref4e7a1214.srcSubresource)
	x.SrcOffset = *NewOffset3DRef(&x.ref4e7a1214.srcOffset)
	x.DstSubresource = *NewImageSubresourceLayersRef(&x.ref4e7a1214.dstSubresource)
	x.DstOffset = *NewOffset3DRef(&x.ref4e7a1214.dstOffset)
	x.Extent = *NewExtent3DRef(&x.ref4e7a1214.extent)
}

// allocImageBlitMemory allocates memory for type C.VkImageBlit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageBlitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageBlitValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageBlitValue = unsafe.Sizeof([1]C.VkImageBlit{})

// allocA2Offset3DMemory allocates memory for type [2]C.VkOffset3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA2Offset3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA2Offset3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA2Offset3DValue = unsafe.Sizeof([1][2]C.VkOffset3D{})

// unpackA2Offset3D transforms a sliced Go data structure into plain C format.
func unpackA2Offset3D(x [2]Offset3D) (unpacked [2]C.VkOffset3D, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**[50][93]C.VkOffset3D) {
		go allocs.Free()
	})

	mem0 := allocA2Offset3DMemory(1)
	allocs.Add(mem0)
	v0 := (*[2]C.VkOffset3D)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[2]C.VkOffset3D)(mem0)
	return
}

// packA2Offset3D reads sliced Go data structure out from plain C format.
func packA2Offset3D(v *[2]Offset3D, ptr0 *[2]C.VkOffset3D) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewOffset3DRef(&ptr1)
	}
}

// Ref returns a reference.
func (x *ImageBlit) Ref() *C.VkImageBlit {
	if x == nil {
		return nil
	}
	return x.ref11311e8d
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageBlit) Free() {
	if x != nil && x.allocs11311e8d != nil {
		x.allocs11311e8d.(*cgoAllocMap).Free()
		x.ref11311e8d = nil
	}
}

// NewImageBlitRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageBlitRef(ref *C.VkImageBlit) *ImageBlit {
	if ref == nil {
		return nil
	}
	obj := new(ImageBlit)
	obj.ref11311e8d = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageBlit) PassRef() (*C.VkImageBlit, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11311e8d != nil {
		return x.ref11311e8d, nil
	}
	mem11311e8d := allocImageBlitMemory(1)
	ref11311e8d := (*C.VkImageBlit)(mem11311e8d)
	allocs11311e8d := new(cgoAllocMap)
	var csrcSubresource_allocs *cgoAllocMap
	ref11311e8d.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs11311e8d.Borrow(csrcSubresource_allocs)

	var csrcOffsets_allocs *cgoAllocMap
	ref11311e8d.srcOffsets, csrcOffsets_allocs = unpackA2Offset3D(x.SrcOffsets)
	allocs11311e8d.Borrow(csrcOffsets_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref11311e8d.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs11311e8d.Borrow(cdstSubresource_allocs)

	var cdstOffsets_allocs *cgoAllocMap
	ref11311e8d.dstOffsets, cdstOffsets_allocs = unpackA2Offset3D(x.DstOffsets)
	allocs11311e8d.Borrow(cdstOffsets_allocs)

	x.ref11311e8d = ref11311e8d
	x.allocs11311e8d = allocs11311e8d
	return ref11311e8d, allocs11311e8d

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ImageBlit) PassValue() (C.VkImageBlit, *cgoAllocMap) {
	if x == nil {
		x = NewImageBlitRef(nil)
	} else if x.ref11311e8d != nil {
		return *x.ref11311e8d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageBlit) Deref() {
	if x.ref11311e8d == nil {
		return
	}
	x.SrcSubresource = *NewImageSubresourceLayersRef(&x.ref11311e8d.srcSubresource)
	packA2Offset3D(&x.SrcOffsets, (*[2]C.VkOffset3D)(unsafe.Pointer(&x.ref11311e8d.srcOffsets)))
	x.DstSubresource = *NewImageSubresourceLayersRef(&x.ref11311e8d.dstSubresource)
	packA2Offset3D(&x.DstOffsets, (*[2]C.VkOffset3D)(unsafe.Pointer(&x.ref11311e8d.dstOffsets)))
}

// allocBufferImageCopyMemory allocates memory for type C.VkBufferImageCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferImageCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferImageCopyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferImageCopyValue = unsafe.Sizeof([1]C.VkBufferImageCopy{})

// Ref returns a reference.
func (x *BufferImageCopy) Ref() *C.VkBufferImageCopy {
	if x == nil {
		return nil
	}
	return x.ref6d50e36e
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *BufferImageCopy) Free() {
	if x != nil && x.allocs6d50e36e != nil {
		x.allocs6d50e36e.(*cgoAllocMap).Free()
		x.ref6d50e36e = nil
	}
}

// NewBufferImageCopyRef initialises a new struct holding the reference to the originaitng C struct.
func NewBufferImageCopyRef(ref *C.VkBufferImageCopy) *BufferImageCopy {
	if ref == nil {
		return nil
	}
	obj := new(BufferImageCopy)
	obj.ref6d50e36e = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *BufferImageCopy) PassRef() (*C.VkBufferImageCopy, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6d50e36e != nil {
		return x.ref6d50e36e, nil
	}
	mem6d50e36e := allocBufferImageCopyMemory(1)
	ref6d50e36e := (*C.VkBufferImageCopy)(mem6d50e36e)
	allocs6d50e36e := new(cgoAllocMap)
	var cbufferOffset_allocs *cgoAllocMap
	ref6d50e36e.bufferOffset, cbufferOffset_allocs = (C.VkDeviceSize)(x.BufferOffset), cgoAllocsUnknown
	allocs6d50e36e.Borrow(cbufferOffset_allocs)

	var cbufferRowLength_allocs *cgoAllocMap
	ref6d50e36e.bufferRowLength, cbufferRowLength_allocs = (C.uint32_t)(x.BufferRowLength), cgoAllocsUnknown
	allocs6d50e36e.Borrow(cbufferRowLength_allocs)

	var cbufferImageHeight_allocs *cgoAllocMap
	ref6d50e36e.bufferImageHeight, cbufferImageHeight_allocs = (C.uint32_t)(x.BufferImageHeight), cgoAllocsUnknown
	allocs6d50e36e.Borrow(cbufferImageHeight_allocs)

	var cimageSubresource_allocs *cgoAllocMap
	ref6d50e36e.imageSubresource, cimageSubresource_allocs = x.ImageSubresource.PassValue()
	allocs6d50e36e.Borrow(cimageSubresource_allocs)

	var cimageOffset_allocs *cgoAllocMap
	ref6d50e36e.imageOffset, cimageOffset_allocs = x.ImageOffset.PassValue()
	allocs6d50e36e.Borrow(cimageOffset_allocs)

	var cimageExtent_allocs *cgoAllocMap
	ref6d50e36e.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocs6d50e36e.Borrow(cimageExtent_allocs)

	x.ref6d50e36e = ref6d50e36e
	x.allocs6d50e36e = allocs6d50e36e
	return ref6d50e36e, allocs6d50e36e

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *BufferImageCopy) PassValue() (C.VkBufferImageCopy, *cgoAllocMap) {
	if x == nil {
		x = NewBufferImageCopyRef(nil)
	} else if x.ref6d50e36e != nil {
		return *x.ref6d50e36e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *BufferImageCopy) Deref() {
	if x.ref6d50e36e == nil {
		return
	}
	x.BufferOffset = (DeviceSize)(x.ref6d50e36e.bufferOffset)
	x.BufferRowLength = (uint32)(x.ref6d50e36e.bufferRowLength)
	x.BufferImageHeight = (uint32)(x.ref6d50e36e.bufferImageHeight)
	x.ImageSubresource = *NewImageSubresourceLayersRef(&x.ref6d50e36e.imageSubresource)
	x.ImageOffset = *NewOffset3DRef(&x.ref6d50e36e.imageOffset)
	x.ImageExtent = *NewExtent3DRef(&x.ref6d50e36e.imageExtent)
}

// allocClearDepthStencilValueMemory allocates memory for type C.VkClearDepthStencilValue in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearDepthStencilValueMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearDepthStencilValueValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfClearDepthStencilValueValue = unsafe.Sizeof([1]C.VkClearDepthStencilValue{})

// Ref returns a reference.
func (x *ClearDepthStencilValue) Ref() *C.VkClearDepthStencilValue {
	if x == nil {
		return nil
	}
	return x.refa7d07c03
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ClearDepthStencilValue) Free() {
	if x != nil && x.allocsa7d07c03 != nil {
		x.allocsa7d07c03.(*cgoAllocMap).Free()
		x.refa7d07c03 = nil
	}
}

// NewClearDepthStencilValueRef initialises a new struct holding the reference to the originaitng C struct.
func NewClearDepthStencilValueRef(ref *C.VkClearDepthStencilValue) *ClearDepthStencilValue {
	if ref == nil {
		return nil
	}
	obj := new(ClearDepthStencilValue)
	obj.refa7d07c03 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ClearDepthStencilValue) PassRef() (*C.VkClearDepthStencilValue, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa7d07c03 != nil {
		return x.refa7d07c03, nil
	}
	mema7d07c03 := allocClearDepthStencilValueMemory(1)
	refa7d07c03 := (*C.VkClearDepthStencilValue)(mema7d07c03)
	allocsa7d07c03 := new(cgoAllocMap)
	var cdepth_allocs *cgoAllocMap
	refa7d07c03.depth, cdepth_allocs = (C.float)(x.Depth), cgoAllocsUnknown
	allocsa7d07c03.Borrow(cdepth_allocs)

	var cstencil_allocs *cgoAllocMap
	refa7d07c03.stencil, cstencil_allocs = (C.uint32_t)(x.Stencil), cgoAllocsUnknown
	allocsa7d07c03.Borrow(cstencil_allocs)

	x.refa7d07c03 = refa7d07c03
	x.allocsa7d07c03 = allocsa7d07c03
	return refa7d07c03, allocsa7d07c03

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ClearDepthStencilValue) PassValue() (C.VkClearDepthStencilValue, *cgoAllocMap) {
	if x == nil {
		x = NewClearDepthStencilValueRef(nil)
	} else if x.refa7d07c03 != nil {
		return *x.refa7d07c03, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ClearDepthStencilValue) Deref() {
	if x.refa7d07c03 == nil {
		return
	}
	x.Depth = (float32)(x.refa7d07c03.depth)
	x.Stencil = (uint32)(x.refa7d07c03.stencil)
}

// allocClearAttachmentMemory allocates memory for type C.VkClearAttachment in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearAttachmentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearAttachmentValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfClearAttachmentValue = unsafe.Sizeof([1]C.VkClearAttachment{})

// Ref returns a reference.
func (x *ClearAttachment) Ref() *C.VkClearAttachment {
	if x == nil {
		return nil
	}
	return x.refe9150303
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ClearAttachment) Free() {
	if x != nil && x.allocse9150303 != nil {
		x.allocse9150303.(*cgoAllocMap).Free()
		x.refe9150303 = nil
	}
}

// NewClearAttachmentRef initialises a new struct holding the reference to the originaitng C struct.
func NewClearAttachmentRef(ref *C.VkClearAttachment) *ClearAttachment {
	if ref == nil {
		return nil
	}
	obj := new(ClearAttachment)
	obj.refe9150303 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ClearAttachment) PassRef() (*C.VkClearAttachment, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe9150303 != nil {
		return x.refe9150303, nil
	}
	meme9150303 := allocClearAttachmentMemory(1)
	refe9150303 := (*C.VkClearAttachment)(meme9150303)
	allocse9150303 := new(cgoAllocMap)
	var caspectMask_allocs *cgoAllocMap
	refe9150303.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocse9150303.Borrow(caspectMask_allocs)

	var ccolorAttachment_allocs *cgoAllocMap
	refe9150303.colorAttachment, ccolorAttachment_allocs = (C.uint32_t)(x.ColorAttachment), cgoAllocsUnknown
	allocse9150303.Borrow(ccolorAttachment_allocs)

	var cclearValue_allocs *cgoAllocMap
	refe9150303.clearValue, cclearValue_allocs = *(*C.VkClearValue)(unsafe.Pointer(&x.ClearValue)), cgoAllocsUnknown
	allocse9150303.Borrow(cclearValue_allocs)

	x.refe9150303 = refe9150303
	x.allocse9150303 = allocse9150303
	return refe9150303, allocse9150303

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ClearAttachment) PassValue() (C.VkClearAttachment, *cgoAllocMap) {
	if x == nil {
		x = NewClearAttachmentRef(nil)
	} else if x.refe9150303 != nil {
		return *x.refe9150303, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ClearAttachment) Deref() {
	if x.refe9150303 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.refe9150303.aspectMask)
	x.ColorAttachment = (uint32)(x.refe9150303.colorAttachment)
	x.ClearValue = *(*ClearValue)(unsafe.Pointer(&x.refe9150303.clearValue))
}

// allocClearRectMemory allocates memory for type C.VkClearRect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearRectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfClearRectValue = unsafe.Sizeof([1]C.VkClearRect{})

// Ref returns a reference.
func (x *ClearRect) Ref() *C.VkClearRect {
	if x == nil {
		return nil
	}
	return x.ref1d449c8b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ClearRect) Free() {
	if x != nil && x.allocs1d449c8b != nil {
		x.allocs1d449c8b.(*cgoAllocMap).Free()
		x.ref1d449c8b = nil
	}
}

// NewClearRectRef initialises a new struct holding the reference to the originaitng C struct.
func NewClearRectRef(ref *C.VkClearRect) *ClearRect {
	if ref == nil {
		return nil
	}
	obj := new(ClearRect)
	obj.ref1d449c8b = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ClearRect) PassRef() (*C.VkClearRect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d449c8b != nil {
		return x.ref1d449c8b, nil
	}
	mem1d449c8b := allocClearRectMemory(1)
	ref1d449c8b := (*C.VkClearRect)(mem1d449c8b)
	allocs1d449c8b := new(cgoAllocMap)
	var crect_allocs *cgoAllocMap
	ref1d449c8b.rect, crect_allocs = x.Rect.PassValue()
	allocs1d449c8b.Borrow(crect_allocs)

	var cbaseArrayLayer_allocs *cgoAllocMap
	ref1d449c8b.baseArrayLayer, cbaseArrayLayer_allocs = (C.uint32_t)(x.BaseArrayLayer), cgoAllocsUnknown
	allocs1d449c8b.Borrow(cbaseArrayLayer_allocs)

	var clayerCount_allocs *cgoAllocMap
	ref1d449c8b.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocs1d449c8b.Borrow(clayerCount_allocs)

	x.ref1d449c8b = ref1d449c8b
	x.allocs1d449c8b = allocs1d449c8b
	return ref1d449c8b, allocs1d449c8b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ClearRect) PassValue() (C.VkClearRect, *cgoAllocMap) {
	if x == nil {
		x = NewClearRectRef(nil)
	} else if x.ref1d449c8b != nil {
		return *x.ref1d449c8b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ClearRect) Deref() {
	if x.ref1d449c8b == nil {
		return
	}
	x.Rect = *NewRect2DRef(&x.ref1d449c8b.rect)
	x.BaseArrayLayer = (uint32)(x.ref1d449c8b.baseArrayLayer)
	x.LayerCount = (uint32)(x.ref1d449c8b.layerCount)
}

// allocImageResolveMemory allocates memory for type C.VkImageResolve in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageResolveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageResolveValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageResolveValue = unsafe.Sizeof([1]C.VkImageResolve{})

// Ref returns a reference.
func (x *ImageResolve) Ref() *C.VkImageResolve {
	if x == nil {
		return nil
	}
	return x.ref7bda856d
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageResolve) Free() {
	if x != nil && x.allocs7bda856d != nil {
		x.allocs7bda856d.(*cgoAllocMap).Free()
		x.ref7bda856d = nil
	}
}

// NewImageResolveRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageResolveRef(ref *C.VkImageResolve) *ImageResolve {
	if ref == nil {
		return nil
	}
	obj := new(ImageResolve)
	obj.ref7bda856d = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageResolve) PassRef() (*C.VkImageResolve, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7bda856d != nil {
		return x.ref7bda856d, nil
	}
	mem7bda856d := allocImageResolveMemory(1)
	ref7bda856d := (*C.VkImageResolve)(mem7bda856d)
	allocs7bda856d := new(cgoAllocMap)
	var csrcSubresource_allocs *cgoAllocMap
	ref7bda856d.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs7bda856d.Borrow(csrcSubresource_allocs)

	var csrcOffset_allocs *cgoAllocMap
	ref7bda856d.srcOffset, csrcOffset_allocs = x.SrcOffset.PassValue()
	allocs7bda856d.Borrow(csrcOffset_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref7bda856d.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs7bda856d.Borrow(cdstSubresource_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref7bda856d.dstOffset, cdstOffset_allocs = x.DstOffset.PassValue()
	allocs7bda856d.Borrow(cdstOffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref7bda856d.extent, cextent_allocs = x.Extent.PassValue()
	allocs7bda856d.Borrow(cextent_allocs)

	x.ref7bda856d = ref7bda856d
	x.allocs7bda856d = allocs7bda856d
	return ref7bda856d, allocs7bda856d

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ImageResolve) PassValue() (C.VkImageResolve, *cgoAllocMap) {
	if x == nil {
		x = NewImageResolveRef(nil)
	} else if x.ref7bda856d != nil {
		return *x.ref7bda856d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageResolve) Deref() {
	if x.ref7bda856d == nil {
		return
	}
	x.SrcSubresource = *NewImageSubresourceLayersRef(&x.ref7bda856d.srcSubresource)
	x.SrcOffset = *NewOffset3DRef(&x.ref7bda856d.srcOffset)
	x.DstSubresource = *NewImageSubresourceLayersRef(&x.ref7bda856d.dstSubresource)
	x.DstOffset = *NewOffset3DRef(&x.ref7bda856d.dstOffset)
	x.Extent = *NewExtent3DRef(&x.ref7bda856d.extent)
}

// allocMemoryBarrierMemory allocates memory for type C.VkMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryBarrierValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryBarrierValue = unsafe.Sizeof([1]C.VkMemoryBarrier{})

// Ref returns a reference.
func (x *MemoryBarrier) Ref() *C.VkMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.ref977c944e
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *MemoryBarrier) Free() {
	if x != nil && x.allocs977c944e != nil {
		x.allocs977c944e.(*cgoAllocMap).Free()
		x.ref977c944e = nil
	}
}

// NewMemoryBarrierRef initialises a new struct holding the reference to the originaitng C struct.
func NewMemoryBarrierRef(ref *C.VkMemoryBarrier) *MemoryBarrier {
	if ref == nil {
		return nil
	}
	obj := new(MemoryBarrier)
	obj.ref977c944e = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *MemoryBarrier) PassRef() (*C.VkMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref977c944e != nil {
		return x.ref977c944e, nil
	}
	mem977c944e := allocMemoryBarrierMemory(1)
	ref977c944e := (*C.VkMemoryBarrier)(mem977c944e)
	allocs977c944e := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref977c944e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs977c944e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref977c944e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs977c944e.Borrow(cpNext_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	ref977c944e.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocs977c944e.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	ref977c944e.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocs977c944e.Borrow(cdstAccessMask_allocs)

	x.ref977c944e = ref977c944e
	x.allocs977c944e = allocs977c944e
	return ref977c944e, allocs977c944e

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *MemoryBarrier) PassValue() (C.VkMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		x = NewMemoryBarrierRef(nil)
	} else if x.ref977c944e != nil {
		return *x.ref977c944e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *MemoryBarrier) Deref() {
	if x.ref977c944e == nil {
		return
	}
	x.SType = (StructureType)(x.ref977c944e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref977c944e.pNext))
	x.SrcAccessMask = (AccessFlags)(x.ref977c944e.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.ref977c944e.dstAccessMask)
}

// allocBufferMemoryBarrierMemory allocates memory for type C.VkBufferMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferMemoryBarrierValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferMemoryBarrierValue = unsafe.Sizeof([1]C.VkBufferMemoryBarrier{})

// Ref returns a reference.
func (x *BufferMemoryBarrier) Ref() *C.VkBufferMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.refeaf4700b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *BufferMemoryBarrier) Free() {
	if x != nil && x.allocseaf4700b != nil {
		x.allocseaf4700b.(*cgoAllocMap).Free()
		x.refeaf4700b = nil
	}
}

// NewBufferMemoryBarrierRef initialises a new struct holding the reference to the originaitng C struct.
func NewBufferMemoryBarrierRef(ref *C.VkBufferMemoryBarrier) *BufferMemoryBarrier {
	if ref == nil {
		return nil
	}
	obj := new(BufferMemoryBarrier)
	obj.refeaf4700b = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *BufferMemoryBarrier) PassRef() (*C.VkBufferMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeaf4700b != nil {
		return x.refeaf4700b, nil
	}
	memeaf4700b := allocBufferMemoryBarrierMemory(1)
	refeaf4700b := (*C.VkBufferMemoryBarrier)(memeaf4700b)
	allocseaf4700b := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refeaf4700b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseaf4700b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeaf4700b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseaf4700b.Borrow(cpNext_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refeaf4700b.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocseaf4700b.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refeaf4700b.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocseaf4700b.Borrow(cdstAccessMask_allocs)

	var csrcQueueFamilyIndex_allocs *cgoAllocMap
	refeaf4700b.srcQueueFamilyIndex, csrcQueueFamilyIndex_allocs = (C.uint32_t)(x.SrcQueueFamilyIndex), cgoAllocsUnknown
	allocseaf4700b.Borrow(csrcQueueFamilyIndex_allocs)

	var cdstQueueFamilyIndex_allocs *cgoAllocMap
	refeaf4700b.dstQueueFamilyIndex, cdstQueueFamilyIndex_allocs = (C.uint32_t)(x.DstQueueFamilyIndex), cgoAllocsUnknown
	allocseaf4700b.Borrow(cdstQueueFamilyIndex_allocs)

	var cbuffer_allocs *cgoAllocMap
	refeaf4700b.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocseaf4700b.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	refeaf4700b.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocseaf4700b.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	refeaf4700b.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocseaf4700b.Borrow(csize_allocs)

	x.refeaf4700b = refeaf4700b
	x.allocseaf4700b = allocseaf4700b
	return refeaf4700b, allocseaf4700b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *BufferMemoryBarrier) PassValue() (C.VkBufferMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		x = NewBufferMemoryBarrierRef(nil)
	} else if x.refeaf4700b != nil {
		return *x.refeaf4700b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *BufferMemoryBarrier) Deref() {
	if x.refeaf4700b == nil {
		return
	}
	x.SType = (StructureType)(x.refeaf4700b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeaf4700b.pNext))
	x.SrcAccessMask = (AccessFlags)(x.refeaf4700b.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refeaf4700b.dstAccessMask)
	x.SrcQueueFamilyIndex = (uint32)(x.refeaf4700b.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.refeaf4700b.dstQueueFamilyIndex)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refeaf4700b.buffer))
	x.Offset = (DeviceSize)(x.refeaf4700b.offset)
	x.Size = (DeviceSize)(x.refeaf4700b.size)
}

// allocImageMemoryBarrierMemory allocates memory for type C.VkImageMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageMemoryBarrierValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageMemoryBarrierValue = unsafe.Sizeof([1]C.VkImageMemoryBarrier{})

// Ref returns a reference.
func (x *ImageMemoryBarrier) Ref() *C.VkImageMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.refd52734ec
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageMemoryBarrier) Free() {
	if x != nil && x.allocsd52734ec != nil {
		x.allocsd52734ec.(*cgoAllocMap).Free()
		x.refd52734ec = nil
	}
}

// NewImageMemoryBarrierRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageMemoryBarrierRef(ref *C.VkImageMemoryBarrier) *ImageMemoryBarrier {
	if ref == nil {
		return nil
	}
	obj := new(ImageMemoryBarrier)
	obj.refd52734ec = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageMemoryBarrier) PassRef() (*C.VkImageMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd52734ec != nil {
		return x.refd52734ec, nil
	}
	memd52734ec := allocImageMemoryBarrierMemory(1)
	refd52734ec := (*C.VkImageMemoryBarrier)(memd52734ec)
	allocsd52734ec := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refd52734ec.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd52734ec.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd52734ec.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd52734ec.Borrow(cpNext_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refd52734ec.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocsd52734ec.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refd52734ec.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocsd52734ec.Borrow(cdstAccessMask_allocs)

	var coldLayout_allocs *cgoAllocMap
	refd52734ec.oldLayout, coldLayout_allocs = (C.VkImageLayout)(x.OldLayout), cgoAllocsUnknown
	allocsd52734ec.Borrow(coldLayout_allocs)

	var cnewLayout_allocs *cgoAllocMap
	refd52734ec.newLayout, cnewLayout_allocs = (C.VkImageLayout)(x.NewLayout), cgoAllocsUnknown
	allocsd52734ec.Borrow(cnewLayout_allocs)

	var csrcQueueFamilyIndex_allocs *cgoAllocMap
	refd52734ec.srcQueueFamilyIndex, csrcQueueFamilyIndex_allocs = (C.uint32_t)(x.SrcQueueFamilyIndex), cgoAllocsUnknown
	allocsd52734ec.Borrow(csrcQueueFamilyIndex_allocs)

	var cdstQueueFamilyIndex_allocs *cgoAllocMap
	refd52734ec.dstQueueFamilyIndex, cdstQueueFamilyIndex_allocs = (C.uint32_t)(x.DstQueueFamilyIndex), cgoAllocsUnknown
	allocsd52734ec.Borrow(cdstQueueFamilyIndex_allocs)

	var cimage_allocs *cgoAllocMap
	refd52734ec.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocsd52734ec.Borrow(cimage_allocs)

	var csubresourceRange_allocs *cgoAllocMap
	refd52734ec.subresourceRange, csubresourceRange_allocs = x.SubresourceRange.PassValue()
	allocsd52734ec.Borrow(csubresourceRange_allocs)

	x.refd52734ec = refd52734ec
	x.allocsd52734ec = allocsd52734ec
	return refd52734ec, allocsd52734ec

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ImageMemoryBarrier) PassValue() (C.VkImageMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		x = NewImageMemoryBarrierRef(nil)
	} else if x.refd52734ec != nil {
		return *x.refd52734ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageMemoryBarrier) Deref() {
	if x.refd52734ec == nil {
		return
	}
	x.SType = (StructureType)(x.refd52734ec.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd52734ec.pNext))
	x.SrcAccessMask = (AccessFlags)(x.refd52734ec.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refd52734ec.dstAccessMask)
	x.OldLayout = (ImageLayout)(x.refd52734ec.oldLayout)
	x.NewLayout = (ImageLayout)(x.refd52734ec.newLayout)
	x.SrcQueueFamilyIndex = (uint32)(x.refd52734ec.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.refd52734ec.dstQueueFamilyIndex)
	x.Image = *(*Image)(unsafe.Pointer(&x.refd52734ec.image))
	x.SubresourceRange = *NewImageSubresourceRangeRef(&x.refd52734ec.subresourceRange)
}

// allocRenderPassBeginInfoMemory allocates memory for type C.VkRenderPassBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassBeginInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassBeginInfoValue = unsafe.Sizeof([1]C.VkRenderPassBeginInfo{})

// Ref returns a reference.
func (x *RenderPassBeginInfo) Ref() *C.VkRenderPassBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref3c3752c8
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *RenderPassBeginInfo) Free() {
	if x != nil && x.allocs3c3752c8 != nil {
		x.allocs3c3752c8.(*cgoAllocMap).Free()
		x.ref3c3752c8 = nil
	}
}

// NewRenderPassBeginInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewRenderPassBeginInfoRef(ref *C.VkRenderPassBeginInfo) *RenderPassBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassBeginInfo)
	obj.ref3c3752c8 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *RenderPassBeginInfo) PassRef() (*C.VkRenderPassBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c3752c8 != nil {
		return x.ref3c3752c8, nil
	}
	mem3c3752c8 := allocRenderPassBeginInfoMemory(1)
	ref3c3752c8 := (*C.VkRenderPassBeginInfo)(mem3c3752c8)
	allocs3c3752c8 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref3c3752c8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3c3752c8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3c3752c8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cpNext_allocs)

	var crenderPass_allocs *cgoAllocMap
	ref3c3752c8.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(crenderPass_allocs)

	var cframebuffer_allocs *cgoAllocMap
	ref3c3752c8.framebuffer, cframebuffer_allocs = *(*C.VkFramebuffer)(unsafe.Pointer(&x.Framebuffer)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cframebuffer_allocs)

	var crenderArea_allocs *cgoAllocMap
	ref3c3752c8.renderArea, crenderArea_allocs = x.RenderArea.PassValue()
	allocs3c3752c8.Borrow(crenderArea_allocs)

	var cclearValueCount_allocs *cgoAllocMap
	ref3c3752c8.clearValueCount, cclearValueCount_allocs = (C.uint32_t)(x.ClearValueCount), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cclearValueCount_allocs)

	var cpClearValues_allocs *cgoAllocMap
	ref3c3752c8.pClearValues, cpClearValues_allocs = (*C.VkClearValue)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PClearValues)).Data)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cpClearValues_allocs)

	x.ref3c3752c8 = ref3c3752c8
	x.allocs3c3752c8 = allocs3c3752c8
	return ref3c3752c8, allocs3c3752c8

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *RenderPassBeginInfo) PassValue() (C.VkRenderPassBeginInfo, *cgoAllocMap) {
	if x == nil {
		x = NewRenderPassBeginInfoRef(nil)
	} else if x.ref3c3752c8 != nil {
		return *x.ref3c3752c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *RenderPassBeginInfo) Deref() {
	if x.ref3c3752c8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3c3752c8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3c3752c8.pNext))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref3c3752c8.renderPass))
	x.Framebuffer = *(*Framebuffer)(unsafe.Pointer(&x.ref3c3752c8.framebuffer))
	x.RenderArea = *NewRect2DRef(&x.ref3c3752c8.renderArea)
	x.ClearValueCount = (uint32)(x.ref3c3752c8.clearValueCount)
	hxf1231c9 := (*sliceHeader)(unsafe.Pointer(&x.PClearValues))
	hxf1231c9.Data = uintptr(unsafe.Pointer(x.ref3c3752c8.pClearValues))
	hxf1231c9.Cap = 0x7fffffff
	// hxf1231c9.Len = ?

}

// allocDispatchIndirectCommandMemory allocates memory for type C.VkDispatchIndirectCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDispatchIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDispatchIndirectCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDispatchIndirectCommandValue = unsafe.Sizeof([1]C.VkDispatchIndirectCommand{})

// Ref returns a reference.
func (x *DispatchIndirectCommand) Ref() *C.VkDispatchIndirectCommand {
	if x == nil {
		return nil
	}
	return x.refd298ba27
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DispatchIndirectCommand) Free() {
	if x != nil && x.allocsd298ba27 != nil {
		x.allocsd298ba27.(*cgoAllocMap).Free()
		x.refd298ba27 = nil
	}
}

// NewDispatchIndirectCommandRef initialises a new struct holding the reference to the originaitng C struct.
func NewDispatchIndirectCommandRef(ref *C.VkDispatchIndirectCommand) *DispatchIndirectCommand {
	if ref == nil {
		return nil
	}
	obj := new(DispatchIndirectCommand)
	obj.refd298ba27 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DispatchIndirectCommand) PassRef() (*C.VkDispatchIndirectCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd298ba27 != nil {
		return x.refd298ba27, nil
	}
	memd298ba27 := allocDispatchIndirectCommandMemory(1)
	refd298ba27 := (*C.VkDispatchIndirectCommand)(memd298ba27)
	allocsd298ba27 := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	refd298ba27.x, cx_allocs = (C.uint32_t)(x.X), cgoAllocsUnknown
	allocsd298ba27.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refd298ba27.y, cy_allocs = (C.uint32_t)(x.Y), cgoAllocsUnknown
	allocsd298ba27.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	refd298ba27.z, cz_allocs = (C.uint32_t)(x.Z), cgoAllocsUnknown
	allocsd298ba27.Borrow(cz_allocs)

	x.refd298ba27 = refd298ba27
	x.allocsd298ba27 = allocsd298ba27
	return refd298ba27, allocsd298ba27

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DispatchIndirectCommand) PassValue() (C.VkDispatchIndirectCommand, *cgoAllocMap) {
	if x == nil {
		x = NewDispatchIndirectCommandRef(nil)
	} else if x.refd298ba27 != nil {
		return *x.refd298ba27, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DispatchIndirectCommand) Deref() {
	if x.refd298ba27 == nil {
		return
	}
	x.X = (uint32)(x.refd298ba27.x)
	x.Y = (uint32)(x.refd298ba27.y)
	x.Z = (uint32)(x.refd298ba27.z)
}

// allocDrawIndexedIndirectCommandMemory allocates memory for type C.VkDrawIndexedIndirectCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrawIndexedIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrawIndexedIndirectCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDrawIndexedIndirectCommandValue = unsafe.Sizeof([1]C.VkDrawIndexedIndirectCommand{})

// Ref returns a reference.
func (x *DrawIndexedIndirectCommand) Ref() *C.VkDrawIndexedIndirectCommand {
	if x == nil {
		return nil
	}
	return x.ref4c78b5c3
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DrawIndexedIndirectCommand) Free() {
	if x != nil && x.allocs4c78b5c3 != nil {
		x.allocs4c78b5c3.(*cgoAllocMap).Free()
		x.ref4c78b5c3 = nil
	}
}

// NewDrawIndexedIndirectCommandRef initialises a new struct holding the reference to the originaitng C struct.
func NewDrawIndexedIndirectCommandRef(ref *C.VkDrawIndexedIndirectCommand) *DrawIndexedIndirectCommand {
	if ref == nil {
		return nil
	}
	obj := new(DrawIndexedIndirectCommand)
	obj.ref4c78b5c3 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DrawIndexedIndirectCommand) PassRef() (*C.VkDrawIndexedIndirectCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4c78b5c3 != nil {
		return x.ref4c78b5c3, nil
	}
	mem4c78b5c3 := allocDrawIndexedIndirectCommandMemory(1)
	ref4c78b5c3 := (*C.VkDrawIndexedIndirectCommand)(mem4c78b5c3)
	allocs4c78b5c3 := new(cgoAllocMap)
	var cindexCount_allocs *cgoAllocMap
	ref4c78b5c3.indexCount, cindexCount_allocs = (C.uint32_t)(x.IndexCount), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cindexCount_allocs)

	var cinstanceCount_allocs *cgoAllocMap
	ref4c78b5c3.instanceCount, cinstanceCount_allocs = (C.uint32_t)(x.InstanceCount), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cinstanceCount_allocs)

	var cfirstIndex_allocs *cgoAllocMap
	ref4c78b5c3.firstIndex, cfirstIndex_allocs = (C.uint32_t)(x.FirstIndex), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cfirstIndex_allocs)

	var cvertexOffset_allocs *cgoAllocMap
	ref4c78b5c3.vertexOffset, cvertexOffset_allocs = (C.int32_t)(x.VertexOffset), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cvertexOffset_allocs)

	var cfirstInstance_allocs *cgoAllocMap
	ref4c78b5c3.firstInstance, cfirstInstance_allocs = (C.uint32_t)(x.FirstInstance), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cfirstInstance_allocs)

	x.ref4c78b5c3 = ref4c78b5c3
	x.allocs4c78b5c3 = allocs4c78b5c3
	return ref4c78b5c3, allocs4c78b5c3

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DrawIndexedIndirectCommand) PassValue() (C.VkDrawIndexedIndirectCommand, *cgoAllocMap) {
	if x == nil {
		x = NewDrawIndexedIndirectCommandRef(nil)
	} else if x.ref4c78b5c3 != nil {
		return *x.ref4c78b5c3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DrawIndexedIndirectCommand) Deref() {
	if x.ref4c78b5c3 == nil {
		return
	}
	x.IndexCount = (uint32)(x.ref4c78b5c3.indexCount)
	x.InstanceCount = (uint32)(x.ref4c78b5c3.instanceCount)
	x.FirstIndex = (uint32)(x.ref4c78b5c3.firstIndex)
	x.VertexOffset = (int32)(x.ref4c78b5c3.vertexOffset)
	x.FirstInstance = (uint32)(x.ref4c78b5c3.firstInstance)
}

// allocDrawIndirectCommandMemory allocates memory for type C.VkDrawIndirectCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrawIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrawIndirectCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDrawIndirectCommandValue = unsafe.Sizeof([1]C.VkDrawIndirectCommand{})

// Ref returns a reference.
func (x *DrawIndirectCommand) Ref() *C.VkDrawIndirectCommand {
	if x == nil {
		return nil
	}
	return x.ref2b5b67c4
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DrawIndirectCommand) Free() {
	if x != nil && x.allocs2b5b67c4 != nil {
		x.allocs2b5b67c4.(*cgoAllocMap).Free()
		x.ref2b5b67c4 = nil
	}
}

// NewDrawIndirectCommandRef initialises a new struct holding the reference to the originaitng C struct.
func NewDrawIndirectCommandRef(ref *C.VkDrawIndirectCommand) *DrawIndirectCommand {
	if ref == nil {
		return nil
	}
	obj := new(DrawIndirectCommand)
	obj.ref2b5b67c4 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DrawIndirectCommand) PassRef() (*C.VkDrawIndirectCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2b5b67c4 != nil {
		return x.ref2b5b67c4, nil
	}
	mem2b5b67c4 := allocDrawIndirectCommandMemory(1)
	ref2b5b67c4 := (*C.VkDrawIndirectCommand)(mem2b5b67c4)
	allocs2b5b67c4 := new(cgoAllocMap)
	var cvertexCount_allocs *cgoAllocMap
	ref2b5b67c4.vertexCount, cvertexCount_allocs = (C.uint32_t)(x.VertexCount), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cvertexCount_allocs)

	var cinstanceCount_allocs *cgoAllocMap
	ref2b5b67c4.instanceCount, cinstanceCount_allocs = (C.uint32_t)(x.InstanceCount), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cinstanceCount_allocs)

	var cfirstVertex_allocs *cgoAllocMap
	ref2b5b67c4.firstVertex, cfirstVertex_allocs = (C.uint32_t)(x.FirstVertex), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cfirstVertex_allocs)

	var cfirstInstance_allocs *cgoAllocMap
	ref2b5b67c4.firstInstance, cfirstInstance_allocs = (C.uint32_t)(x.FirstInstance), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cfirstInstance_allocs)

	x.ref2b5b67c4 = ref2b5b67c4
	x.allocs2b5b67c4 = allocs2b5b67c4
	return ref2b5b67c4, allocs2b5b67c4

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DrawIndirectCommand) PassValue() (C.VkDrawIndirectCommand, *cgoAllocMap) {
	if x == nil {
		x = NewDrawIndirectCommandRef(nil)
	} else if x.ref2b5b67c4 != nil {
		return *x.ref2b5b67c4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DrawIndirectCommand) Deref() {
	if x.ref2b5b67c4 == nil {
		return
	}
	x.VertexCount = (uint32)(x.ref2b5b67c4.vertexCount)
	x.InstanceCount = (uint32)(x.ref2b5b67c4.instanceCount)
	x.FirstVertex = (uint32)(x.ref2b5b67c4.firstVertex)
	x.FirstInstance = (uint32)(x.ref2b5b67c4.firstInstance)
}

// packSInstanceCreateInfo reads sliced Go data structure out from plain C format.
func packSInstanceCreateInfo(v []InstanceCreateInfo, ptr0 *C.VkInstanceCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfInstanceCreateInfoValue]C.VkInstanceCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewInstanceCreateInfoRef(&ptr1)
	}
}

// packSAllocationCallbacks reads sliced Go data structure out from plain C format.
func packSAllocationCallbacks(v []AllocationCallbacks, ptr0 *C.VkAllocationCallbacks) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAllocationCallbacksValue]C.VkAllocationCallbacks)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAllocationCallbacksRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateInstance) PassRef() (ref *C.PFN_vkCreateInstance, allocs *cgoAllocMap) {
	if pFNCreateInstanceC4DE473DFunc == nil {
		pFNCreateInstanceC4DE473DFunc = x
	}
	return (*C.PFN_vkCreateInstance)(C.PFN_vkCreateInstance_c4de473d), nil
}

// PassValue returns a value.
func (x PFNCreateInstance) PassValue() (ref C.PFN_vkCreateInstance, allocs *cgoAllocMap) {
	if pFNCreateInstanceC4DE473DFunc == nil {
		pFNCreateInstanceC4DE473DFunc = x
	}
	return (C.PFN_vkCreateInstance)(C.PFN_vkCreateInstance_c4de473d), nil
}

//export pFNCreateInstanceC4DE473D
func pFNCreateInstanceC4DE473D(cPCreateInfo *C.VkInstanceCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPInstance *C.VkInstance) C.VkResult {
	if pFNCreateInstanceC4DE473DFunc != nil {
		var PCreateInfoc4de473d []InstanceCreateInfo
		packSInstanceCreateInfo(PCreateInfoc4de473d, cPCreateInfo)
		var PAllocatorc4de473d []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorc4de473d, cPAllocator)
		var PInstancec4de473d []Instance
		hxf04b15b := (*sliceHeader)(unsafe.Pointer(&PInstancec4de473d))
		hxf04b15b.Data = uintptr(unsafe.Pointer(cPInstance))
		hxf04b15b.Cap = 0x7fffffff
		// hxf04b15b.Len = ?

		retc4de473d := pFNCreateInstanceC4DE473DFunc(PCreateInfoc4de473d, PAllocatorc4de473d, PInstancec4de473d)
		ret, _ := (C.VkResult)(retc4de473d), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateInstanceC4DE473DFunc PFNCreateInstance

// PassRef returns a reference.
func (x PFNDestroyInstance) PassRef() (ref *C.PFN_vkDestroyInstance, allocs *cgoAllocMap) {
	if pFNDestroyInstance38A99281Func == nil {
		pFNDestroyInstance38A99281Func = x
	}
	return (*C.PFN_vkDestroyInstance)(C.PFN_vkDestroyInstance_38a99281), nil
}

// PassValue returns a value.
func (x PFNDestroyInstance) PassValue() (ref C.PFN_vkDestroyInstance, allocs *cgoAllocMap) {
	if pFNDestroyInstance38A99281Func == nil {
		pFNDestroyInstance38A99281Func = x
	}
	return (C.PFN_vkDestroyInstance)(C.PFN_vkDestroyInstance_38a99281), nil
}

//export pFNDestroyInstance38A99281
func pFNDestroyInstance38A99281(cInstance C.VkInstance, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyInstance38A99281Func != nil {
		Instance38a99281 := *(*Instance)(unsafe.Pointer(&cInstance))
		var PAllocator38a99281 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator38a99281, cPAllocator)
		pFNDestroyInstance38A99281Func(Instance38a99281, PAllocator38a99281)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyInstance38A99281Func PFNDestroyInstance

// PassRef returns a reference.
func (x PFNEnumeratePhysicalDevices) PassRef() (ref *C.PFN_vkEnumeratePhysicalDevices, allocs *cgoAllocMap) {
	if pFNEnumeratePhysicalDevices1025CAFFFunc == nil {
		pFNEnumeratePhysicalDevices1025CAFFFunc = x
	}
	return (*C.PFN_vkEnumeratePhysicalDevices)(C.PFN_vkEnumeratePhysicalDevices_1025caff), nil
}

// PassValue returns a value.
func (x PFNEnumeratePhysicalDevices) PassValue() (ref C.PFN_vkEnumeratePhysicalDevices, allocs *cgoAllocMap) {
	if pFNEnumeratePhysicalDevices1025CAFFFunc == nil {
		pFNEnumeratePhysicalDevices1025CAFFFunc = x
	}
	return (C.PFN_vkEnumeratePhysicalDevices)(C.PFN_vkEnumeratePhysicalDevices_1025caff), nil
}

//export pFNEnumeratePhysicalDevices1025CAFF
func pFNEnumeratePhysicalDevices1025CAFF(cInstance C.VkInstance, cPPhysicalDeviceCount *C.uint32_t, cPPhysicalDevices *C.VkPhysicalDevice) C.VkResult {
	if pFNEnumeratePhysicalDevices1025CAFFFunc != nil {
		Instance1025caff := *(*Instance)(unsafe.Pointer(&cInstance))
		var PPhysicalDeviceCount1025caff []uint32
		hxf2f888b := (*sliceHeader)(unsafe.Pointer(&PPhysicalDeviceCount1025caff))
		hxf2f888b.Data = uintptr(unsafe.Pointer(cPPhysicalDeviceCount))
		hxf2f888b.Cap = 0x7fffffff
		// hxf2f888b.Len = ?

		var PPhysicalDevices1025caff []PhysicalDevice
		hxf5d1de2 := (*sliceHeader)(unsafe.Pointer(&PPhysicalDevices1025caff))
		hxf5d1de2.Data = uintptr(unsafe.Pointer(cPPhysicalDevices))
		hxf5d1de2.Cap = 0x7fffffff
		// hxf5d1de2.Len = ?

		ret1025caff := pFNEnumeratePhysicalDevices1025CAFFFunc(Instance1025caff, PPhysicalDeviceCount1025caff, PPhysicalDevices1025caff)
		ret, _ := (C.VkResult)(ret1025caff), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNEnumeratePhysicalDevices1025CAFFFunc PFNEnumeratePhysicalDevices

// PassRef returns a reference.
func (x PFNGetPhysicalDeviceFeatures) PassRef() (ref *C.PFN_vkGetPhysicalDeviceFeatures, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceFeaturesBE6387A0Func == nil {
		pFNGetPhysicalDeviceFeaturesBE6387A0Func = x
	}
	return (*C.PFN_vkGetPhysicalDeviceFeatures)(C.PFN_vkGetPhysicalDeviceFeatures_be6387a0), nil
}

// PassValue returns a value.
func (x PFNGetPhysicalDeviceFeatures) PassValue() (ref C.PFN_vkGetPhysicalDeviceFeatures, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceFeaturesBE6387A0Func == nil {
		pFNGetPhysicalDeviceFeaturesBE6387A0Func = x
	}
	return (C.PFN_vkGetPhysicalDeviceFeatures)(C.PFN_vkGetPhysicalDeviceFeatures_be6387a0), nil
}

//export pFNGetPhysicalDeviceFeaturesBE6387A0
func pFNGetPhysicalDeviceFeaturesBE6387A0(cPhysicalDevice C.VkPhysicalDevice, cPFeatures *C.VkPhysicalDeviceFeatures) {
	if pFNGetPhysicalDeviceFeaturesBE6387A0Func != nil {
		PhysicalDevicebe6387a0 := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		var PFeaturesbe6387a0 []PhysicalDeviceFeatures
		packSPhysicalDeviceFeatures(PFeaturesbe6387a0, cPFeatures)
		pFNGetPhysicalDeviceFeaturesBE6387A0Func(PhysicalDevicebe6387a0, PFeaturesbe6387a0)
	}
	panic("callback func has not been set (race?)")
}

var pFNGetPhysicalDeviceFeaturesBE6387A0Func PFNGetPhysicalDeviceFeatures

// packSFormatProperties reads sliced Go data structure out from plain C format.
func packSFormatProperties(v []FormatProperties, ptr0 *C.VkFormatProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFormatPropertiesValue]C.VkFormatProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFormatPropertiesRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetPhysicalDeviceFormatProperties) PassRef() (ref *C.PFN_vkGetPhysicalDeviceFormatProperties, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceFormatPropertiesDF58990EFunc == nil {
		pFNGetPhysicalDeviceFormatPropertiesDF58990EFunc = x
	}
	return (*C.PFN_vkGetPhysicalDeviceFormatProperties)(C.PFN_vkGetPhysicalDeviceFormatProperties_df58990e), nil
}

// PassValue returns a value.
func (x PFNGetPhysicalDeviceFormatProperties) PassValue() (ref C.PFN_vkGetPhysicalDeviceFormatProperties, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceFormatPropertiesDF58990EFunc == nil {
		pFNGetPhysicalDeviceFormatPropertiesDF58990EFunc = x
	}
	return (C.PFN_vkGetPhysicalDeviceFormatProperties)(C.PFN_vkGetPhysicalDeviceFormatProperties_df58990e), nil
}

//export pFNGetPhysicalDeviceFormatPropertiesDF58990E
func pFNGetPhysicalDeviceFormatPropertiesDF58990E(cPhysicalDevice C.VkPhysicalDevice, cFormat C.VkFormat, cPFormatProperties *C.VkFormatProperties) {
	if pFNGetPhysicalDeviceFormatPropertiesDF58990EFunc != nil {
		PhysicalDevicedf58990e := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		Formatdf58990e := (Format)(cFormat)
		var PFormatPropertiesdf58990e []FormatProperties
		packSFormatProperties(PFormatPropertiesdf58990e, cPFormatProperties)
		pFNGetPhysicalDeviceFormatPropertiesDF58990EFunc(PhysicalDevicedf58990e, Formatdf58990e, PFormatPropertiesdf58990e)
	}
	panic("callback func has not been set (race?)")
}

var pFNGetPhysicalDeviceFormatPropertiesDF58990EFunc PFNGetPhysicalDeviceFormatProperties

// packSImageFormatProperties reads sliced Go data structure out from plain C format.
func packSImageFormatProperties(v []ImageFormatProperties, ptr0 *C.VkImageFormatProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageFormatPropertiesValue]C.VkImageFormatProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageFormatPropertiesRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetPhysicalDeviceImageFormatProperties) PassRef() (ref *C.PFN_vkGetPhysicalDeviceImageFormatProperties, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceImageFormatProperties1362D074Func == nil {
		pFNGetPhysicalDeviceImageFormatProperties1362D074Func = x
	}
	return (*C.PFN_vkGetPhysicalDeviceImageFormatProperties)(C.PFN_vkGetPhysicalDeviceImageFormatProperties_1362d074), nil
}

// PassValue returns a value.
func (x PFNGetPhysicalDeviceImageFormatProperties) PassValue() (ref C.PFN_vkGetPhysicalDeviceImageFormatProperties, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceImageFormatProperties1362D074Func == nil {
		pFNGetPhysicalDeviceImageFormatProperties1362D074Func = x
	}
	return (C.PFN_vkGetPhysicalDeviceImageFormatProperties)(C.PFN_vkGetPhysicalDeviceImageFormatProperties_1362d074), nil
}

//export pFNGetPhysicalDeviceImageFormatProperties1362D074
func pFNGetPhysicalDeviceImageFormatProperties1362D074(cPhysicalDevice C.VkPhysicalDevice, cFormat C.VkFormat, c_type C.VkImageType, cTiling C.VkImageTiling, cUsage C.VkImageUsageFlags, cFlags C.VkImageCreateFlags, cPImageFormatProperties *C.VkImageFormatProperties) C.VkResult {
	if pFNGetPhysicalDeviceImageFormatProperties1362D074Func != nil {
		PhysicalDevice1362d074 := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		Format1362d074 := (Format)(cFormat)
		_type1362d074 := (ImageType)(c_type)
		Tiling1362d074 := (ImageTiling)(cTiling)
		Usage1362d074 := (ImageUsageFlags)(cUsage)
		Flags1362d074 := (ImageCreateFlags)(cFlags)
		var PImageFormatProperties1362d074 []ImageFormatProperties
		packSImageFormatProperties(PImageFormatProperties1362d074, cPImageFormatProperties)
		ret1362d074 := pFNGetPhysicalDeviceImageFormatProperties1362D074Func(PhysicalDevice1362d074, Format1362d074, _type1362d074, Tiling1362d074, Usage1362d074, Flags1362d074, PImageFormatProperties1362d074)
		ret, _ := (C.VkResult)(ret1362d074), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNGetPhysicalDeviceImageFormatProperties1362D074Func PFNGetPhysicalDeviceImageFormatProperties

// packSPhysicalDeviceProperties reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceProperties(v []PhysicalDeviceProperties, ptr0 *C.VkPhysicalDeviceProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDevicePropertiesValue]C.VkPhysicalDeviceProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDevicePropertiesRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetPhysicalDeviceProperties) PassRef() (ref *C.PFN_vkGetPhysicalDeviceProperties, allocs *cgoAllocMap) {
	if pFNGetPhysicalDevicePropertiesB4924563Func == nil {
		pFNGetPhysicalDevicePropertiesB4924563Func = x
	}
	return (*C.PFN_vkGetPhysicalDeviceProperties)(C.PFN_vkGetPhysicalDeviceProperties_b4924563), nil
}

// PassValue returns a value.
func (x PFNGetPhysicalDeviceProperties) PassValue() (ref C.PFN_vkGetPhysicalDeviceProperties, allocs *cgoAllocMap) {
	if pFNGetPhysicalDevicePropertiesB4924563Func == nil {
		pFNGetPhysicalDevicePropertiesB4924563Func = x
	}
	return (C.PFN_vkGetPhysicalDeviceProperties)(C.PFN_vkGetPhysicalDeviceProperties_b4924563), nil
}

//export pFNGetPhysicalDevicePropertiesB4924563
func pFNGetPhysicalDevicePropertiesB4924563(cPhysicalDevice C.VkPhysicalDevice, cPProperties *C.VkPhysicalDeviceProperties) {
	if pFNGetPhysicalDevicePropertiesB4924563Func != nil {
		PhysicalDeviceb4924563 := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		var PPropertiesb4924563 []PhysicalDeviceProperties
		packSPhysicalDeviceProperties(PPropertiesb4924563, cPProperties)
		pFNGetPhysicalDevicePropertiesB4924563Func(PhysicalDeviceb4924563, PPropertiesb4924563)
	}
	panic("callback func has not been set (race?)")
}

var pFNGetPhysicalDevicePropertiesB4924563Func PFNGetPhysicalDeviceProperties

// packSQueueFamilyProperties reads sliced Go data structure out from plain C format.
func packSQueueFamilyProperties(v []QueueFamilyProperties, ptr0 *C.VkQueueFamilyProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfQueueFamilyPropertiesValue]C.VkQueueFamilyProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewQueueFamilyPropertiesRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetPhysicalDeviceQueueFamilyProperties) PassRef() (ref *C.PFN_vkGetPhysicalDeviceQueueFamilyProperties, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceQueueFamilyProperties8AA13A90Func == nil {
		pFNGetPhysicalDeviceQueueFamilyProperties8AA13A90Func = x
	}
	return (*C.PFN_vkGetPhysicalDeviceQueueFamilyProperties)(C.PFN_vkGetPhysicalDeviceQueueFamilyProperties_8aa13a90), nil
}

// PassValue returns a value.
func (x PFNGetPhysicalDeviceQueueFamilyProperties) PassValue() (ref C.PFN_vkGetPhysicalDeviceQueueFamilyProperties, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceQueueFamilyProperties8AA13A90Func == nil {
		pFNGetPhysicalDeviceQueueFamilyProperties8AA13A90Func = x
	}
	return (C.PFN_vkGetPhysicalDeviceQueueFamilyProperties)(C.PFN_vkGetPhysicalDeviceQueueFamilyProperties_8aa13a90), nil
}

//export pFNGetPhysicalDeviceQueueFamilyProperties8AA13A90
func pFNGetPhysicalDeviceQueueFamilyProperties8AA13A90(cPhysicalDevice C.VkPhysicalDevice, cPQueueFamilyPropertyCount *C.uint32_t, cPQueueFamilyProperties *C.VkQueueFamilyProperties) {
	if pFNGetPhysicalDeviceQueueFamilyProperties8AA13A90Func != nil {
		PhysicalDevice8aa13a90 := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		var PQueueFamilyPropertyCount8aa13a90 []uint32
		hxfe53d34 := (*sliceHeader)(unsafe.Pointer(&PQueueFamilyPropertyCount8aa13a90))
		hxfe53d34.Data = uintptr(unsafe.Pointer(cPQueueFamilyPropertyCount))
		hxfe53d34.Cap = 0x7fffffff
		// hxfe53d34.Len = ?

		var PQueueFamilyProperties8aa13a90 []QueueFamilyProperties
		packSQueueFamilyProperties(PQueueFamilyProperties8aa13a90, cPQueueFamilyProperties)
		pFNGetPhysicalDeviceQueueFamilyProperties8AA13A90Func(PhysicalDevice8aa13a90, PQueueFamilyPropertyCount8aa13a90, PQueueFamilyProperties8aa13a90)
	}
	panic("callback func has not been set (race?)")
}

var pFNGetPhysicalDeviceQueueFamilyProperties8AA13A90Func PFNGetPhysicalDeviceQueueFamilyProperties

// packSPhysicalDeviceMemoryProperties reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceMemoryProperties(v []PhysicalDeviceMemoryProperties, ptr0 *C.VkPhysicalDeviceMemoryProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceMemoryPropertiesValue]C.VkPhysicalDeviceMemoryProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceMemoryPropertiesRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetPhysicalDeviceMemoryProperties) PassRef() (ref *C.PFN_vkGetPhysicalDeviceMemoryProperties, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceMemoryProperties2E4807FFunc == nil {
		pFNGetPhysicalDeviceMemoryProperties2E4807FFunc = x
	}
	return (*C.PFN_vkGetPhysicalDeviceMemoryProperties)(C.PFN_vkGetPhysicalDeviceMemoryProperties_2e4807f), nil
}

// PassValue returns a value.
func (x PFNGetPhysicalDeviceMemoryProperties) PassValue() (ref C.PFN_vkGetPhysicalDeviceMemoryProperties, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceMemoryProperties2E4807FFunc == nil {
		pFNGetPhysicalDeviceMemoryProperties2E4807FFunc = x
	}
	return (C.PFN_vkGetPhysicalDeviceMemoryProperties)(C.PFN_vkGetPhysicalDeviceMemoryProperties_2e4807f), nil
}

//export pFNGetPhysicalDeviceMemoryProperties2E4807F
func pFNGetPhysicalDeviceMemoryProperties2E4807F(cPhysicalDevice C.VkPhysicalDevice, cPMemoryProperties *C.VkPhysicalDeviceMemoryProperties) {
	if pFNGetPhysicalDeviceMemoryProperties2E4807FFunc != nil {
		PhysicalDevice2e4807f := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		var PMemoryProperties2e4807f []PhysicalDeviceMemoryProperties
		packSPhysicalDeviceMemoryProperties(PMemoryProperties2e4807f, cPMemoryProperties)
		pFNGetPhysicalDeviceMemoryProperties2E4807FFunc(PhysicalDevice2e4807f, PMemoryProperties2e4807f)
	}
	panic("callback func has not been set (race?)")
}

var pFNGetPhysicalDeviceMemoryProperties2E4807FFunc PFNGetPhysicalDeviceMemoryProperties

// packSDeviceCreateInfo reads sliced Go data structure out from plain C format.
func packSDeviceCreateInfo(v []DeviceCreateInfo, ptr0 *C.VkDeviceCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDeviceCreateInfoValue]C.VkDeviceCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateDevice) PassRef() (ref *C.PFN_vkCreateDevice, allocs *cgoAllocMap) {
	if pFNCreateDeviceF58DB1EBFunc == nil {
		pFNCreateDeviceF58DB1EBFunc = x
	}
	return (*C.PFN_vkCreateDevice)(C.PFN_vkCreateDevice_f58db1eb), nil
}

// PassValue returns a value.
func (x PFNCreateDevice) PassValue() (ref C.PFN_vkCreateDevice, allocs *cgoAllocMap) {
	if pFNCreateDeviceF58DB1EBFunc == nil {
		pFNCreateDeviceF58DB1EBFunc = x
	}
	return (C.PFN_vkCreateDevice)(C.PFN_vkCreateDevice_f58db1eb), nil
}

//export pFNCreateDeviceF58DB1EB
func pFNCreateDeviceF58DB1EB(cPhysicalDevice C.VkPhysicalDevice, cPCreateInfo *C.VkDeviceCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPDevice *C.VkDevice) C.VkResult {
	if pFNCreateDeviceF58DB1EBFunc != nil {
		PhysicalDevicef58db1eb := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		var PCreateInfof58db1eb []DeviceCreateInfo
		packSDeviceCreateInfo(PCreateInfof58db1eb, cPCreateInfo)
		var PAllocatorf58db1eb []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorf58db1eb, cPAllocator)
		var PDevicef58db1eb []Device
		hxf547023 := (*sliceHeader)(unsafe.Pointer(&PDevicef58db1eb))
		hxf547023.Data = uintptr(unsafe.Pointer(cPDevice))
		hxf547023.Cap = 0x7fffffff
		// hxf547023.Len = ?

		retf58db1eb := pFNCreateDeviceF58DB1EBFunc(PhysicalDevicef58db1eb, PCreateInfof58db1eb, PAllocatorf58db1eb, PDevicef58db1eb)
		ret, _ := (C.VkResult)(retf58db1eb), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateDeviceF58DB1EBFunc PFNCreateDevice

// PassRef returns a reference.
func (x PFNDestroyDevice) PassRef() (ref *C.PFN_vkDestroyDevice, allocs *cgoAllocMap) {
	if pFNDestroyDeviceC9A9759CFunc == nil {
		pFNDestroyDeviceC9A9759CFunc = x
	}
	return (*C.PFN_vkDestroyDevice)(C.PFN_vkDestroyDevice_c9a9759c), nil
}

// PassValue returns a value.
func (x PFNDestroyDevice) PassValue() (ref C.PFN_vkDestroyDevice, allocs *cgoAllocMap) {
	if pFNDestroyDeviceC9A9759CFunc == nil {
		pFNDestroyDeviceC9A9759CFunc = x
	}
	return (C.PFN_vkDestroyDevice)(C.PFN_vkDestroyDevice_c9a9759c), nil
}

//export pFNDestroyDeviceC9A9759C
func pFNDestroyDeviceC9A9759C(cDevice C.VkDevice, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyDeviceC9A9759CFunc != nil {
		Devicec9a9759c := *(*Device)(unsafe.Pointer(&cDevice))
		var PAllocatorc9a9759c []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorc9a9759c, cPAllocator)
		pFNDestroyDeviceC9A9759CFunc(Devicec9a9759c, PAllocatorc9a9759c)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyDeviceC9A9759CFunc PFNDestroyDevice

// packSExtensionProperties reads sliced Go data structure out from plain C format.
func packSExtensionProperties(v []ExtensionProperties, ptr0 *C.VkExtensionProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfExtensionPropertiesValue]C.VkExtensionProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewExtensionPropertiesRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNEnumerateInstanceExtensionProperties) PassRef() (ref *C.PFN_vkEnumerateInstanceExtensionProperties, allocs *cgoAllocMap) {
	if pFNEnumerateInstanceExtensionProperties43068F6EFunc == nil {
		pFNEnumerateInstanceExtensionProperties43068F6EFunc = x
	}
	return (*C.PFN_vkEnumerateInstanceExtensionProperties)(C.PFN_vkEnumerateInstanceExtensionProperties_43068f6e), nil
}

// PassValue returns a value.
func (x PFNEnumerateInstanceExtensionProperties) PassValue() (ref C.PFN_vkEnumerateInstanceExtensionProperties, allocs *cgoAllocMap) {
	if pFNEnumerateInstanceExtensionProperties43068F6EFunc == nil {
		pFNEnumerateInstanceExtensionProperties43068F6EFunc = x
	}
	return (C.PFN_vkEnumerateInstanceExtensionProperties)(C.PFN_vkEnumerateInstanceExtensionProperties_43068f6e), nil
}

//export pFNEnumerateInstanceExtensionProperties43068F6E
func pFNEnumerateInstanceExtensionProperties43068F6E(cPLayerName *C.char, cPPropertyCount *C.uint32_t, cPProperties *C.VkExtensionProperties) C.VkResult {
	if pFNEnumerateInstanceExtensionProperties43068F6EFunc != nil {
		PLayerName43068f6e := packPCharString(cPLayerName)
		var PPropertyCount43068f6e []uint32
		hxf5ebb88 := (*sliceHeader)(unsafe.Pointer(&PPropertyCount43068f6e))
		hxf5ebb88.Data = uintptr(unsafe.Pointer(cPPropertyCount))
		hxf5ebb88.Cap = 0x7fffffff
		// hxf5ebb88.Len = ?

		var PProperties43068f6e []ExtensionProperties
		packSExtensionProperties(PProperties43068f6e, cPProperties)
		ret43068f6e := pFNEnumerateInstanceExtensionProperties43068F6EFunc(PLayerName43068f6e, PPropertyCount43068f6e, PProperties43068f6e)
		ret, _ := (C.VkResult)(ret43068f6e), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNEnumerateInstanceExtensionProperties43068F6EFunc PFNEnumerateInstanceExtensionProperties

// PassRef returns a reference.
func (x PFNEnumerateDeviceExtensionProperties) PassRef() (ref *C.PFN_vkEnumerateDeviceExtensionProperties, allocs *cgoAllocMap) {
	if pFNEnumerateDeviceExtensionProperties1F7C3436Func == nil {
		pFNEnumerateDeviceExtensionProperties1F7C3436Func = x
	}
	return (*C.PFN_vkEnumerateDeviceExtensionProperties)(C.PFN_vkEnumerateDeviceExtensionProperties_1f7c3436), nil
}

// PassValue returns a value.
func (x PFNEnumerateDeviceExtensionProperties) PassValue() (ref C.PFN_vkEnumerateDeviceExtensionProperties, allocs *cgoAllocMap) {
	if pFNEnumerateDeviceExtensionProperties1F7C3436Func == nil {
		pFNEnumerateDeviceExtensionProperties1F7C3436Func = x
	}
	return (C.PFN_vkEnumerateDeviceExtensionProperties)(C.PFN_vkEnumerateDeviceExtensionProperties_1f7c3436), nil
}

//export pFNEnumerateDeviceExtensionProperties1F7C3436
func pFNEnumerateDeviceExtensionProperties1F7C3436(cPhysicalDevice C.VkPhysicalDevice, cPLayerName *C.char, cPPropertyCount *C.uint32_t, cPProperties *C.VkExtensionProperties) C.VkResult {
	if pFNEnumerateDeviceExtensionProperties1F7C3436Func != nil {
		PhysicalDevice1f7c3436 := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		PLayerName1f7c3436 := packPCharString(cPLayerName)
		var PPropertyCount1f7c3436 []uint32
		hxff20e84 := (*sliceHeader)(unsafe.Pointer(&PPropertyCount1f7c3436))
		hxff20e84.Data = uintptr(unsafe.Pointer(cPPropertyCount))
		hxff20e84.Cap = 0x7fffffff
		// hxff20e84.Len = ?

		var PProperties1f7c3436 []ExtensionProperties
		packSExtensionProperties(PProperties1f7c3436, cPProperties)
		ret1f7c3436 := pFNEnumerateDeviceExtensionProperties1F7C3436Func(PhysicalDevice1f7c3436, PLayerName1f7c3436, PPropertyCount1f7c3436, PProperties1f7c3436)
		ret, _ := (C.VkResult)(ret1f7c3436), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNEnumerateDeviceExtensionProperties1F7C3436Func PFNEnumerateDeviceExtensionProperties

// packSLayerProperties reads sliced Go data structure out from plain C format.
func packSLayerProperties(v []LayerProperties, ptr0 *C.VkLayerProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfLayerPropertiesValue]C.VkLayerProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewLayerPropertiesRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNEnumerateInstanceLayerProperties) PassRef() (ref *C.PFN_vkEnumerateInstanceLayerProperties, allocs *cgoAllocMap) {
	if pFNEnumerateInstanceLayerProperties692027FAFunc == nil {
		pFNEnumerateInstanceLayerProperties692027FAFunc = x
	}
	return (*C.PFN_vkEnumerateInstanceLayerProperties)(C.PFN_vkEnumerateInstanceLayerProperties_692027fa), nil
}

// PassValue returns a value.
func (x PFNEnumerateInstanceLayerProperties) PassValue() (ref C.PFN_vkEnumerateInstanceLayerProperties, allocs *cgoAllocMap) {
	if pFNEnumerateInstanceLayerProperties692027FAFunc == nil {
		pFNEnumerateInstanceLayerProperties692027FAFunc = x
	}
	return (C.PFN_vkEnumerateInstanceLayerProperties)(C.PFN_vkEnumerateInstanceLayerProperties_692027fa), nil
}

//export pFNEnumerateInstanceLayerProperties692027FA
func pFNEnumerateInstanceLayerProperties692027FA(cPPropertyCount *C.uint32_t, cPProperties *C.VkLayerProperties) C.VkResult {
	if pFNEnumerateInstanceLayerProperties692027FAFunc != nil {
		var PPropertyCount692027fa []uint32
		hxfa26a4d := (*sliceHeader)(unsafe.Pointer(&PPropertyCount692027fa))
		hxfa26a4d.Data = uintptr(unsafe.Pointer(cPPropertyCount))
		hxfa26a4d.Cap = 0x7fffffff
		// hxfa26a4d.Len = ?

		var PProperties692027fa []LayerProperties
		packSLayerProperties(PProperties692027fa, cPProperties)
		ret692027fa := pFNEnumerateInstanceLayerProperties692027FAFunc(PPropertyCount692027fa, PProperties692027fa)
		ret, _ := (C.VkResult)(ret692027fa), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNEnumerateInstanceLayerProperties692027FAFunc PFNEnumerateInstanceLayerProperties

// PassRef returns a reference.
func (x PFNEnumerateDeviceLayerProperties) PassRef() (ref *C.PFN_vkEnumerateDeviceLayerProperties, allocs *cgoAllocMap) {
	if pFNEnumerateDeviceLayerProperties991FC1BEFunc == nil {
		pFNEnumerateDeviceLayerProperties991FC1BEFunc = x
	}
	return (*C.PFN_vkEnumerateDeviceLayerProperties)(C.PFN_vkEnumerateDeviceLayerProperties_991fc1be), nil
}

// PassValue returns a value.
func (x PFNEnumerateDeviceLayerProperties) PassValue() (ref C.PFN_vkEnumerateDeviceLayerProperties, allocs *cgoAllocMap) {
	if pFNEnumerateDeviceLayerProperties991FC1BEFunc == nil {
		pFNEnumerateDeviceLayerProperties991FC1BEFunc = x
	}
	return (C.PFN_vkEnumerateDeviceLayerProperties)(C.PFN_vkEnumerateDeviceLayerProperties_991fc1be), nil
}

//export pFNEnumerateDeviceLayerProperties991FC1BE
func pFNEnumerateDeviceLayerProperties991FC1BE(cPhysicalDevice C.VkPhysicalDevice, cPPropertyCount *C.uint32_t, cPProperties *C.VkLayerProperties) C.VkResult {
	if pFNEnumerateDeviceLayerProperties991FC1BEFunc != nil {
		PhysicalDevice991fc1be := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		var PPropertyCount991fc1be []uint32
		hxfe48098 := (*sliceHeader)(unsafe.Pointer(&PPropertyCount991fc1be))
		hxfe48098.Data = uintptr(unsafe.Pointer(cPPropertyCount))
		hxfe48098.Cap = 0x7fffffff
		// hxfe48098.Len = ?

		var PProperties991fc1be []LayerProperties
		packSLayerProperties(PProperties991fc1be, cPProperties)
		ret991fc1be := pFNEnumerateDeviceLayerProperties991FC1BEFunc(PhysicalDevice991fc1be, PPropertyCount991fc1be, PProperties991fc1be)
		ret, _ := (C.VkResult)(ret991fc1be), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNEnumerateDeviceLayerProperties991FC1BEFunc PFNEnumerateDeviceLayerProperties

// PassRef returns a reference.
func (x PFNGetDeviceQueue) PassRef() (ref *C.PFN_vkGetDeviceQueue, allocs *cgoAllocMap) {
	if pFNGetDeviceQueueA2E8A65AFunc == nil {
		pFNGetDeviceQueueA2E8A65AFunc = x
	}
	return (*C.PFN_vkGetDeviceQueue)(C.PFN_vkGetDeviceQueue_a2e8a65a), nil
}

// PassValue returns a value.
func (x PFNGetDeviceQueue) PassValue() (ref C.PFN_vkGetDeviceQueue, allocs *cgoAllocMap) {
	if pFNGetDeviceQueueA2E8A65AFunc == nil {
		pFNGetDeviceQueueA2E8A65AFunc = x
	}
	return (C.PFN_vkGetDeviceQueue)(C.PFN_vkGetDeviceQueue_a2e8a65a), nil
}

//export pFNGetDeviceQueueA2E8A65A
func pFNGetDeviceQueueA2E8A65A(cDevice C.VkDevice, cQueueFamilyIndex C.uint32_t, cQueueIndex C.uint32_t, cPQueue *C.VkQueue) {
	if pFNGetDeviceQueueA2E8A65AFunc != nil {
		Devicea2e8a65a := *(*Device)(unsafe.Pointer(&cDevice))
		QueueFamilyIndexa2e8a65a := (uint32)(cQueueFamilyIndex)
		QueueIndexa2e8a65a := (uint32)(cQueueIndex)
		var PQueuea2e8a65a []Queue
		hxffe3496 := (*sliceHeader)(unsafe.Pointer(&PQueuea2e8a65a))
		hxffe3496.Data = uintptr(unsafe.Pointer(cPQueue))
		hxffe3496.Cap = 0x7fffffff
		// hxffe3496.Len = ?

		pFNGetDeviceQueueA2E8A65AFunc(Devicea2e8a65a, QueueFamilyIndexa2e8a65a, QueueIndexa2e8a65a, PQueuea2e8a65a)
	}
	panic("callback func has not been set (race?)")
}

var pFNGetDeviceQueueA2E8A65AFunc PFNGetDeviceQueue

// packSSubmitInfo reads sliced Go data structure out from plain C format.
func packSSubmitInfo(v []SubmitInfo, ptr0 *C.VkSubmitInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubmitInfoValue]C.VkSubmitInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubmitInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNQueueSubmit) PassRef() (ref *C.PFN_vkQueueSubmit, allocs *cgoAllocMap) {
	if pFNQueueSubmitE01486A5Func == nil {
		pFNQueueSubmitE01486A5Func = x
	}
	return (*C.PFN_vkQueueSubmit)(C.PFN_vkQueueSubmit_e01486a5), nil
}

// PassValue returns a value.
func (x PFNQueueSubmit) PassValue() (ref C.PFN_vkQueueSubmit, allocs *cgoAllocMap) {
	if pFNQueueSubmitE01486A5Func == nil {
		pFNQueueSubmitE01486A5Func = x
	}
	return (C.PFN_vkQueueSubmit)(C.PFN_vkQueueSubmit_e01486a5), nil
}

//export pFNQueueSubmitE01486A5
func pFNQueueSubmitE01486A5(cQueue C.VkQueue, cSubmitCount C.uint32_t, cPSubmits *C.VkSubmitInfo, cFence C.VkFence) C.VkResult {
	if pFNQueueSubmitE01486A5Func != nil {
		Queuee01486a5 := *(*Queue)(unsafe.Pointer(&cQueue))
		SubmitCounte01486a5 := (uint32)(cSubmitCount)
		var PSubmitse01486a5 []SubmitInfo
		packSSubmitInfo(PSubmitse01486a5, cPSubmits)
		Fencee01486a5 := *(*Fence)(unsafe.Pointer(&cFence))
		rete01486a5 := pFNQueueSubmitE01486A5Func(Queuee01486a5, SubmitCounte01486a5, PSubmitse01486a5, Fencee01486a5)
		ret, _ := (C.VkResult)(rete01486a5), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNQueueSubmitE01486A5Func PFNQueueSubmit

// PassRef returns a reference.
func (x PFNQueueWaitIdle) PassRef() (ref *C.PFN_vkQueueWaitIdle, allocs *cgoAllocMap) {
	if pFNQueueWaitIdleCE1A9277Func == nil {
		pFNQueueWaitIdleCE1A9277Func = x
	}
	return (*C.PFN_vkQueueWaitIdle)(C.PFN_vkQueueWaitIdle_ce1a9277), nil
}

// PassValue returns a value.
func (x PFNQueueWaitIdle) PassValue() (ref C.PFN_vkQueueWaitIdle, allocs *cgoAllocMap) {
	if pFNQueueWaitIdleCE1A9277Func == nil {
		pFNQueueWaitIdleCE1A9277Func = x
	}
	return (C.PFN_vkQueueWaitIdle)(C.PFN_vkQueueWaitIdle_ce1a9277), nil
}

//export pFNQueueWaitIdleCE1A9277
func pFNQueueWaitIdleCE1A9277(cQueue C.VkQueue) C.VkResult {
	if pFNQueueWaitIdleCE1A9277Func != nil {
		Queuece1a9277 := *(*Queue)(unsafe.Pointer(&cQueue))
		retce1a9277 := pFNQueueWaitIdleCE1A9277Func(Queuece1a9277)
		ret, _ := (C.VkResult)(retce1a9277), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNQueueWaitIdleCE1A9277Func PFNQueueWaitIdle

// PassRef returns a reference.
func (x PFNDeviceWaitIdle) PassRef() (ref *C.PFN_vkDeviceWaitIdle, allocs *cgoAllocMap) {
	if pFNDeviceWaitIdleBEED6562Func == nil {
		pFNDeviceWaitIdleBEED6562Func = x
	}
	return (*C.PFN_vkDeviceWaitIdle)(C.PFN_vkDeviceWaitIdle_beed6562), nil
}

// PassValue returns a value.
func (x PFNDeviceWaitIdle) PassValue() (ref C.PFN_vkDeviceWaitIdle, allocs *cgoAllocMap) {
	if pFNDeviceWaitIdleBEED6562Func == nil {
		pFNDeviceWaitIdleBEED6562Func = x
	}
	return (C.PFN_vkDeviceWaitIdle)(C.PFN_vkDeviceWaitIdle_beed6562), nil
}

//export pFNDeviceWaitIdleBEED6562
func pFNDeviceWaitIdleBEED6562(cDevice C.VkDevice) C.VkResult {
	if pFNDeviceWaitIdleBEED6562Func != nil {
		Devicebeed6562 := *(*Device)(unsafe.Pointer(&cDevice))
		retbeed6562 := pFNDeviceWaitIdleBEED6562Func(Devicebeed6562)
		ret, _ := (C.VkResult)(retbeed6562), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNDeviceWaitIdleBEED6562Func PFNDeviceWaitIdle

// packSMemoryAllocateInfo reads sliced Go data structure out from plain C format.
func packSMemoryAllocateInfo(v []MemoryAllocateInfo, ptr0 *C.VkMemoryAllocateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMemoryAllocateInfoValue]C.VkMemoryAllocateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMemoryAllocateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNAllocateMemory) PassRef() (ref *C.PFN_vkAllocateMemory, allocs *cgoAllocMap) {
	if pFNAllocateMemory4FE39399Func == nil {
		pFNAllocateMemory4FE39399Func = x
	}
	return (*C.PFN_vkAllocateMemory)(C.PFN_vkAllocateMemory_4fe39399), nil
}

// PassValue returns a value.
func (x PFNAllocateMemory) PassValue() (ref C.PFN_vkAllocateMemory, allocs *cgoAllocMap) {
	if pFNAllocateMemory4FE39399Func == nil {
		pFNAllocateMemory4FE39399Func = x
	}
	return (C.PFN_vkAllocateMemory)(C.PFN_vkAllocateMemory_4fe39399), nil
}

//export pFNAllocateMemory4FE39399
func pFNAllocateMemory4FE39399(cDevice C.VkDevice, cPAllocateInfo *C.VkMemoryAllocateInfo, cPAllocator *C.VkAllocationCallbacks, cPMemory *C.VkDeviceMemory) C.VkResult {
	if pFNAllocateMemory4FE39399Func != nil {
		Device4fe39399 := *(*Device)(unsafe.Pointer(&cDevice))
		var PAllocateInfo4fe39399 []MemoryAllocateInfo
		packSMemoryAllocateInfo(PAllocateInfo4fe39399, cPAllocateInfo)
		var PAllocator4fe39399 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator4fe39399, cPAllocator)
		var PMemory4fe39399 []DeviceMemory
		hxf5d48a6 := (*sliceHeader)(unsafe.Pointer(&PMemory4fe39399))
		hxf5d48a6.Data = uintptr(unsafe.Pointer(cPMemory))
		hxf5d48a6.Cap = 0x7fffffff
		// hxf5d48a6.Len = ?

		ret4fe39399 := pFNAllocateMemory4FE39399Func(Device4fe39399, PAllocateInfo4fe39399, PAllocator4fe39399, PMemory4fe39399)
		ret, _ := (C.VkResult)(ret4fe39399), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNAllocateMemory4FE39399Func PFNAllocateMemory

// PassRef returns a reference.
func (x PFNFreeMemory) PassRef() (ref *C.PFN_vkFreeMemory, allocs *cgoAllocMap) {
	if pFNFreeMemory80CE986AFunc == nil {
		pFNFreeMemory80CE986AFunc = x
	}
	return (*C.PFN_vkFreeMemory)(C.PFN_vkFreeMemory_80ce986a), nil
}

// PassValue returns a value.
func (x PFNFreeMemory) PassValue() (ref C.PFN_vkFreeMemory, allocs *cgoAllocMap) {
	if pFNFreeMemory80CE986AFunc == nil {
		pFNFreeMemory80CE986AFunc = x
	}
	return (C.PFN_vkFreeMemory)(C.PFN_vkFreeMemory_80ce986a), nil
}

//export pFNFreeMemory80CE986A
func pFNFreeMemory80CE986A(cDevice C.VkDevice, cMemory C.VkDeviceMemory, cPAllocator *C.VkAllocationCallbacks) {
	if pFNFreeMemory80CE986AFunc != nil {
		Device80ce986a := *(*Device)(unsafe.Pointer(&cDevice))
		Memory80ce986a := *(*DeviceMemory)(unsafe.Pointer(&cMemory))
		var PAllocator80ce986a []AllocationCallbacks
		packSAllocationCallbacks(PAllocator80ce986a, cPAllocator)
		pFNFreeMemory80CE986AFunc(Device80ce986a, Memory80ce986a, PAllocator80ce986a)
	}
	panic("callback func has not been set (race?)")
}

var pFNFreeMemory80CE986AFunc PFNFreeMemory

// PassRef returns a reference.
func (x PFNMapMemory) PassRef() (ref *C.PFN_vkMapMemory, allocs *cgoAllocMap) {
	if pFNMapMemory55D2603DFunc == nil {
		pFNMapMemory55D2603DFunc = x
	}
	return (*C.PFN_vkMapMemory)(C.PFN_vkMapMemory_55d2603d), nil
}

// PassValue returns a value.
func (x PFNMapMemory) PassValue() (ref C.PFN_vkMapMemory, allocs *cgoAllocMap) {
	if pFNMapMemory55D2603DFunc == nil {
		pFNMapMemory55D2603DFunc = x
	}
	return (C.PFN_vkMapMemory)(C.PFN_vkMapMemory_55d2603d), nil
}

//export pFNMapMemory55D2603D
func pFNMapMemory55D2603D(cDevice C.VkDevice, cMemory C.VkDeviceMemory, cOffset C.VkDeviceSize, cSize C.VkDeviceSize, cFlags C.VkMemoryMapFlags, cPpData *unsafe.Pointer) C.VkResult {
	if pFNMapMemory55D2603DFunc != nil {
		Device55d2603d := *(*Device)(unsafe.Pointer(&cDevice))
		Memory55d2603d := *(*DeviceMemory)(unsafe.Pointer(&cMemory))
		Offset55d2603d := (DeviceSize)(cOffset)
		Size55d2603d := (DeviceSize)(cSize)
		Flags55d2603d := (MemoryMapFlags)(cFlags)
		var PpData55d2603d []unsafe.Pointer
		hxf685469 := (*sliceHeader)(unsafe.Pointer(&PpData55d2603d))
		hxf685469.Data = uintptr(unsafe.Pointer(cPpData))
		hxf685469.Cap = 0x7fffffff
		// hxf685469.Len = ?

		ret55d2603d := pFNMapMemory55D2603DFunc(Device55d2603d, Memory55d2603d, Offset55d2603d, Size55d2603d, Flags55d2603d, PpData55d2603d)
		ret, _ := (C.VkResult)(ret55d2603d), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNMapMemory55D2603DFunc PFNMapMemory

// PassRef returns a reference.
func (x PFNUnmapMemory) PassRef() (ref *C.PFN_vkUnmapMemory, allocs *cgoAllocMap) {
	if pFNUnmapMemory2C1026EEFunc == nil {
		pFNUnmapMemory2C1026EEFunc = x
	}
	return (*C.PFN_vkUnmapMemory)(C.PFN_vkUnmapMemory_2c1026ee), nil
}

// PassValue returns a value.
func (x PFNUnmapMemory) PassValue() (ref C.PFN_vkUnmapMemory, allocs *cgoAllocMap) {
	if pFNUnmapMemory2C1026EEFunc == nil {
		pFNUnmapMemory2C1026EEFunc = x
	}
	return (C.PFN_vkUnmapMemory)(C.PFN_vkUnmapMemory_2c1026ee), nil
}

//export pFNUnmapMemory2C1026EE
func pFNUnmapMemory2C1026EE(cDevice C.VkDevice, cMemory C.VkDeviceMemory) {
	if pFNUnmapMemory2C1026EEFunc != nil {
		Device2c1026ee := *(*Device)(unsafe.Pointer(&cDevice))
		Memory2c1026ee := *(*DeviceMemory)(unsafe.Pointer(&cMemory))
		pFNUnmapMemory2C1026EEFunc(Device2c1026ee, Memory2c1026ee)
	}
	panic("callback func has not been set (race?)")
}

var pFNUnmapMemory2C1026EEFunc PFNUnmapMemory

// packSMappedMemoryRange reads sliced Go data structure out from plain C format.
func packSMappedMemoryRange(v []MappedMemoryRange, ptr0 *C.VkMappedMemoryRange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMappedMemoryRangeValue]C.VkMappedMemoryRange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMappedMemoryRangeRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNFlushMappedMemoryRanges) PassRef() (ref *C.PFN_vkFlushMappedMemoryRanges, allocs *cgoAllocMap) {
	if pFNFlushMappedMemoryRanges912839F9Func == nil {
		pFNFlushMappedMemoryRanges912839F9Func = x
	}
	return (*C.PFN_vkFlushMappedMemoryRanges)(C.PFN_vkFlushMappedMemoryRanges_912839f9), nil
}

// PassValue returns a value.
func (x PFNFlushMappedMemoryRanges) PassValue() (ref C.PFN_vkFlushMappedMemoryRanges, allocs *cgoAllocMap) {
	if pFNFlushMappedMemoryRanges912839F9Func == nil {
		pFNFlushMappedMemoryRanges912839F9Func = x
	}
	return (C.PFN_vkFlushMappedMemoryRanges)(C.PFN_vkFlushMappedMemoryRanges_912839f9), nil
}

//export pFNFlushMappedMemoryRanges912839F9
func pFNFlushMappedMemoryRanges912839F9(cDevice C.VkDevice, cMemoryRangeCount C.uint32_t, cPMemoryRanges *C.VkMappedMemoryRange) C.VkResult {
	if pFNFlushMappedMemoryRanges912839F9Func != nil {
		Device912839f9 := *(*Device)(unsafe.Pointer(&cDevice))
		MemoryRangeCount912839f9 := (uint32)(cMemoryRangeCount)
		var PMemoryRanges912839f9 []MappedMemoryRange
		packSMappedMemoryRange(PMemoryRanges912839f9, cPMemoryRanges)
		ret912839f9 := pFNFlushMappedMemoryRanges912839F9Func(Device912839f9, MemoryRangeCount912839f9, PMemoryRanges912839f9)
		ret, _ := (C.VkResult)(ret912839f9), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNFlushMappedMemoryRanges912839F9Func PFNFlushMappedMemoryRanges

// PassRef returns a reference.
func (x PFNInvalidateMappedMemoryRanges) PassRef() (ref *C.PFN_vkInvalidateMappedMemoryRanges, allocs *cgoAllocMap) {
	if pFNInvalidateMappedMemoryRanges583CF236Func == nil {
		pFNInvalidateMappedMemoryRanges583CF236Func = x
	}
	return (*C.PFN_vkInvalidateMappedMemoryRanges)(C.PFN_vkInvalidateMappedMemoryRanges_583cf236), nil
}

// PassValue returns a value.
func (x PFNInvalidateMappedMemoryRanges) PassValue() (ref C.PFN_vkInvalidateMappedMemoryRanges, allocs *cgoAllocMap) {
	if pFNInvalidateMappedMemoryRanges583CF236Func == nil {
		pFNInvalidateMappedMemoryRanges583CF236Func = x
	}
	return (C.PFN_vkInvalidateMappedMemoryRanges)(C.PFN_vkInvalidateMappedMemoryRanges_583cf236), nil
}

//export pFNInvalidateMappedMemoryRanges583CF236
func pFNInvalidateMappedMemoryRanges583CF236(cDevice C.VkDevice, cMemoryRangeCount C.uint32_t, cPMemoryRanges *C.VkMappedMemoryRange) C.VkResult {
	if pFNInvalidateMappedMemoryRanges583CF236Func != nil {
		Device583cf236 := *(*Device)(unsafe.Pointer(&cDevice))
		MemoryRangeCount583cf236 := (uint32)(cMemoryRangeCount)
		var PMemoryRanges583cf236 []MappedMemoryRange
		packSMappedMemoryRange(PMemoryRanges583cf236, cPMemoryRanges)
		ret583cf236 := pFNInvalidateMappedMemoryRanges583CF236Func(Device583cf236, MemoryRangeCount583cf236, PMemoryRanges583cf236)
		ret, _ := (C.VkResult)(ret583cf236), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNInvalidateMappedMemoryRanges583CF236Func PFNInvalidateMappedMemoryRanges

// PassRef returns a reference.
func (x PFNGetDeviceMemoryCommitment) PassRef() (ref *C.PFN_vkGetDeviceMemoryCommitment, allocs *cgoAllocMap) {
	if pFNGetDeviceMemoryCommitment26E8EE13Func == nil {
		pFNGetDeviceMemoryCommitment26E8EE13Func = x
	}
	return (*C.PFN_vkGetDeviceMemoryCommitment)(C.PFN_vkGetDeviceMemoryCommitment_26e8ee13), nil
}

// PassValue returns a value.
func (x PFNGetDeviceMemoryCommitment) PassValue() (ref C.PFN_vkGetDeviceMemoryCommitment, allocs *cgoAllocMap) {
	if pFNGetDeviceMemoryCommitment26E8EE13Func == nil {
		pFNGetDeviceMemoryCommitment26E8EE13Func = x
	}
	return (C.PFN_vkGetDeviceMemoryCommitment)(C.PFN_vkGetDeviceMemoryCommitment_26e8ee13), nil
}

//export pFNGetDeviceMemoryCommitment26E8EE13
func pFNGetDeviceMemoryCommitment26E8EE13(cDevice C.VkDevice, cMemory C.VkDeviceMemory, cPCommittedMemoryInBytes *C.VkDeviceSize) {
	if pFNGetDeviceMemoryCommitment26E8EE13Func != nil {
		Device26e8ee13 := *(*Device)(unsafe.Pointer(&cDevice))
		Memory26e8ee13 := *(*DeviceMemory)(unsafe.Pointer(&cMemory))
		var PCommittedMemoryInBytes26e8ee13 []DeviceSize
		hxf03a9a7 := (*sliceHeader)(unsafe.Pointer(&PCommittedMemoryInBytes26e8ee13))
		hxf03a9a7.Data = uintptr(unsafe.Pointer(cPCommittedMemoryInBytes))
		hxf03a9a7.Cap = 0x7fffffff
		// hxf03a9a7.Len = ?

		pFNGetDeviceMemoryCommitment26E8EE13Func(Device26e8ee13, Memory26e8ee13, PCommittedMemoryInBytes26e8ee13)
	}
	panic("callback func has not been set (race?)")
}

var pFNGetDeviceMemoryCommitment26E8EE13Func PFNGetDeviceMemoryCommitment

// PassRef returns a reference.
func (x PFNBindBufferMemory) PassRef() (ref *C.PFN_vkBindBufferMemory, allocs *cgoAllocMap) {
	if pFNBindBufferMemoryF22E1EDBFunc == nil {
		pFNBindBufferMemoryF22E1EDBFunc = x
	}
	return (*C.PFN_vkBindBufferMemory)(C.PFN_vkBindBufferMemory_f22e1edb), nil
}

// PassValue returns a value.
func (x PFNBindBufferMemory) PassValue() (ref C.PFN_vkBindBufferMemory, allocs *cgoAllocMap) {
	if pFNBindBufferMemoryF22E1EDBFunc == nil {
		pFNBindBufferMemoryF22E1EDBFunc = x
	}
	return (C.PFN_vkBindBufferMemory)(C.PFN_vkBindBufferMemory_f22e1edb), nil
}

//export pFNBindBufferMemoryF22E1EDB
func pFNBindBufferMemoryF22E1EDB(cDevice C.VkDevice, cBuffer C.VkBuffer, cMemory C.VkDeviceMemory, cMemoryOffset C.VkDeviceSize) C.VkResult {
	if pFNBindBufferMemoryF22E1EDBFunc != nil {
		Devicef22e1edb := *(*Device)(unsafe.Pointer(&cDevice))
		Bufferf22e1edb := *(*Buffer)(unsafe.Pointer(&cBuffer))
		Memoryf22e1edb := *(*DeviceMemory)(unsafe.Pointer(&cMemory))
		MemoryOffsetf22e1edb := (DeviceSize)(cMemoryOffset)
		retf22e1edb := pFNBindBufferMemoryF22E1EDBFunc(Devicef22e1edb, Bufferf22e1edb, Memoryf22e1edb, MemoryOffsetf22e1edb)
		ret, _ := (C.VkResult)(retf22e1edb), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNBindBufferMemoryF22E1EDBFunc PFNBindBufferMemory

// PassRef returns a reference.
func (x PFNBindImageMemory) PassRef() (ref *C.PFN_vkBindImageMemory, allocs *cgoAllocMap) {
	if pFNBindImageMemory56F456ABFunc == nil {
		pFNBindImageMemory56F456ABFunc = x
	}
	return (*C.PFN_vkBindImageMemory)(C.PFN_vkBindImageMemory_56f456ab), nil
}

// PassValue returns a value.
func (x PFNBindImageMemory) PassValue() (ref C.PFN_vkBindImageMemory, allocs *cgoAllocMap) {
	if pFNBindImageMemory56F456ABFunc == nil {
		pFNBindImageMemory56F456ABFunc = x
	}
	return (C.PFN_vkBindImageMemory)(C.PFN_vkBindImageMemory_56f456ab), nil
}

//export pFNBindImageMemory56F456AB
func pFNBindImageMemory56F456AB(cDevice C.VkDevice, cImage C.VkImage, cMemory C.VkDeviceMemory, cMemoryOffset C.VkDeviceSize) C.VkResult {
	if pFNBindImageMemory56F456ABFunc != nil {
		Device56f456ab := *(*Device)(unsafe.Pointer(&cDevice))
		Image56f456ab := *(*Image)(unsafe.Pointer(&cImage))
		Memory56f456ab := *(*DeviceMemory)(unsafe.Pointer(&cMemory))
		MemoryOffset56f456ab := (DeviceSize)(cMemoryOffset)
		ret56f456ab := pFNBindImageMemory56F456ABFunc(Device56f456ab, Image56f456ab, Memory56f456ab, MemoryOffset56f456ab)
		ret, _ := (C.VkResult)(ret56f456ab), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNBindImageMemory56F456ABFunc PFNBindImageMemory

// packSMemoryRequirements reads sliced Go data structure out from plain C format.
func packSMemoryRequirements(v []MemoryRequirements, ptr0 *C.VkMemoryRequirements) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMemoryRequirementsValue]C.VkMemoryRequirements)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMemoryRequirementsRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetBufferMemoryRequirements) PassRef() (ref *C.PFN_vkGetBufferMemoryRequirements, allocs *cgoAllocMap) {
	if pFNGetBufferMemoryRequirements4AF23F40Func == nil {
		pFNGetBufferMemoryRequirements4AF23F40Func = x
	}
	return (*C.PFN_vkGetBufferMemoryRequirements)(C.PFN_vkGetBufferMemoryRequirements_4af23f40), nil
}

// PassValue returns a value.
func (x PFNGetBufferMemoryRequirements) PassValue() (ref C.PFN_vkGetBufferMemoryRequirements, allocs *cgoAllocMap) {
	if pFNGetBufferMemoryRequirements4AF23F40Func == nil {
		pFNGetBufferMemoryRequirements4AF23F40Func = x
	}
	return (C.PFN_vkGetBufferMemoryRequirements)(C.PFN_vkGetBufferMemoryRequirements_4af23f40), nil
}

//export pFNGetBufferMemoryRequirements4AF23F40
func pFNGetBufferMemoryRequirements4AF23F40(cDevice C.VkDevice, cBuffer C.VkBuffer, cPMemoryRequirements *C.VkMemoryRequirements) {
	if pFNGetBufferMemoryRequirements4AF23F40Func != nil {
		Device4af23f40 := *(*Device)(unsafe.Pointer(&cDevice))
		Buffer4af23f40 := *(*Buffer)(unsafe.Pointer(&cBuffer))
		var PMemoryRequirements4af23f40 []MemoryRequirements
		packSMemoryRequirements(PMemoryRequirements4af23f40, cPMemoryRequirements)
		pFNGetBufferMemoryRequirements4AF23F40Func(Device4af23f40, Buffer4af23f40, PMemoryRequirements4af23f40)
	}
	panic("callback func has not been set (race?)")
}

var pFNGetBufferMemoryRequirements4AF23F40Func PFNGetBufferMemoryRequirements

// PassRef returns a reference.
func (x PFNGetImageMemoryRequirements) PassRef() (ref *C.PFN_vkGetImageMemoryRequirements, allocs *cgoAllocMap) {
	if pFNGetImageMemoryRequirements74385628Func == nil {
		pFNGetImageMemoryRequirements74385628Func = x
	}
	return (*C.PFN_vkGetImageMemoryRequirements)(C.PFN_vkGetImageMemoryRequirements_74385628), nil
}

// PassValue returns a value.
func (x PFNGetImageMemoryRequirements) PassValue() (ref C.PFN_vkGetImageMemoryRequirements, allocs *cgoAllocMap) {
	if pFNGetImageMemoryRequirements74385628Func == nil {
		pFNGetImageMemoryRequirements74385628Func = x
	}
	return (C.PFN_vkGetImageMemoryRequirements)(C.PFN_vkGetImageMemoryRequirements_74385628), nil
}

//export pFNGetImageMemoryRequirements74385628
func pFNGetImageMemoryRequirements74385628(cDevice C.VkDevice, cImage C.VkImage, cPMemoryRequirements *C.VkMemoryRequirements) {
	if pFNGetImageMemoryRequirements74385628Func != nil {
		Device74385628 := *(*Device)(unsafe.Pointer(&cDevice))
		Image74385628 := *(*Image)(unsafe.Pointer(&cImage))
		var PMemoryRequirements74385628 []MemoryRequirements
		packSMemoryRequirements(PMemoryRequirements74385628, cPMemoryRequirements)
		pFNGetImageMemoryRequirements74385628Func(Device74385628, Image74385628, PMemoryRequirements74385628)
	}
	panic("callback func has not been set (race?)")
}

var pFNGetImageMemoryRequirements74385628Func PFNGetImageMemoryRequirements

// packSSparseImageMemoryRequirements reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryRequirements(v []SparseImageMemoryRequirements, ptr0 *C.VkSparseImageMemoryRequirements) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryRequirementsValue]C.VkSparseImageMemoryRequirements)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryRequirementsRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetImageSparseMemoryRequirements) PassRef() (ref *C.PFN_vkGetImageSparseMemoryRequirements, allocs *cgoAllocMap) {
	if pFNGetImageSparseMemoryRequirements86DD1A84Func == nil {
		pFNGetImageSparseMemoryRequirements86DD1A84Func = x
	}
	return (*C.PFN_vkGetImageSparseMemoryRequirements)(C.PFN_vkGetImageSparseMemoryRequirements_86dd1a84), nil
}

// PassValue returns a value.
func (x PFNGetImageSparseMemoryRequirements) PassValue() (ref C.PFN_vkGetImageSparseMemoryRequirements, allocs *cgoAllocMap) {
	if pFNGetImageSparseMemoryRequirements86DD1A84Func == nil {
		pFNGetImageSparseMemoryRequirements86DD1A84Func = x
	}
	return (C.PFN_vkGetImageSparseMemoryRequirements)(C.PFN_vkGetImageSparseMemoryRequirements_86dd1a84), nil
}

//export pFNGetImageSparseMemoryRequirements86DD1A84
func pFNGetImageSparseMemoryRequirements86DD1A84(cDevice C.VkDevice, cImage C.VkImage, cPSparseMemoryRequirementCount *C.uint32_t, cPSparseMemoryRequirements *C.VkSparseImageMemoryRequirements) {
	if pFNGetImageSparseMemoryRequirements86DD1A84Func != nil {
		Device86dd1a84 := *(*Device)(unsafe.Pointer(&cDevice))
		Image86dd1a84 := *(*Image)(unsafe.Pointer(&cImage))
		var PSparseMemoryRequirementCount86dd1a84 []uint32
		hxff24242 := (*sliceHeader)(unsafe.Pointer(&PSparseMemoryRequirementCount86dd1a84))
		hxff24242.Data = uintptr(unsafe.Pointer(cPSparseMemoryRequirementCount))
		hxff24242.Cap = 0x7fffffff
		// hxff24242.Len = ?

		var PSparseMemoryRequirements86dd1a84 []SparseImageMemoryRequirements
		packSSparseImageMemoryRequirements(PSparseMemoryRequirements86dd1a84, cPSparseMemoryRequirements)
		pFNGetImageSparseMemoryRequirements86DD1A84Func(Device86dd1a84, Image86dd1a84, PSparseMemoryRequirementCount86dd1a84, PSparseMemoryRequirements86dd1a84)
	}
	panic("callback func has not been set (race?)")
}

var pFNGetImageSparseMemoryRequirements86DD1A84Func PFNGetImageSparseMemoryRequirements

// packSSparseImageFormatProperties reads sliced Go data structure out from plain C format.
func packSSparseImageFormatProperties(v []SparseImageFormatProperties, ptr0 *C.VkSparseImageFormatProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageFormatPropertiesValue]C.VkSparseImageFormatProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageFormatPropertiesRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetPhysicalDeviceSparseImageFormatProperties) PassRef() (ref *C.PFN_vkGetPhysicalDeviceSparseImageFormatProperties, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceSparseImageFormatPropertiesB8D919E9Func == nil {
		pFNGetPhysicalDeviceSparseImageFormatPropertiesB8D919E9Func = x
	}
	return (*C.PFN_vkGetPhysicalDeviceSparseImageFormatProperties)(C.PFN_vkGetPhysicalDeviceSparseImageFormatProperties_b8d919e9), nil
}

// PassValue returns a value.
func (x PFNGetPhysicalDeviceSparseImageFormatProperties) PassValue() (ref C.PFN_vkGetPhysicalDeviceSparseImageFormatProperties, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceSparseImageFormatPropertiesB8D919E9Func == nil {
		pFNGetPhysicalDeviceSparseImageFormatPropertiesB8D919E9Func = x
	}
	return (C.PFN_vkGetPhysicalDeviceSparseImageFormatProperties)(C.PFN_vkGetPhysicalDeviceSparseImageFormatProperties_b8d919e9), nil
}

//export pFNGetPhysicalDeviceSparseImageFormatPropertiesB8D919E9
func pFNGetPhysicalDeviceSparseImageFormatPropertiesB8D919E9(cPhysicalDevice C.VkPhysicalDevice, cFormat C.VkFormat, c_type C.VkImageType, cSamples C.VkSampleCountFlagBits, cUsage C.VkImageUsageFlags, cTiling C.VkImageTiling, cPPropertyCount *C.uint32_t, cPProperties *C.VkSparseImageFormatProperties) {
	if pFNGetPhysicalDeviceSparseImageFormatPropertiesB8D919E9Func != nil {
		PhysicalDeviceb8d919e9 := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		Formatb8d919e9 := (Format)(cFormat)
		_typeb8d919e9 := (ImageType)(c_type)
		Samplesb8d919e9 := (SampleCountFlagBits)(cSamples)
		Usageb8d919e9 := (ImageUsageFlags)(cUsage)
		Tilingb8d919e9 := (ImageTiling)(cTiling)
		var PPropertyCountb8d919e9 []uint32
		hxfe93325 := (*sliceHeader)(unsafe.Pointer(&PPropertyCountb8d919e9))
		hxfe93325.Data = uintptr(unsafe.Pointer(cPPropertyCount))
		hxfe93325.Cap = 0x7fffffff
		// hxfe93325.Len = ?

		var PPropertiesb8d919e9 []SparseImageFormatProperties
		packSSparseImageFormatProperties(PPropertiesb8d919e9, cPProperties)
		pFNGetPhysicalDeviceSparseImageFormatPropertiesB8D919E9Func(PhysicalDeviceb8d919e9, Formatb8d919e9, _typeb8d919e9, Samplesb8d919e9, Usageb8d919e9, Tilingb8d919e9, PPropertyCountb8d919e9, PPropertiesb8d919e9)
	}
	panic("callback func has not been set (race?)")
}

var pFNGetPhysicalDeviceSparseImageFormatPropertiesB8D919E9Func PFNGetPhysicalDeviceSparseImageFormatProperties

// packSBindSparseInfo reads sliced Go data structure out from plain C format.
func packSBindSparseInfo(v []BindSparseInfo, ptr0 *C.VkBindSparseInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBindSparseInfoValue]C.VkBindSparseInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBindSparseInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNQueueBindSparse) PassRef() (ref *C.PFN_vkQueueBindSparse, allocs *cgoAllocMap) {
	if pFNQueueBindSparseCD067EAAFunc == nil {
		pFNQueueBindSparseCD067EAAFunc = x
	}
	return (*C.PFN_vkQueueBindSparse)(C.PFN_vkQueueBindSparse_cd067eaa), nil
}

// PassValue returns a value.
func (x PFNQueueBindSparse) PassValue() (ref C.PFN_vkQueueBindSparse, allocs *cgoAllocMap) {
	if pFNQueueBindSparseCD067EAAFunc == nil {
		pFNQueueBindSparseCD067EAAFunc = x
	}
	return (C.PFN_vkQueueBindSparse)(C.PFN_vkQueueBindSparse_cd067eaa), nil
}

//export pFNQueueBindSparseCD067EAA
func pFNQueueBindSparseCD067EAA(cQueue C.VkQueue, cBindInfoCount C.uint32_t, cPBindInfo *C.VkBindSparseInfo, cFence C.VkFence) C.VkResult {
	if pFNQueueBindSparseCD067EAAFunc != nil {
		Queuecd067eaa := *(*Queue)(unsafe.Pointer(&cQueue))
		BindInfoCountcd067eaa := (uint32)(cBindInfoCount)
		var PBindInfocd067eaa []BindSparseInfo
		packSBindSparseInfo(PBindInfocd067eaa, cPBindInfo)
		Fencecd067eaa := *(*Fence)(unsafe.Pointer(&cFence))
		retcd067eaa := pFNQueueBindSparseCD067EAAFunc(Queuecd067eaa, BindInfoCountcd067eaa, PBindInfocd067eaa, Fencecd067eaa)
		ret, _ := (C.VkResult)(retcd067eaa), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNQueueBindSparseCD067EAAFunc PFNQueueBindSparse

// packSFenceCreateInfo reads sliced Go data structure out from plain C format.
func packSFenceCreateInfo(v []FenceCreateInfo, ptr0 *C.VkFenceCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFenceCreateInfoValue]C.VkFenceCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFenceCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateFence) PassRef() (ref *C.PFN_vkCreateFence, allocs *cgoAllocMap) {
	if pFNCreateFenceF6662003Func == nil {
		pFNCreateFenceF6662003Func = x
	}
	return (*C.PFN_vkCreateFence)(C.PFN_vkCreateFence_f6662003), nil
}

// PassValue returns a value.
func (x PFNCreateFence) PassValue() (ref C.PFN_vkCreateFence, allocs *cgoAllocMap) {
	if pFNCreateFenceF6662003Func == nil {
		pFNCreateFenceF6662003Func = x
	}
	return (C.PFN_vkCreateFence)(C.PFN_vkCreateFence_f6662003), nil
}

//export pFNCreateFenceF6662003
func pFNCreateFenceF6662003(cDevice C.VkDevice, cPCreateInfo *C.VkFenceCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPFence *C.VkFence) C.VkResult {
	if pFNCreateFenceF6662003Func != nil {
		Devicef6662003 := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfof6662003 []FenceCreateInfo
		packSFenceCreateInfo(PCreateInfof6662003, cPCreateInfo)
		var PAllocatorf6662003 []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorf6662003, cPAllocator)
		var PFencef6662003 []Fence
		hxf09ea94 := (*sliceHeader)(unsafe.Pointer(&PFencef6662003))
		hxf09ea94.Data = uintptr(unsafe.Pointer(cPFence))
		hxf09ea94.Cap = 0x7fffffff
		// hxf09ea94.Len = ?

		retf6662003 := pFNCreateFenceF6662003Func(Devicef6662003, PCreateInfof6662003, PAllocatorf6662003, PFencef6662003)
		ret, _ := (C.VkResult)(retf6662003), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateFenceF6662003Func PFNCreateFence

// PassRef returns a reference.
func (x PFNDestroyFence) PassRef() (ref *C.PFN_vkDestroyFence, allocs *cgoAllocMap) {
	if pFNDestroyFenceD1468627Func == nil {
		pFNDestroyFenceD1468627Func = x
	}
	return (*C.PFN_vkDestroyFence)(C.PFN_vkDestroyFence_d1468627), nil
}

// PassValue returns a value.
func (x PFNDestroyFence) PassValue() (ref C.PFN_vkDestroyFence, allocs *cgoAllocMap) {
	if pFNDestroyFenceD1468627Func == nil {
		pFNDestroyFenceD1468627Func = x
	}
	return (C.PFN_vkDestroyFence)(C.PFN_vkDestroyFence_d1468627), nil
}

//export pFNDestroyFenceD1468627
func pFNDestroyFenceD1468627(cDevice C.VkDevice, cFence C.VkFence, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyFenceD1468627Func != nil {
		Deviced1468627 := *(*Device)(unsafe.Pointer(&cDevice))
		Fenced1468627 := *(*Fence)(unsafe.Pointer(&cFence))
		var PAllocatord1468627 []AllocationCallbacks
		packSAllocationCallbacks(PAllocatord1468627, cPAllocator)
		pFNDestroyFenceD1468627Func(Deviced1468627, Fenced1468627, PAllocatord1468627)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyFenceD1468627Func PFNDestroyFence

// PassRef returns a reference.
func (x PFNResetFences) PassRef() (ref *C.PFN_vkResetFences, allocs *cgoAllocMap) {
	if pFNResetFences7DF2B051Func == nil {
		pFNResetFences7DF2B051Func = x
	}
	return (*C.PFN_vkResetFences)(C.PFN_vkResetFences_7df2b051), nil
}

// PassValue returns a value.
func (x PFNResetFences) PassValue() (ref C.PFN_vkResetFences, allocs *cgoAllocMap) {
	if pFNResetFences7DF2B051Func == nil {
		pFNResetFences7DF2B051Func = x
	}
	return (C.PFN_vkResetFences)(C.PFN_vkResetFences_7df2b051), nil
}

//export pFNResetFences7DF2B051
func pFNResetFences7DF2B051(cDevice C.VkDevice, cFenceCount C.uint32_t, cPFences *C.VkFence) C.VkResult {
	if pFNResetFences7DF2B051Func != nil {
		Device7df2b051 := *(*Device)(unsafe.Pointer(&cDevice))
		FenceCount7df2b051 := (uint32)(cFenceCount)
		var PFences7df2b051 []Fence
		hxfd687ee := (*sliceHeader)(unsafe.Pointer(&PFences7df2b051))
		hxfd687ee.Data = uintptr(unsafe.Pointer(cPFences))
		hxfd687ee.Cap = 0x7fffffff
		// hxfd687ee.Len = ?

		ret7df2b051 := pFNResetFences7DF2B051Func(Device7df2b051, FenceCount7df2b051, PFences7df2b051)
		ret, _ := (C.VkResult)(ret7df2b051), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNResetFences7DF2B051Func PFNResetFences

// PassRef returns a reference.
func (x PFNGetFenceStatus) PassRef() (ref *C.PFN_vkGetFenceStatus, allocs *cgoAllocMap) {
	if pFNGetFenceStatusF2C52E1AFunc == nil {
		pFNGetFenceStatusF2C52E1AFunc = x
	}
	return (*C.PFN_vkGetFenceStatus)(C.PFN_vkGetFenceStatus_f2c52e1a), nil
}

// PassValue returns a value.
func (x PFNGetFenceStatus) PassValue() (ref C.PFN_vkGetFenceStatus, allocs *cgoAllocMap) {
	if pFNGetFenceStatusF2C52E1AFunc == nil {
		pFNGetFenceStatusF2C52E1AFunc = x
	}
	return (C.PFN_vkGetFenceStatus)(C.PFN_vkGetFenceStatus_f2c52e1a), nil
}

//export pFNGetFenceStatusF2C52E1A
func pFNGetFenceStatusF2C52E1A(cDevice C.VkDevice, cFence C.VkFence) C.VkResult {
	if pFNGetFenceStatusF2C52E1AFunc != nil {
		Devicef2c52e1a := *(*Device)(unsafe.Pointer(&cDevice))
		Fencef2c52e1a := *(*Fence)(unsafe.Pointer(&cFence))
		retf2c52e1a := pFNGetFenceStatusF2C52E1AFunc(Devicef2c52e1a, Fencef2c52e1a)
		ret, _ := (C.VkResult)(retf2c52e1a), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNGetFenceStatusF2C52E1AFunc PFNGetFenceStatus

// PassRef returns a reference.
func (x PFNWaitForFences) PassRef() (ref *C.PFN_vkWaitForFences, allocs *cgoAllocMap) {
	if pFNWaitForFences899D94E6Func == nil {
		pFNWaitForFences899D94E6Func = x
	}
	return (*C.PFN_vkWaitForFences)(C.PFN_vkWaitForFences_899d94e6), nil
}

// PassValue returns a value.
func (x PFNWaitForFences) PassValue() (ref C.PFN_vkWaitForFences, allocs *cgoAllocMap) {
	if pFNWaitForFences899D94E6Func == nil {
		pFNWaitForFences899D94E6Func = x
	}
	return (C.PFN_vkWaitForFences)(C.PFN_vkWaitForFences_899d94e6), nil
}

//export pFNWaitForFences899D94E6
func pFNWaitForFences899D94E6(cDevice C.VkDevice, cFenceCount C.uint32_t, cPFences *C.VkFence, cWaitAll C.VkBool32, cTimeout C.uint64_t) C.VkResult {
	if pFNWaitForFences899D94E6Func != nil {
		Device899d94e6 := *(*Device)(unsafe.Pointer(&cDevice))
		FenceCount899d94e6 := (uint32)(cFenceCount)
		var PFences899d94e6 []Fence
		hxf15a567 := (*sliceHeader)(unsafe.Pointer(&PFences899d94e6))
		hxf15a567.Data = uintptr(unsafe.Pointer(cPFences))
		hxf15a567.Cap = 0x7fffffff
		// hxf15a567.Len = ?

		WaitAll899d94e6 := (Bool32)(cWaitAll)
		Timeout899d94e6 := (uint64)(cTimeout)
		ret899d94e6 := pFNWaitForFences899D94E6Func(Device899d94e6, FenceCount899d94e6, PFences899d94e6, WaitAll899d94e6, Timeout899d94e6)
		ret, _ := (C.VkResult)(ret899d94e6), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNWaitForFences899D94E6Func PFNWaitForFences

// packSSemaphoreCreateInfo reads sliced Go data structure out from plain C format.
func packSSemaphoreCreateInfo(v []SemaphoreCreateInfo, ptr0 *C.VkSemaphoreCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSemaphoreCreateInfoValue]C.VkSemaphoreCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSemaphoreCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateSemaphore) PassRef() (ref *C.PFN_vkCreateSemaphore, allocs *cgoAllocMap) {
	if pFNCreateSemaphoreC37AD412Func == nil {
		pFNCreateSemaphoreC37AD412Func = x
	}
	return (*C.PFN_vkCreateSemaphore)(C.PFN_vkCreateSemaphore_c37ad412), nil
}

// PassValue returns a value.
func (x PFNCreateSemaphore) PassValue() (ref C.PFN_vkCreateSemaphore, allocs *cgoAllocMap) {
	if pFNCreateSemaphoreC37AD412Func == nil {
		pFNCreateSemaphoreC37AD412Func = x
	}
	return (C.PFN_vkCreateSemaphore)(C.PFN_vkCreateSemaphore_c37ad412), nil
}

//export pFNCreateSemaphoreC37AD412
func pFNCreateSemaphoreC37AD412(cDevice C.VkDevice, cPCreateInfo *C.VkSemaphoreCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPSemaphore *C.VkSemaphore) C.VkResult {
	if pFNCreateSemaphoreC37AD412Func != nil {
		Devicec37ad412 := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfoc37ad412 []SemaphoreCreateInfo
		packSSemaphoreCreateInfo(PCreateInfoc37ad412, cPCreateInfo)
		var PAllocatorc37ad412 []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorc37ad412, cPAllocator)
		var PSemaphorec37ad412 []Semaphore
		hxf8aebb5 := (*sliceHeader)(unsafe.Pointer(&PSemaphorec37ad412))
		hxf8aebb5.Data = uintptr(unsafe.Pointer(cPSemaphore))
		hxf8aebb5.Cap = 0x7fffffff
		// hxf8aebb5.Len = ?

		retc37ad412 := pFNCreateSemaphoreC37AD412Func(Devicec37ad412, PCreateInfoc37ad412, PAllocatorc37ad412, PSemaphorec37ad412)
		ret, _ := (C.VkResult)(retc37ad412), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateSemaphoreC37AD412Func PFNCreateSemaphore

// PassRef returns a reference.
func (x PFNDestroySemaphore) PassRef() (ref *C.PFN_vkDestroySemaphore, allocs *cgoAllocMap) {
	if pFNDestroySemaphore1515C60Func == nil {
		pFNDestroySemaphore1515C60Func = x
	}
	return (*C.PFN_vkDestroySemaphore)(C.PFN_vkDestroySemaphore_1515c60), nil
}

// PassValue returns a value.
func (x PFNDestroySemaphore) PassValue() (ref C.PFN_vkDestroySemaphore, allocs *cgoAllocMap) {
	if pFNDestroySemaphore1515C60Func == nil {
		pFNDestroySemaphore1515C60Func = x
	}
	return (C.PFN_vkDestroySemaphore)(C.PFN_vkDestroySemaphore_1515c60), nil
}

//export pFNDestroySemaphore1515C60
func pFNDestroySemaphore1515C60(cDevice C.VkDevice, cSemaphore C.VkSemaphore, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroySemaphore1515C60Func != nil {
		Device1515c60 := *(*Device)(unsafe.Pointer(&cDevice))
		Semaphore1515c60 := *(*Semaphore)(unsafe.Pointer(&cSemaphore))
		var PAllocator1515c60 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator1515c60, cPAllocator)
		pFNDestroySemaphore1515C60Func(Device1515c60, Semaphore1515c60, PAllocator1515c60)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroySemaphore1515C60Func PFNDestroySemaphore

// packSEventCreateInfo reads sliced Go data structure out from plain C format.
func packSEventCreateInfo(v []EventCreateInfo, ptr0 *C.VkEventCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfEventCreateInfoValue]C.VkEventCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewEventCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateEvent) PassRef() (ref *C.PFN_vkCreateEvent, allocs *cgoAllocMap) {
	if pFNCreateEvent202113FCFunc == nil {
		pFNCreateEvent202113FCFunc = x
	}
	return (*C.PFN_vkCreateEvent)(C.PFN_vkCreateEvent_202113fc), nil
}

// PassValue returns a value.
func (x PFNCreateEvent) PassValue() (ref C.PFN_vkCreateEvent, allocs *cgoAllocMap) {
	if pFNCreateEvent202113FCFunc == nil {
		pFNCreateEvent202113FCFunc = x
	}
	return (C.PFN_vkCreateEvent)(C.PFN_vkCreateEvent_202113fc), nil
}

//export pFNCreateEvent202113FC
func pFNCreateEvent202113FC(cDevice C.VkDevice, cPCreateInfo *C.VkEventCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPEvent *C.VkEvent) C.VkResult {
	if pFNCreateEvent202113FCFunc != nil {
		Device202113fc := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfo202113fc []EventCreateInfo
		packSEventCreateInfo(PCreateInfo202113fc, cPCreateInfo)
		var PAllocator202113fc []AllocationCallbacks
		packSAllocationCallbacks(PAllocator202113fc, cPAllocator)
		var PEvent202113fc []Event
		hxf5d30cf := (*sliceHeader)(unsafe.Pointer(&PEvent202113fc))
		hxf5d30cf.Data = uintptr(unsafe.Pointer(cPEvent))
		hxf5d30cf.Cap = 0x7fffffff
		// hxf5d30cf.Len = ?

		ret202113fc := pFNCreateEvent202113FCFunc(Device202113fc, PCreateInfo202113fc, PAllocator202113fc, PEvent202113fc)
		ret, _ := (C.VkResult)(ret202113fc), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateEvent202113FCFunc PFNCreateEvent

// PassRef returns a reference.
func (x PFNDestroyEvent) PassRef() (ref *C.PFN_vkDestroyEvent, allocs *cgoAllocMap) {
	if pFNDestroyEvent701B5D8Func == nil {
		pFNDestroyEvent701B5D8Func = x
	}
	return (*C.PFN_vkDestroyEvent)(C.PFN_vkDestroyEvent_701b5d8), nil
}

// PassValue returns a value.
func (x PFNDestroyEvent) PassValue() (ref C.PFN_vkDestroyEvent, allocs *cgoAllocMap) {
	if pFNDestroyEvent701B5D8Func == nil {
		pFNDestroyEvent701B5D8Func = x
	}
	return (C.PFN_vkDestroyEvent)(C.PFN_vkDestroyEvent_701b5d8), nil
}

//export pFNDestroyEvent701B5D8
func pFNDestroyEvent701B5D8(cDevice C.VkDevice, cEvent C.VkEvent, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyEvent701B5D8Func != nil {
		Device701b5d8 := *(*Device)(unsafe.Pointer(&cDevice))
		Event701b5d8 := *(*Event)(unsafe.Pointer(&cEvent))
		var PAllocator701b5d8 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator701b5d8, cPAllocator)
		pFNDestroyEvent701B5D8Func(Device701b5d8, Event701b5d8, PAllocator701b5d8)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyEvent701B5D8Func PFNDestroyEvent

// PassRef returns a reference.
func (x PFNGetEventStatus) PassRef() (ref *C.PFN_vkGetEventStatus, allocs *cgoAllocMap) {
	if pFNGetEventStatus7F476E86Func == nil {
		pFNGetEventStatus7F476E86Func = x
	}
	return (*C.PFN_vkGetEventStatus)(C.PFN_vkGetEventStatus_7f476e86), nil
}

// PassValue returns a value.
func (x PFNGetEventStatus) PassValue() (ref C.PFN_vkGetEventStatus, allocs *cgoAllocMap) {
	if pFNGetEventStatus7F476E86Func == nil {
		pFNGetEventStatus7F476E86Func = x
	}
	return (C.PFN_vkGetEventStatus)(C.PFN_vkGetEventStatus_7f476e86), nil
}

//export pFNGetEventStatus7F476E86
func pFNGetEventStatus7F476E86(cDevice C.VkDevice, cEvent C.VkEvent) C.VkResult {
	if pFNGetEventStatus7F476E86Func != nil {
		Device7f476e86 := *(*Device)(unsafe.Pointer(&cDevice))
		Event7f476e86 := *(*Event)(unsafe.Pointer(&cEvent))
		ret7f476e86 := pFNGetEventStatus7F476E86Func(Device7f476e86, Event7f476e86)
		ret, _ := (C.VkResult)(ret7f476e86), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNGetEventStatus7F476E86Func PFNGetEventStatus

// PassRef returns a reference.
func (x PFNSetEvent) PassRef() (ref *C.PFN_vkSetEvent, allocs *cgoAllocMap) {
	if pFNSetEvent52745188Func == nil {
		pFNSetEvent52745188Func = x
	}
	return (*C.PFN_vkSetEvent)(C.PFN_vkSetEvent_52745188), nil
}

// PassValue returns a value.
func (x PFNSetEvent) PassValue() (ref C.PFN_vkSetEvent, allocs *cgoAllocMap) {
	if pFNSetEvent52745188Func == nil {
		pFNSetEvent52745188Func = x
	}
	return (C.PFN_vkSetEvent)(C.PFN_vkSetEvent_52745188), nil
}

//export pFNSetEvent52745188
func pFNSetEvent52745188(cDevice C.VkDevice, cEvent C.VkEvent) C.VkResult {
	if pFNSetEvent52745188Func != nil {
		Device52745188 := *(*Device)(unsafe.Pointer(&cDevice))
		Event52745188 := *(*Event)(unsafe.Pointer(&cEvent))
		ret52745188 := pFNSetEvent52745188Func(Device52745188, Event52745188)
		ret, _ := (C.VkResult)(ret52745188), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNSetEvent52745188Func PFNSetEvent

// PassRef returns a reference.
func (x PFNResetEvent) PassRef() (ref *C.PFN_vkResetEvent, allocs *cgoAllocMap) {
	if pFNResetEvent2C03A325Func == nil {
		pFNResetEvent2C03A325Func = x
	}
	return (*C.PFN_vkResetEvent)(C.PFN_vkResetEvent_2c03a325), nil
}

// PassValue returns a value.
func (x PFNResetEvent) PassValue() (ref C.PFN_vkResetEvent, allocs *cgoAllocMap) {
	if pFNResetEvent2C03A325Func == nil {
		pFNResetEvent2C03A325Func = x
	}
	return (C.PFN_vkResetEvent)(C.PFN_vkResetEvent_2c03a325), nil
}

//export pFNResetEvent2C03A325
func pFNResetEvent2C03A325(cDevice C.VkDevice, cEvent C.VkEvent) C.VkResult {
	if pFNResetEvent2C03A325Func != nil {
		Device2c03a325 := *(*Device)(unsafe.Pointer(&cDevice))
		Event2c03a325 := *(*Event)(unsafe.Pointer(&cEvent))
		ret2c03a325 := pFNResetEvent2C03A325Func(Device2c03a325, Event2c03a325)
		ret, _ := (C.VkResult)(ret2c03a325), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNResetEvent2C03A325Func PFNResetEvent

// packSQueryPoolCreateInfo reads sliced Go data structure out from plain C format.
func packSQueryPoolCreateInfo(v []QueryPoolCreateInfo, ptr0 *C.VkQueryPoolCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfQueryPoolCreateInfoValue]C.VkQueryPoolCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewQueryPoolCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateQueryPool) PassRef() (ref *C.PFN_vkCreateQueryPool, allocs *cgoAllocMap) {
	if pFNCreateQueryPool99A5956AFunc == nil {
		pFNCreateQueryPool99A5956AFunc = x
	}
	return (*C.PFN_vkCreateQueryPool)(C.PFN_vkCreateQueryPool_99a5956a), nil
}

// PassValue returns a value.
func (x PFNCreateQueryPool) PassValue() (ref C.PFN_vkCreateQueryPool, allocs *cgoAllocMap) {
	if pFNCreateQueryPool99A5956AFunc == nil {
		pFNCreateQueryPool99A5956AFunc = x
	}
	return (C.PFN_vkCreateQueryPool)(C.PFN_vkCreateQueryPool_99a5956a), nil
}

//export pFNCreateQueryPool99A5956A
func pFNCreateQueryPool99A5956A(cDevice C.VkDevice, cPCreateInfo *C.VkQueryPoolCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPQueryPool *C.VkQueryPool) C.VkResult {
	if pFNCreateQueryPool99A5956AFunc != nil {
		Device99a5956a := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfo99a5956a []QueryPoolCreateInfo
		packSQueryPoolCreateInfo(PCreateInfo99a5956a, cPCreateInfo)
		var PAllocator99a5956a []AllocationCallbacks
		packSAllocationCallbacks(PAllocator99a5956a, cPAllocator)
		var PQueryPool99a5956a []QueryPool
		hxf882e98 := (*sliceHeader)(unsafe.Pointer(&PQueryPool99a5956a))
		hxf882e98.Data = uintptr(unsafe.Pointer(cPQueryPool))
		hxf882e98.Cap = 0x7fffffff
		// hxf882e98.Len = ?

		ret99a5956a := pFNCreateQueryPool99A5956AFunc(Device99a5956a, PCreateInfo99a5956a, PAllocator99a5956a, PQueryPool99a5956a)
		ret, _ := (C.VkResult)(ret99a5956a), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateQueryPool99A5956AFunc PFNCreateQueryPool

// PassRef returns a reference.
func (x PFNDestroyQueryPool) PassRef() (ref *C.PFN_vkDestroyQueryPool, allocs *cgoAllocMap) {
	if pFNDestroyQueryPool5B8E1D18Func == nil {
		pFNDestroyQueryPool5B8E1D18Func = x
	}
	return (*C.PFN_vkDestroyQueryPool)(C.PFN_vkDestroyQueryPool_5b8e1d18), nil
}

// PassValue returns a value.
func (x PFNDestroyQueryPool) PassValue() (ref C.PFN_vkDestroyQueryPool, allocs *cgoAllocMap) {
	if pFNDestroyQueryPool5B8E1D18Func == nil {
		pFNDestroyQueryPool5B8E1D18Func = x
	}
	return (C.PFN_vkDestroyQueryPool)(C.PFN_vkDestroyQueryPool_5b8e1d18), nil
}

//export pFNDestroyQueryPool5B8E1D18
func pFNDestroyQueryPool5B8E1D18(cDevice C.VkDevice, cQueryPool C.VkQueryPool, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyQueryPool5B8E1D18Func != nil {
		Device5b8e1d18 := *(*Device)(unsafe.Pointer(&cDevice))
		QueryPool5b8e1d18 := *(*QueryPool)(unsafe.Pointer(&cQueryPool))
		var PAllocator5b8e1d18 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator5b8e1d18, cPAllocator)
		pFNDestroyQueryPool5B8E1D18Func(Device5b8e1d18, QueryPool5b8e1d18, PAllocator5b8e1d18)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyQueryPool5B8E1D18Func PFNDestroyQueryPool

// PassRef returns a reference.
func (x PFNGetQueryPoolResults) PassRef() (ref *C.PFN_vkGetQueryPoolResults, allocs *cgoAllocMap) {
	if pFNGetQueryPoolResultsB2D2A5CBFunc == nil {
		pFNGetQueryPoolResultsB2D2A5CBFunc = x
	}
	return (*C.PFN_vkGetQueryPoolResults)(C.PFN_vkGetQueryPoolResults_b2d2a5cb), nil
}

// PassValue returns a value.
func (x PFNGetQueryPoolResults) PassValue() (ref C.PFN_vkGetQueryPoolResults, allocs *cgoAllocMap) {
	if pFNGetQueryPoolResultsB2D2A5CBFunc == nil {
		pFNGetQueryPoolResultsB2D2A5CBFunc = x
	}
	return (C.PFN_vkGetQueryPoolResults)(C.PFN_vkGetQueryPoolResults_b2d2a5cb), nil
}

//export pFNGetQueryPoolResultsB2D2A5CB
func pFNGetQueryPoolResultsB2D2A5CB(cDevice C.VkDevice, cQueryPool C.VkQueryPool, cFirstQuery C.uint32_t, cQueryCount C.uint32_t, cDataSize C.size_t, cPData unsafe.Pointer, cStride C.VkDeviceSize, cFlags C.VkQueryResultFlags) C.VkResult {
	if pFNGetQueryPoolResultsB2D2A5CBFunc != nil {
		Deviceb2d2a5cb := *(*Device)(unsafe.Pointer(&cDevice))
		QueryPoolb2d2a5cb := *(*QueryPool)(unsafe.Pointer(&cQueryPool))
		FirstQueryb2d2a5cb := (uint32)(cFirstQuery)
		QueryCountb2d2a5cb := (uint32)(cQueryCount)
		DataSizeb2d2a5cb := (uint)(cDataSize)
		PDatab2d2a5cb := (unsafe.Pointer)(unsafe.Pointer(cPData))
		Strideb2d2a5cb := (DeviceSize)(cStride)
		Flagsb2d2a5cb := (QueryResultFlags)(cFlags)
		retb2d2a5cb := pFNGetQueryPoolResultsB2D2A5CBFunc(Deviceb2d2a5cb, QueryPoolb2d2a5cb, FirstQueryb2d2a5cb, QueryCountb2d2a5cb, DataSizeb2d2a5cb, PDatab2d2a5cb, Strideb2d2a5cb, Flagsb2d2a5cb)
		ret, _ := (C.VkResult)(retb2d2a5cb), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNGetQueryPoolResultsB2D2A5CBFunc PFNGetQueryPoolResults

// packSBufferCreateInfo reads sliced Go data structure out from plain C format.
func packSBufferCreateInfo(v []BufferCreateInfo, ptr0 *C.VkBufferCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferCreateInfoValue]C.VkBufferCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateBuffer) PassRef() (ref *C.PFN_vkCreateBuffer, allocs *cgoAllocMap) {
	if pFNCreateBufferCDF8F797Func == nil {
		pFNCreateBufferCDF8F797Func = x
	}
	return (*C.PFN_vkCreateBuffer)(C.PFN_vkCreateBuffer_cdf8f797), nil
}

// PassValue returns a value.
func (x PFNCreateBuffer) PassValue() (ref C.PFN_vkCreateBuffer, allocs *cgoAllocMap) {
	if pFNCreateBufferCDF8F797Func == nil {
		pFNCreateBufferCDF8F797Func = x
	}
	return (C.PFN_vkCreateBuffer)(C.PFN_vkCreateBuffer_cdf8f797), nil
}

//export pFNCreateBufferCDF8F797
func pFNCreateBufferCDF8F797(cDevice C.VkDevice, cPCreateInfo *C.VkBufferCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPBuffer *C.VkBuffer) C.VkResult {
	if pFNCreateBufferCDF8F797Func != nil {
		Devicecdf8f797 := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfocdf8f797 []BufferCreateInfo
		packSBufferCreateInfo(PCreateInfocdf8f797, cPCreateInfo)
		var PAllocatorcdf8f797 []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorcdf8f797, cPAllocator)
		var PBuffercdf8f797 []Buffer
		hxf992404 := (*sliceHeader)(unsafe.Pointer(&PBuffercdf8f797))
		hxf992404.Data = uintptr(unsafe.Pointer(cPBuffer))
		hxf992404.Cap = 0x7fffffff
		// hxf992404.Len = ?

		retcdf8f797 := pFNCreateBufferCDF8F797Func(Devicecdf8f797, PCreateInfocdf8f797, PAllocatorcdf8f797, PBuffercdf8f797)
		ret, _ := (C.VkResult)(retcdf8f797), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateBufferCDF8F797Func PFNCreateBuffer

// PassRef returns a reference.
func (x PFNDestroyBuffer) PassRef() (ref *C.PFN_vkDestroyBuffer, allocs *cgoAllocMap) {
	if pFNDestroyBufferF1DC33E0Func == nil {
		pFNDestroyBufferF1DC33E0Func = x
	}
	return (*C.PFN_vkDestroyBuffer)(C.PFN_vkDestroyBuffer_f1dc33e0), nil
}

// PassValue returns a value.
func (x PFNDestroyBuffer) PassValue() (ref C.PFN_vkDestroyBuffer, allocs *cgoAllocMap) {
	if pFNDestroyBufferF1DC33E0Func == nil {
		pFNDestroyBufferF1DC33E0Func = x
	}
	return (C.PFN_vkDestroyBuffer)(C.PFN_vkDestroyBuffer_f1dc33e0), nil
}

//export pFNDestroyBufferF1DC33E0
func pFNDestroyBufferF1DC33E0(cDevice C.VkDevice, cBuffer C.VkBuffer, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyBufferF1DC33E0Func != nil {
		Devicef1dc33e0 := *(*Device)(unsafe.Pointer(&cDevice))
		Bufferf1dc33e0 := *(*Buffer)(unsafe.Pointer(&cBuffer))
		var PAllocatorf1dc33e0 []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorf1dc33e0, cPAllocator)
		pFNDestroyBufferF1DC33E0Func(Devicef1dc33e0, Bufferf1dc33e0, PAllocatorf1dc33e0)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyBufferF1DC33E0Func PFNDestroyBuffer

// packSBufferViewCreateInfo reads sliced Go data structure out from plain C format.
func packSBufferViewCreateInfo(v []BufferViewCreateInfo, ptr0 *C.VkBufferViewCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferViewCreateInfoValue]C.VkBufferViewCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferViewCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateBufferView) PassRef() (ref *C.PFN_vkCreateBufferView, allocs *cgoAllocMap) {
	if pFNCreateBufferViewF7636D40Func == nil {
		pFNCreateBufferViewF7636D40Func = x
	}
	return (*C.PFN_vkCreateBufferView)(C.PFN_vkCreateBufferView_f7636d40), nil
}

// PassValue returns a value.
func (x PFNCreateBufferView) PassValue() (ref C.PFN_vkCreateBufferView, allocs *cgoAllocMap) {
	if pFNCreateBufferViewF7636D40Func == nil {
		pFNCreateBufferViewF7636D40Func = x
	}
	return (C.PFN_vkCreateBufferView)(C.PFN_vkCreateBufferView_f7636d40), nil
}

//export pFNCreateBufferViewF7636D40
func pFNCreateBufferViewF7636D40(cDevice C.VkDevice, cPCreateInfo *C.VkBufferViewCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPView *C.VkBufferView) C.VkResult {
	if pFNCreateBufferViewF7636D40Func != nil {
		Devicef7636d40 := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfof7636d40 []BufferViewCreateInfo
		packSBufferViewCreateInfo(PCreateInfof7636d40, cPCreateInfo)
		var PAllocatorf7636d40 []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorf7636d40, cPAllocator)
		var PViewf7636d40 []BufferView
		hxf8e0dd2 := (*sliceHeader)(unsafe.Pointer(&PViewf7636d40))
		hxf8e0dd2.Data = uintptr(unsafe.Pointer(cPView))
		hxf8e0dd2.Cap = 0x7fffffff
		// hxf8e0dd2.Len = ?

		retf7636d40 := pFNCreateBufferViewF7636D40Func(Devicef7636d40, PCreateInfof7636d40, PAllocatorf7636d40, PViewf7636d40)
		ret, _ := (C.VkResult)(retf7636d40), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateBufferViewF7636D40Func PFNCreateBufferView

// PassRef returns a reference.
func (x PFNDestroyBufferView) PassRef() (ref *C.PFN_vkDestroyBufferView, allocs *cgoAllocMap) {
	if pFNDestroyBufferView49AA56D8Func == nil {
		pFNDestroyBufferView49AA56D8Func = x
	}
	return (*C.PFN_vkDestroyBufferView)(C.PFN_vkDestroyBufferView_49aa56d8), nil
}

// PassValue returns a value.
func (x PFNDestroyBufferView) PassValue() (ref C.PFN_vkDestroyBufferView, allocs *cgoAllocMap) {
	if pFNDestroyBufferView49AA56D8Func == nil {
		pFNDestroyBufferView49AA56D8Func = x
	}
	return (C.PFN_vkDestroyBufferView)(C.PFN_vkDestroyBufferView_49aa56d8), nil
}

//export pFNDestroyBufferView49AA56D8
func pFNDestroyBufferView49AA56D8(cDevice C.VkDevice, cBufferView C.VkBufferView, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyBufferView49AA56D8Func != nil {
		Device49aa56d8 := *(*Device)(unsafe.Pointer(&cDevice))
		BufferView49aa56d8 := *(*BufferView)(unsafe.Pointer(&cBufferView))
		var PAllocator49aa56d8 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator49aa56d8, cPAllocator)
		pFNDestroyBufferView49AA56D8Func(Device49aa56d8, BufferView49aa56d8, PAllocator49aa56d8)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyBufferView49AA56D8Func PFNDestroyBufferView

// packSImageCreateInfo reads sliced Go data structure out from plain C format.
func packSImageCreateInfo(v []ImageCreateInfo, ptr0 *C.VkImageCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageCreateInfoValue]C.VkImageCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateImage) PassRef() (ref *C.PFN_vkCreateImage, allocs *cgoAllocMap) {
	if pFNCreateImageDEB21D04Func == nil {
		pFNCreateImageDEB21D04Func = x
	}
	return (*C.PFN_vkCreateImage)(C.PFN_vkCreateImage_deb21d04), nil
}

// PassValue returns a value.
func (x PFNCreateImage) PassValue() (ref C.PFN_vkCreateImage, allocs *cgoAllocMap) {
	if pFNCreateImageDEB21D04Func == nil {
		pFNCreateImageDEB21D04Func = x
	}
	return (C.PFN_vkCreateImage)(C.PFN_vkCreateImage_deb21d04), nil
}

//export pFNCreateImageDEB21D04
func pFNCreateImageDEB21D04(cDevice C.VkDevice, cPCreateInfo *C.VkImageCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPImage *C.VkImage) C.VkResult {
	if pFNCreateImageDEB21D04Func != nil {
		Devicedeb21d04 := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfodeb21d04 []ImageCreateInfo
		packSImageCreateInfo(PCreateInfodeb21d04, cPCreateInfo)
		var PAllocatordeb21d04 []AllocationCallbacks
		packSAllocationCallbacks(PAllocatordeb21d04, cPAllocator)
		var PImagedeb21d04 []Image
		hxf44d909 := (*sliceHeader)(unsafe.Pointer(&PImagedeb21d04))
		hxf44d909.Data = uintptr(unsafe.Pointer(cPImage))
		hxf44d909.Cap = 0x7fffffff
		// hxf44d909.Len = ?

		retdeb21d04 := pFNCreateImageDEB21D04Func(Devicedeb21d04, PCreateInfodeb21d04, PAllocatordeb21d04, PImagedeb21d04)
		ret, _ := (C.VkResult)(retdeb21d04), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateImageDEB21D04Func PFNCreateImage

// PassRef returns a reference.
func (x PFNDestroyImage) PassRef() (ref *C.PFN_vkDestroyImage, allocs *cgoAllocMap) {
	if pFNDestroyImageF992BB20Func == nil {
		pFNDestroyImageF992BB20Func = x
	}
	return (*C.PFN_vkDestroyImage)(C.PFN_vkDestroyImage_f992bb20), nil
}

// PassValue returns a value.
func (x PFNDestroyImage) PassValue() (ref C.PFN_vkDestroyImage, allocs *cgoAllocMap) {
	if pFNDestroyImageF992BB20Func == nil {
		pFNDestroyImageF992BB20Func = x
	}
	return (C.PFN_vkDestroyImage)(C.PFN_vkDestroyImage_f992bb20), nil
}

//export pFNDestroyImageF992BB20
func pFNDestroyImageF992BB20(cDevice C.VkDevice, cImage C.VkImage, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyImageF992BB20Func != nil {
		Devicef992bb20 := *(*Device)(unsafe.Pointer(&cDevice))
		Imagef992bb20 := *(*Image)(unsafe.Pointer(&cImage))
		var PAllocatorf992bb20 []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorf992bb20, cPAllocator)
		pFNDestroyImageF992BB20Func(Devicef992bb20, Imagef992bb20, PAllocatorf992bb20)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyImageF992BB20Func PFNDestroyImage

// packSImageSubresource reads sliced Go data structure out from plain C format.
func packSImageSubresource(v []ImageSubresource, ptr0 *C.VkImageSubresource) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageSubresourceValue]C.VkImageSubresource)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageSubresourceRef(&ptr1)
	}
}

// packSSubresourceLayout reads sliced Go data structure out from plain C format.
func packSSubresourceLayout(v []SubresourceLayout, ptr0 *C.VkSubresourceLayout) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubresourceLayoutValue]C.VkSubresourceLayout)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubresourceLayoutRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetImageSubresourceLayout) PassRef() (ref *C.PFN_vkGetImageSubresourceLayout, allocs *cgoAllocMap) {
	if pFNGetImageSubresourceLayoutA0BCFD9DFunc == nil {
		pFNGetImageSubresourceLayoutA0BCFD9DFunc = x
	}
	return (*C.PFN_vkGetImageSubresourceLayout)(C.PFN_vkGetImageSubresourceLayout_a0bcfd9d), nil
}

// PassValue returns a value.
func (x PFNGetImageSubresourceLayout) PassValue() (ref C.PFN_vkGetImageSubresourceLayout, allocs *cgoAllocMap) {
	if pFNGetImageSubresourceLayoutA0BCFD9DFunc == nil {
		pFNGetImageSubresourceLayoutA0BCFD9DFunc = x
	}
	return (C.PFN_vkGetImageSubresourceLayout)(C.PFN_vkGetImageSubresourceLayout_a0bcfd9d), nil
}

//export pFNGetImageSubresourceLayoutA0BCFD9D
func pFNGetImageSubresourceLayoutA0BCFD9D(cDevice C.VkDevice, cImage C.VkImage, cPSubresource *C.VkImageSubresource, cPLayout *C.VkSubresourceLayout) {
	if pFNGetImageSubresourceLayoutA0BCFD9DFunc != nil {
		Devicea0bcfd9d := *(*Device)(unsafe.Pointer(&cDevice))
		Imagea0bcfd9d := *(*Image)(unsafe.Pointer(&cImage))
		var PSubresourcea0bcfd9d []ImageSubresource
		packSImageSubresource(PSubresourcea0bcfd9d, cPSubresource)
		var PLayouta0bcfd9d []SubresourceLayout
		packSSubresourceLayout(PLayouta0bcfd9d, cPLayout)
		pFNGetImageSubresourceLayoutA0BCFD9DFunc(Devicea0bcfd9d, Imagea0bcfd9d, PSubresourcea0bcfd9d, PLayouta0bcfd9d)
	}
	panic("callback func has not been set (race?)")
}

var pFNGetImageSubresourceLayoutA0BCFD9DFunc PFNGetImageSubresourceLayout

// packSImageViewCreateInfo reads sliced Go data structure out from plain C format.
func packSImageViewCreateInfo(v []ImageViewCreateInfo, ptr0 *C.VkImageViewCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageViewCreateInfoValue]C.VkImageViewCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageViewCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateImageView) PassRef() (ref *C.PFN_vkCreateImageView, allocs *cgoAllocMap) {
	if pFNCreateImageView72CB902DFunc == nil {
		pFNCreateImageView72CB902DFunc = x
	}
	return (*C.PFN_vkCreateImageView)(C.PFN_vkCreateImageView_72cb902d), nil
}

// PassValue returns a value.
func (x PFNCreateImageView) PassValue() (ref C.PFN_vkCreateImageView, allocs *cgoAllocMap) {
	if pFNCreateImageView72CB902DFunc == nil {
		pFNCreateImageView72CB902DFunc = x
	}
	return (C.PFN_vkCreateImageView)(C.PFN_vkCreateImageView_72cb902d), nil
}

//export pFNCreateImageView72CB902D
func pFNCreateImageView72CB902D(cDevice C.VkDevice, cPCreateInfo *C.VkImageViewCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPView *C.VkImageView) C.VkResult {
	if pFNCreateImageView72CB902DFunc != nil {
		Device72cb902d := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfo72cb902d []ImageViewCreateInfo
		packSImageViewCreateInfo(PCreateInfo72cb902d, cPCreateInfo)
		var PAllocator72cb902d []AllocationCallbacks
		packSAllocationCallbacks(PAllocator72cb902d, cPAllocator)
		var PView72cb902d []ImageView
		hxfa835e7 := (*sliceHeader)(unsafe.Pointer(&PView72cb902d))
		hxfa835e7.Data = uintptr(unsafe.Pointer(cPView))
		hxfa835e7.Cap = 0x7fffffff
		// hxfa835e7.Len = ?

		ret72cb902d := pFNCreateImageView72CB902DFunc(Device72cb902d, PCreateInfo72cb902d, PAllocator72cb902d, PView72cb902d)
		ret, _ := (C.VkResult)(ret72cb902d), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateImageView72CB902DFunc PFNCreateImageView

// PassRef returns a reference.
func (x PFNDestroyImageView) PassRef() (ref *C.PFN_vkDestroyImageView, allocs *cgoAllocMap) {
	if pFNDestroyImageViewB0E0185FFunc == nil {
		pFNDestroyImageViewB0E0185FFunc = x
	}
	return (*C.PFN_vkDestroyImageView)(C.PFN_vkDestroyImageView_b0e0185f), nil
}

// PassValue returns a value.
func (x PFNDestroyImageView) PassValue() (ref C.PFN_vkDestroyImageView, allocs *cgoAllocMap) {
	if pFNDestroyImageViewB0E0185FFunc == nil {
		pFNDestroyImageViewB0E0185FFunc = x
	}
	return (C.PFN_vkDestroyImageView)(C.PFN_vkDestroyImageView_b0e0185f), nil
}

//export pFNDestroyImageViewB0E0185F
func pFNDestroyImageViewB0E0185F(cDevice C.VkDevice, cImageView C.VkImageView, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyImageViewB0E0185FFunc != nil {
		Deviceb0e0185f := *(*Device)(unsafe.Pointer(&cDevice))
		ImageViewb0e0185f := *(*ImageView)(unsafe.Pointer(&cImageView))
		var PAllocatorb0e0185f []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorb0e0185f, cPAllocator)
		pFNDestroyImageViewB0E0185FFunc(Deviceb0e0185f, ImageViewb0e0185f, PAllocatorb0e0185f)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyImageViewB0E0185FFunc PFNDestroyImageView

// packSShaderModuleCreateInfo reads sliced Go data structure out from plain C format.
func packSShaderModuleCreateInfo(v []ShaderModuleCreateInfo, ptr0 *C.VkShaderModuleCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfShaderModuleCreateInfoValue]C.VkShaderModuleCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewShaderModuleCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateShaderModule) PassRef() (ref *C.PFN_vkCreateShaderModule, allocs *cgoAllocMap) {
	if pFNCreateShaderModule15AFA953Func == nil {
		pFNCreateShaderModule15AFA953Func = x
	}
	return (*C.PFN_vkCreateShaderModule)(C.PFN_vkCreateShaderModule_15afa953), nil
}

// PassValue returns a value.
func (x PFNCreateShaderModule) PassValue() (ref C.PFN_vkCreateShaderModule, allocs *cgoAllocMap) {
	if pFNCreateShaderModule15AFA953Func == nil {
		pFNCreateShaderModule15AFA953Func = x
	}
	return (C.PFN_vkCreateShaderModule)(C.PFN_vkCreateShaderModule_15afa953), nil
}

//export pFNCreateShaderModule15AFA953
func pFNCreateShaderModule15AFA953(cDevice C.VkDevice, cPCreateInfo *C.VkShaderModuleCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPShaderModule *C.VkShaderModule) C.VkResult {
	if pFNCreateShaderModule15AFA953Func != nil {
		Device15afa953 := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfo15afa953 []ShaderModuleCreateInfo
		packSShaderModuleCreateInfo(PCreateInfo15afa953, cPCreateInfo)
		var PAllocator15afa953 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator15afa953, cPAllocator)
		var PShaderModule15afa953 []ShaderModule
		hxf8eae10 := (*sliceHeader)(unsafe.Pointer(&PShaderModule15afa953))
		hxf8eae10.Data = uintptr(unsafe.Pointer(cPShaderModule))
		hxf8eae10.Cap = 0x7fffffff
		// hxf8eae10.Len = ?

		ret15afa953 := pFNCreateShaderModule15AFA953Func(Device15afa953, PCreateInfo15afa953, PAllocator15afa953, PShaderModule15afa953)
		ret, _ := (C.VkResult)(ret15afa953), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateShaderModule15AFA953Func PFNCreateShaderModule

// PassRef returns a reference.
func (x PFNDestroyShaderModule) PassRef() (ref *C.PFN_vkDestroyShaderModule, allocs *cgoAllocMap) {
	if pFNDestroyShaderModule1D3CFEACFunc == nil {
		pFNDestroyShaderModule1D3CFEACFunc = x
	}
	return (*C.PFN_vkDestroyShaderModule)(C.PFN_vkDestroyShaderModule_1d3cfeac), nil
}

// PassValue returns a value.
func (x PFNDestroyShaderModule) PassValue() (ref C.PFN_vkDestroyShaderModule, allocs *cgoAllocMap) {
	if pFNDestroyShaderModule1D3CFEACFunc == nil {
		pFNDestroyShaderModule1D3CFEACFunc = x
	}
	return (C.PFN_vkDestroyShaderModule)(C.PFN_vkDestroyShaderModule_1d3cfeac), nil
}

//export pFNDestroyShaderModule1D3CFEAC
func pFNDestroyShaderModule1D3CFEAC(cDevice C.VkDevice, cShaderModule C.VkShaderModule, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyShaderModule1D3CFEACFunc != nil {
		Device1d3cfeac := *(*Device)(unsafe.Pointer(&cDevice))
		ShaderModule1d3cfeac := *(*ShaderModule)(unsafe.Pointer(&cShaderModule))
		var PAllocator1d3cfeac []AllocationCallbacks
		packSAllocationCallbacks(PAllocator1d3cfeac, cPAllocator)
		pFNDestroyShaderModule1D3CFEACFunc(Device1d3cfeac, ShaderModule1d3cfeac, PAllocator1d3cfeac)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyShaderModule1D3CFEACFunc PFNDestroyShaderModule

// packSPipelineCacheCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineCacheCreateInfo(v []PipelineCacheCreateInfo, ptr0 *C.VkPipelineCacheCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineCacheCreateInfoValue]C.VkPipelineCacheCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineCacheCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreatePipelineCache) PassRef() (ref *C.PFN_vkCreatePipelineCache, allocs *cgoAllocMap) {
	if pFNCreatePipelineCache7BAC14C4Func == nil {
		pFNCreatePipelineCache7BAC14C4Func = x
	}
	return (*C.PFN_vkCreatePipelineCache)(C.PFN_vkCreatePipelineCache_7bac14c4), nil
}

// PassValue returns a value.
func (x PFNCreatePipelineCache) PassValue() (ref C.PFN_vkCreatePipelineCache, allocs *cgoAllocMap) {
	if pFNCreatePipelineCache7BAC14C4Func == nil {
		pFNCreatePipelineCache7BAC14C4Func = x
	}
	return (C.PFN_vkCreatePipelineCache)(C.PFN_vkCreatePipelineCache_7bac14c4), nil
}

//export pFNCreatePipelineCache7BAC14C4
func pFNCreatePipelineCache7BAC14C4(cDevice C.VkDevice, cPCreateInfo *C.VkPipelineCacheCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPPipelineCache *C.VkPipelineCache) C.VkResult {
	if pFNCreatePipelineCache7BAC14C4Func != nil {
		Device7bac14c4 := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfo7bac14c4 []PipelineCacheCreateInfo
		packSPipelineCacheCreateInfo(PCreateInfo7bac14c4, cPCreateInfo)
		var PAllocator7bac14c4 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator7bac14c4, cPAllocator)
		var PPipelineCache7bac14c4 []PipelineCache
		hxfeb55cf := (*sliceHeader)(unsafe.Pointer(&PPipelineCache7bac14c4))
		hxfeb55cf.Data = uintptr(unsafe.Pointer(cPPipelineCache))
		hxfeb55cf.Cap = 0x7fffffff
		// hxfeb55cf.Len = ?

		ret7bac14c4 := pFNCreatePipelineCache7BAC14C4Func(Device7bac14c4, PCreateInfo7bac14c4, PAllocator7bac14c4, PPipelineCache7bac14c4)
		ret, _ := (C.VkResult)(ret7bac14c4), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreatePipelineCache7BAC14C4Func PFNCreatePipelineCache

// PassRef returns a reference.
func (x PFNDestroyPipelineCache) PassRef() (ref *C.PFN_vkDestroyPipelineCache, allocs *cgoAllocMap) {
	if pFNDestroyPipelineCache56A6681EFunc == nil {
		pFNDestroyPipelineCache56A6681EFunc = x
	}
	return (*C.PFN_vkDestroyPipelineCache)(C.PFN_vkDestroyPipelineCache_56a6681e), nil
}

// PassValue returns a value.
func (x PFNDestroyPipelineCache) PassValue() (ref C.PFN_vkDestroyPipelineCache, allocs *cgoAllocMap) {
	if pFNDestroyPipelineCache56A6681EFunc == nil {
		pFNDestroyPipelineCache56A6681EFunc = x
	}
	return (C.PFN_vkDestroyPipelineCache)(C.PFN_vkDestroyPipelineCache_56a6681e), nil
}

//export pFNDestroyPipelineCache56A6681E
func pFNDestroyPipelineCache56A6681E(cDevice C.VkDevice, cPipelineCache C.VkPipelineCache, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyPipelineCache56A6681EFunc != nil {
		Device56a6681e := *(*Device)(unsafe.Pointer(&cDevice))
		PipelineCache56a6681e := *(*PipelineCache)(unsafe.Pointer(&cPipelineCache))
		var PAllocator56a6681e []AllocationCallbacks
		packSAllocationCallbacks(PAllocator56a6681e, cPAllocator)
		pFNDestroyPipelineCache56A6681EFunc(Device56a6681e, PipelineCache56a6681e, PAllocator56a6681e)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyPipelineCache56A6681EFunc PFNDestroyPipelineCache

// PassRef returns a reference.
func (x PFNGetPipelineCacheData) PassRef() (ref *C.PFN_vkGetPipelineCacheData, allocs *cgoAllocMap) {
	if pFNGetPipelineCacheDataAC8F8977Func == nil {
		pFNGetPipelineCacheDataAC8F8977Func = x
	}
	return (*C.PFN_vkGetPipelineCacheData)(C.PFN_vkGetPipelineCacheData_ac8f8977), nil
}

// PassValue returns a value.
func (x PFNGetPipelineCacheData) PassValue() (ref C.PFN_vkGetPipelineCacheData, allocs *cgoAllocMap) {
	if pFNGetPipelineCacheDataAC8F8977Func == nil {
		pFNGetPipelineCacheDataAC8F8977Func = x
	}
	return (C.PFN_vkGetPipelineCacheData)(C.PFN_vkGetPipelineCacheData_ac8f8977), nil
}

//export pFNGetPipelineCacheDataAC8F8977
func pFNGetPipelineCacheDataAC8F8977(cDevice C.VkDevice, cPipelineCache C.VkPipelineCache, cPDataSize *C.size_t, cPData unsafe.Pointer) C.VkResult {
	if pFNGetPipelineCacheDataAC8F8977Func != nil {
		Deviceac8f8977 := *(*Device)(unsafe.Pointer(&cDevice))
		PipelineCacheac8f8977 := *(*PipelineCache)(unsafe.Pointer(&cPipelineCache))
		var PDataSizeac8f8977 []uint
		hxf458096 := (*sliceHeader)(unsafe.Pointer(&PDataSizeac8f8977))
		hxf458096.Data = uintptr(unsafe.Pointer(cPDataSize))
		hxf458096.Cap = 0x7fffffff
		// hxf458096.Len = ?

		PDataac8f8977 := (unsafe.Pointer)(unsafe.Pointer(cPData))
		retac8f8977 := pFNGetPipelineCacheDataAC8F8977Func(Deviceac8f8977, PipelineCacheac8f8977, PDataSizeac8f8977, PDataac8f8977)
		ret, _ := (C.VkResult)(retac8f8977), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNGetPipelineCacheDataAC8F8977Func PFNGetPipelineCacheData

// PassRef returns a reference.
func (x PFNMergePipelineCaches) PassRef() (ref *C.PFN_vkMergePipelineCaches, allocs *cgoAllocMap) {
	if pFNMergePipelineCaches6B8CABFEFunc == nil {
		pFNMergePipelineCaches6B8CABFEFunc = x
	}
	return (*C.PFN_vkMergePipelineCaches)(C.PFN_vkMergePipelineCaches_6b8cabfe), nil
}

// PassValue returns a value.
func (x PFNMergePipelineCaches) PassValue() (ref C.PFN_vkMergePipelineCaches, allocs *cgoAllocMap) {
	if pFNMergePipelineCaches6B8CABFEFunc == nil {
		pFNMergePipelineCaches6B8CABFEFunc = x
	}
	return (C.PFN_vkMergePipelineCaches)(C.PFN_vkMergePipelineCaches_6b8cabfe), nil
}

//export pFNMergePipelineCaches6B8CABFE
func pFNMergePipelineCaches6B8CABFE(cDevice C.VkDevice, cDstCache C.VkPipelineCache, cSrcCacheCount C.uint32_t, cPSrcCaches *C.VkPipelineCache) C.VkResult {
	if pFNMergePipelineCaches6B8CABFEFunc != nil {
		Device6b8cabfe := *(*Device)(unsafe.Pointer(&cDevice))
		DstCache6b8cabfe := *(*PipelineCache)(unsafe.Pointer(&cDstCache))
		SrcCacheCount6b8cabfe := (uint32)(cSrcCacheCount)
		var PSrcCaches6b8cabfe []PipelineCache
		hxf9aab83 := (*sliceHeader)(unsafe.Pointer(&PSrcCaches6b8cabfe))
		hxf9aab83.Data = uintptr(unsafe.Pointer(cPSrcCaches))
		hxf9aab83.Cap = 0x7fffffff
		// hxf9aab83.Len = ?

		ret6b8cabfe := pFNMergePipelineCaches6B8CABFEFunc(Device6b8cabfe, DstCache6b8cabfe, SrcCacheCount6b8cabfe, PSrcCaches6b8cabfe)
		ret, _ := (C.VkResult)(ret6b8cabfe), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNMergePipelineCaches6B8CABFEFunc PFNMergePipelineCaches

// packSGraphicsPipelineCreateInfo reads sliced Go data structure out from plain C format.
func packSGraphicsPipelineCreateInfo(v []GraphicsPipelineCreateInfo, ptr0 *C.VkGraphicsPipelineCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfGraphicsPipelineCreateInfoValue]C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewGraphicsPipelineCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateGraphicsPipelines) PassRef() (ref *C.PFN_vkCreateGraphicsPipelines, allocs *cgoAllocMap) {
	if pFNCreateGraphicsPipelinesC7FAB507Func == nil {
		pFNCreateGraphicsPipelinesC7FAB507Func = x
	}
	return (*C.PFN_vkCreateGraphicsPipelines)(C.PFN_vkCreateGraphicsPipelines_c7fab507), nil
}

// PassValue returns a value.
func (x PFNCreateGraphicsPipelines) PassValue() (ref C.PFN_vkCreateGraphicsPipelines, allocs *cgoAllocMap) {
	if pFNCreateGraphicsPipelinesC7FAB507Func == nil {
		pFNCreateGraphicsPipelinesC7FAB507Func = x
	}
	return (C.PFN_vkCreateGraphicsPipelines)(C.PFN_vkCreateGraphicsPipelines_c7fab507), nil
}

//export pFNCreateGraphicsPipelinesC7FAB507
func pFNCreateGraphicsPipelinesC7FAB507(cDevice C.VkDevice, cPipelineCache C.VkPipelineCache, cCreateInfoCount C.uint32_t, cPCreateInfos *C.VkGraphicsPipelineCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPPipelines *C.VkPipeline) C.VkResult {
	if pFNCreateGraphicsPipelinesC7FAB507Func != nil {
		Devicec7fab507 := *(*Device)(unsafe.Pointer(&cDevice))
		PipelineCachec7fab507 := *(*PipelineCache)(unsafe.Pointer(&cPipelineCache))
		CreateInfoCountc7fab507 := (uint32)(cCreateInfoCount)
		var PCreateInfosc7fab507 []GraphicsPipelineCreateInfo
		packSGraphicsPipelineCreateInfo(PCreateInfosc7fab507, cPCreateInfos)
		var PAllocatorc7fab507 []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorc7fab507, cPAllocator)
		var PPipelinesc7fab507 []Pipeline
		hxf8b35a8 := (*sliceHeader)(unsafe.Pointer(&PPipelinesc7fab507))
		hxf8b35a8.Data = uintptr(unsafe.Pointer(cPPipelines))
		hxf8b35a8.Cap = 0x7fffffff
		// hxf8b35a8.Len = ?

		retc7fab507 := pFNCreateGraphicsPipelinesC7FAB507Func(Devicec7fab507, PipelineCachec7fab507, CreateInfoCountc7fab507, PCreateInfosc7fab507, PAllocatorc7fab507, PPipelinesc7fab507)
		ret, _ := (C.VkResult)(retc7fab507), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateGraphicsPipelinesC7FAB507Func PFNCreateGraphicsPipelines

// packSComputePipelineCreateInfo reads sliced Go data structure out from plain C format.
func packSComputePipelineCreateInfo(v []ComputePipelineCreateInfo, ptr0 *C.VkComputePipelineCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfComputePipelineCreateInfoValue]C.VkComputePipelineCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewComputePipelineCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateComputePipelines) PassRef() (ref *C.PFN_vkCreateComputePipelines, allocs *cgoAllocMap) {
	if pFNCreateComputePipelines3616B207Func == nil {
		pFNCreateComputePipelines3616B207Func = x
	}
	return (*C.PFN_vkCreateComputePipelines)(C.PFN_vkCreateComputePipelines_3616b207), nil
}

// PassValue returns a value.
func (x PFNCreateComputePipelines) PassValue() (ref C.PFN_vkCreateComputePipelines, allocs *cgoAllocMap) {
	if pFNCreateComputePipelines3616B207Func == nil {
		pFNCreateComputePipelines3616B207Func = x
	}
	return (C.PFN_vkCreateComputePipelines)(C.PFN_vkCreateComputePipelines_3616b207), nil
}

//export pFNCreateComputePipelines3616B207
func pFNCreateComputePipelines3616B207(cDevice C.VkDevice, cPipelineCache C.VkPipelineCache, cCreateInfoCount C.uint32_t, cPCreateInfos *C.VkComputePipelineCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPPipelines *C.VkPipeline) C.VkResult {
	if pFNCreateComputePipelines3616B207Func != nil {
		Device3616b207 := *(*Device)(unsafe.Pointer(&cDevice))
		PipelineCache3616b207 := *(*PipelineCache)(unsafe.Pointer(&cPipelineCache))
		CreateInfoCount3616b207 := (uint32)(cCreateInfoCount)
		var PCreateInfos3616b207 []ComputePipelineCreateInfo
		packSComputePipelineCreateInfo(PCreateInfos3616b207, cPCreateInfos)
		var PAllocator3616b207 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator3616b207, cPAllocator)
		var PPipelines3616b207 []Pipeline
		hxf8959c2 := (*sliceHeader)(unsafe.Pointer(&PPipelines3616b207))
		hxf8959c2.Data = uintptr(unsafe.Pointer(cPPipelines))
		hxf8959c2.Cap = 0x7fffffff
		// hxf8959c2.Len = ?

		ret3616b207 := pFNCreateComputePipelines3616B207Func(Device3616b207, PipelineCache3616b207, CreateInfoCount3616b207, PCreateInfos3616b207, PAllocator3616b207, PPipelines3616b207)
		ret, _ := (C.VkResult)(ret3616b207), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateComputePipelines3616B207Func PFNCreateComputePipelines

// PassRef returns a reference.
func (x PFNDestroyPipeline) PassRef() (ref *C.PFN_vkDestroyPipeline, allocs *cgoAllocMap) {
	if pFNDestroyPipeline765FA86Func == nil {
		pFNDestroyPipeline765FA86Func = x
	}
	return (*C.PFN_vkDestroyPipeline)(C.PFN_vkDestroyPipeline_765fa86), nil
}

// PassValue returns a value.
func (x PFNDestroyPipeline) PassValue() (ref C.PFN_vkDestroyPipeline, allocs *cgoAllocMap) {
	if pFNDestroyPipeline765FA86Func == nil {
		pFNDestroyPipeline765FA86Func = x
	}
	return (C.PFN_vkDestroyPipeline)(C.PFN_vkDestroyPipeline_765fa86), nil
}

//export pFNDestroyPipeline765FA86
func pFNDestroyPipeline765FA86(cDevice C.VkDevice, cPipeline C.VkPipeline, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyPipeline765FA86Func != nil {
		Device765fa86 := *(*Device)(unsafe.Pointer(&cDevice))
		Pipeline765fa86 := *(*Pipeline)(unsafe.Pointer(&cPipeline))
		var PAllocator765fa86 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator765fa86, cPAllocator)
		pFNDestroyPipeline765FA86Func(Device765fa86, Pipeline765fa86, PAllocator765fa86)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyPipeline765FA86Func PFNDestroyPipeline

// packSPipelineLayoutCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineLayoutCreateInfo(v []PipelineLayoutCreateInfo, ptr0 *C.VkPipelineLayoutCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineLayoutCreateInfoValue]C.VkPipelineLayoutCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineLayoutCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreatePipelineLayout) PassRef() (ref *C.PFN_vkCreatePipelineLayout, allocs *cgoAllocMap) {
	if pFNCreatePipelineLayout9867F1EFFunc == nil {
		pFNCreatePipelineLayout9867F1EFFunc = x
	}
	return (*C.PFN_vkCreatePipelineLayout)(C.PFN_vkCreatePipelineLayout_9867f1ef), nil
}

// PassValue returns a value.
func (x PFNCreatePipelineLayout) PassValue() (ref C.PFN_vkCreatePipelineLayout, allocs *cgoAllocMap) {
	if pFNCreatePipelineLayout9867F1EFFunc == nil {
		pFNCreatePipelineLayout9867F1EFFunc = x
	}
	return (C.PFN_vkCreatePipelineLayout)(C.PFN_vkCreatePipelineLayout_9867f1ef), nil
}

//export pFNCreatePipelineLayout9867F1EF
func pFNCreatePipelineLayout9867F1EF(cDevice C.VkDevice, cPCreateInfo *C.VkPipelineLayoutCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPPipelineLayout *C.VkPipelineLayout) C.VkResult {
	if pFNCreatePipelineLayout9867F1EFFunc != nil {
		Device9867f1ef := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfo9867f1ef []PipelineLayoutCreateInfo
		packSPipelineLayoutCreateInfo(PCreateInfo9867f1ef, cPCreateInfo)
		var PAllocator9867f1ef []AllocationCallbacks
		packSAllocationCallbacks(PAllocator9867f1ef, cPAllocator)
		var PPipelineLayout9867f1ef []PipelineLayout
		hxfb029a7 := (*sliceHeader)(unsafe.Pointer(&PPipelineLayout9867f1ef))
		hxfb029a7.Data = uintptr(unsafe.Pointer(cPPipelineLayout))
		hxfb029a7.Cap = 0x7fffffff
		// hxfb029a7.Len = ?

		ret9867f1ef := pFNCreatePipelineLayout9867F1EFFunc(Device9867f1ef, PCreateInfo9867f1ef, PAllocator9867f1ef, PPipelineLayout9867f1ef)
		ret, _ := (C.VkResult)(ret9867f1ef), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreatePipelineLayout9867F1EFFunc PFNCreatePipelineLayout

// PassRef returns a reference.
func (x PFNDestroyPipelineLayout) PassRef() (ref *C.PFN_vkDestroyPipelineLayout, allocs *cgoAllocMap) {
	if pFNDestroyPipelineLayoutFE4CC059Func == nil {
		pFNDestroyPipelineLayoutFE4CC059Func = x
	}
	return (*C.PFN_vkDestroyPipelineLayout)(C.PFN_vkDestroyPipelineLayout_fe4cc059), nil
}

// PassValue returns a value.
func (x PFNDestroyPipelineLayout) PassValue() (ref C.PFN_vkDestroyPipelineLayout, allocs *cgoAllocMap) {
	if pFNDestroyPipelineLayoutFE4CC059Func == nil {
		pFNDestroyPipelineLayoutFE4CC059Func = x
	}
	return (C.PFN_vkDestroyPipelineLayout)(C.PFN_vkDestroyPipelineLayout_fe4cc059), nil
}

//export pFNDestroyPipelineLayoutFE4CC059
func pFNDestroyPipelineLayoutFE4CC059(cDevice C.VkDevice, cPipelineLayout C.VkPipelineLayout, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyPipelineLayoutFE4CC059Func != nil {
		Devicefe4cc059 := *(*Device)(unsafe.Pointer(&cDevice))
		PipelineLayoutfe4cc059 := *(*PipelineLayout)(unsafe.Pointer(&cPipelineLayout))
		var PAllocatorfe4cc059 []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorfe4cc059, cPAllocator)
		pFNDestroyPipelineLayoutFE4CC059Func(Devicefe4cc059, PipelineLayoutfe4cc059, PAllocatorfe4cc059)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyPipelineLayoutFE4CC059Func PFNDestroyPipelineLayout

// packSSamplerCreateInfo reads sliced Go data structure out from plain C format.
func packSSamplerCreateInfo(v []SamplerCreateInfo, ptr0 *C.VkSamplerCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSamplerCreateInfoValue]C.VkSamplerCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSamplerCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateSampler) PassRef() (ref *C.PFN_vkCreateSampler, allocs *cgoAllocMap) {
	if pFNCreateSampler53B15031Func == nil {
		pFNCreateSampler53B15031Func = x
	}
	return (*C.PFN_vkCreateSampler)(C.PFN_vkCreateSampler_53b15031), nil
}

// PassValue returns a value.
func (x PFNCreateSampler) PassValue() (ref C.PFN_vkCreateSampler, allocs *cgoAllocMap) {
	if pFNCreateSampler53B15031Func == nil {
		pFNCreateSampler53B15031Func = x
	}
	return (C.PFN_vkCreateSampler)(C.PFN_vkCreateSampler_53b15031), nil
}

//export pFNCreateSampler53B15031
func pFNCreateSampler53B15031(cDevice C.VkDevice, cPCreateInfo *C.VkSamplerCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPSampler *C.VkSampler) C.VkResult {
	if pFNCreateSampler53B15031Func != nil {
		Device53b15031 := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfo53b15031 []SamplerCreateInfo
		packSSamplerCreateInfo(PCreateInfo53b15031, cPCreateInfo)
		var PAllocator53b15031 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator53b15031, cPAllocator)
		var PSampler53b15031 []Sampler
		hxf7d15a2 := (*sliceHeader)(unsafe.Pointer(&PSampler53b15031))
		hxf7d15a2.Data = uintptr(unsafe.Pointer(cPSampler))
		hxf7d15a2.Cap = 0x7fffffff
		// hxf7d15a2.Len = ?

		ret53b15031 := pFNCreateSampler53B15031Func(Device53b15031, PCreateInfo53b15031, PAllocator53b15031, PSampler53b15031)
		ret, _ := (C.VkResult)(ret53b15031), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateSampler53B15031Func PFNCreateSampler

// PassRef returns a reference.
func (x PFNDestroySampler) PassRef() (ref *C.PFN_vkDestroySampler, allocs *cgoAllocMap) {
	if pFNDestroySampler9DEC906AFunc == nil {
		pFNDestroySampler9DEC906AFunc = x
	}
	return (*C.PFN_vkDestroySampler)(C.PFN_vkDestroySampler_9dec906a), nil
}

// PassValue returns a value.
func (x PFNDestroySampler) PassValue() (ref C.PFN_vkDestroySampler, allocs *cgoAllocMap) {
	if pFNDestroySampler9DEC906AFunc == nil {
		pFNDestroySampler9DEC906AFunc = x
	}
	return (C.PFN_vkDestroySampler)(C.PFN_vkDestroySampler_9dec906a), nil
}

//export pFNDestroySampler9DEC906A
func pFNDestroySampler9DEC906A(cDevice C.VkDevice, cSampler C.VkSampler, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroySampler9DEC906AFunc != nil {
		Device9dec906a := *(*Device)(unsafe.Pointer(&cDevice))
		Sampler9dec906a := *(*Sampler)(unsafe.Pointer(&cSampler))
		var PAllocator9dec906a []AllocationCallbacks
		packSAllocationCallbacks(PAllocator9dec906a, cPAllocator)
		pFNDestroySampler9DEC906AFunc(Device9dec906a, Sampler9dec906a, PAllocator9dec906a)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroySampler9DEC906AFunc PFNDestroySampler

// packSDescriptorSetLayoutCreateInfo reads sliced Go data structure out from plain C format.
func packSDescriptorSetLayoutCreateInfo(v []DescriptorSetLayoutCreateInfo, ptr0 *C.VkDescriptorSetLayoutCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorSetLayoutCreateInfoValue]C.VkDescriptorSetLayoutCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorSetLayoutCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateDescriptorSetLayout) PassRef() (ref *C.PFN_vkCreateDescriptorSetLayout, allocs *cgoAllocMap) {
	if pFNCreateDescriptorSetLayoutDF81B6FBFunc == nil {
		pFNCreateDescriptorSetLayoutDF81B6FBFunc = x
	}
	return (*C.PFN_vkCreateDescriptorSetLayout)(C.PFN_vkCreateDescriptorSetLayout_df81b6fb), nil
}

// PassValue returns a value.
func (x PFNCreateDescriptorSetLayout) PassValue() (ref C.PFN_vkCreateDescriptorSetLayout, allocs *cgoAllocMap) {
	if pFNCreateDescriptorSetLayoutDF81B6FBFunc == nil {
		pFNCreateDescriptorSetLayoutDF81B6FBFunc = x
	}
	return (C.PFN_vkCreateDescriptorSetLayout)(C.PFN_vkCreateDescriptorSetLayout_df81b6fb), nil
}

//export pFNCreateDescriptorSetLayoutDF81B6FB
func pFNCreateDescriptorSetLayoutDF81B6FB(cDevice C.VkDevice, cPCreateInfo *C.VkDescriptorSetLayoutCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPSetLayout *C.VkDescriptorSetLayout) C.VkResult {
	if pFNCreateDescriptorSetLayoutDF81B6FBFunc != nil {
		Devicedf81b6fb := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfodf81b6fb []DescriptorSetLayoutCreateInfo
		packSDescriptorSetLayoutCreateInfo(PCreateInfodf81b6fb, cPCreateInfo)
		var PAllocatordf81b6fb []AllocationCallbacks
		packSAllocationCallbacks(PAllocatordf81b6fb, cPAllocator)
		var PSetLayoutdf81b6fb []DescriptorSetLayout
		hxf8dbbe5 := (*sliceHeader)(unsafe.Pointer(&PSetLayoutdf81b6fb))
		hxf8dbbe5.Data = uintptr(unsafe.Pointer(cPSetLayout))
		hxf8dbbe5.Cap = 0x7fffffff
		// hxf8dbbe5.Len = ?

		retdf81b6fb := pFNCreateDescriptorSetLayoutDF81B6FBFunc(Devicedf81b6fb, PCreateInfodf81b6fb, PAllocatordf81b6fb, PSetLayoutdf81b6fb)
		ret, _ := (C.VkResult)(retdf81b6fb), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateDescriptorSetLayoutDF81B6FBFunc PFNCreateDescriptorSetLayout

// PassRef returns a reference.
func (x PFNDestroyDescriptorSetLayout) PassRef() (ref *C.PFN_vkDestroyDescriptorSetLayout, allocs *cgoAllocMap) {
	if pFNDestroyDescriptorSetLayoutF2EB1ABFunc == nil {
		pFNDestroyDescriptorSetLayoutF2EB1ABFunc = x
	}
	return (*C.PFN_vkDestroyDescriptorSetLayout)(C.PFN_vkDestroyDescriptorSetLayout_f2eb1ab), nil
}

// PassValue returns a value.
func (x PFNDestroyDescriptorSetLayout) PassValue() (ref C.PFN_vkDestroyDescriptorSetLayout, allocs *cgoAllocMap) {
	if pFNDestroyDescriptorSetLayoutF2EB1ABFunc == nil {
		pFNDestroyDescriptorSetLayoutF2EB1ABFunc = x
	}
	return (C.PFN_vkDestroyDescriptorSetLayout)(C.PFN_vkDestroyDescriptorSetLayout_f2eb1ab), nil
}

//export pFNDestroyDescriptorSetLayoutF2EB1AB
func pFNDestroyDescriptorSetLayoutF2EB1AB(cDevice C.VkDevice, cDescriptorSetLayout C.VkDescriptorSetLayout, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyDescriptorSetLayoutF2EB1ABFunc != nil {
		Devicef2eb1ab := *(*Device)(unsafe.Pointer(&cDevice))
		DescriptorSetLayoutf2eb1ab := *(*DescriptorSetLayout)(unsafe.Pointer(&cDescriptorSetLayout))
		var PAllocatorf2eb1ab []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorf2eb1ab, cPAllocator)
		pFNDestroyDescriptorSetLayoutF2EB1ABFunc(Devicef2eb1ab, DescriptorSetLayoutf2eb1ab, PAllocatorf2eb1ab)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyDescriptorSetLayoutF2EB1ABFunc PFNDestroyDescriptorSetLayout

// packSDescriptorPoolCreateInfo reads sliced Go data structure out from plain C format.
func packSDescriptorPoolCreateInfo(v []DescriptorPoolCreateInfo, ptr0 *C.VkDescriptorPoolCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorPoolCreateInfoValue]C.VkDescriptorPoolCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorPoolCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateDescriptorPool) PassRef() (ref *C.PFN_vkCreateDescriptorPool, allocs *cgoAllocMap) {
	if pFNCreateDescriptorPoolAB14FE1BFunc == nil {
		pFNCreateDescriptorPoolAB14FE1BFunc = x
	}
	return (*C.PFN_vkCreateDescriptorPool)(C.PFN_vkCreateDescriptorPool_ab14fe1b), nil
}

// PassValue returns a value.
func (x PFNCreateDescriptorPool) PassValue() (ref C.PFN_vkCreateDescriptorPool, allocs *cgoAllocMap) {
	if pFNCreateDescriptorPoolAB14FE1BFunc == nil {
		pFNCreateDescriptorPoolAB14FE1BFunc = x
	}
	return (C.PFN_vkCreateDescriptorPool)(C.PFN_vkCreateDescriptorPool_ab14fe1b), nil
}

//export pFNCreateDescriptorPoolAB14FE1B
func pFNCreateDescriptorPoolAB14FE1B(cDevice C.VkDevice, cPCreateInfo *C.VkDescriptorPoolCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPDescriptorPool *C.VkDescriptorPool) C.VkResult {
	if pFNCreateDescriptorPoolAB14FE1BFunc != nil {
		Deviceab14fe1b := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfoab14fe1b []DescriptorPoolCreateInfo
		packSDescriptorPoolCreateInfo(PCreateInfoab14fe1b, cPCreateInfo)
		var PAllocatorab14fe1b []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorab14fe1b, cPAllocator)
		var PDescriptorPoolab14fe1b []DescriptorPool
		hxf766ff8 := (*sliceHeader)(unsafe.Pointer(&PDescriptorPoolab14fe1b))
		hxf766ff8.Data = uintptr(unsafe.Pointer(cPDescriptorPool))
		hxf766ff8.Cap = 0x7fffffff
		// hxf766ff8.Len = ?

		retab14fe1b := pFNCreateDescriptorPoolAB14FE1BFunc(Deviceab14fe1b, PCreateInfoab14fe1b, PAllocatorab14fe1b, PDescriptorPoolab14fe1b)
		ret, _ := (C.VkResult)(retab14fe1b), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateDescriptorPoolAB14FE1BFunc PFNCreateDescriptorPool

// PassRef returns a reference.
func (x PFNDestroyDescriptorPool) PassRef() (ref *C.PFN_vkDestroyDescriptorPool, allocs *cgoAllocMap) {
	if pFNDestroyDescriptorPoolCD3FCFADFunc == nil {
		pFNDestroyDescriptorPoolCD3FCFADFunc = x
	}
	return (*C.PFN_vkDestroyDescriptorPool)(C.PFN_vkDestroyDescriptorPool_cd3fcfad), nil
}

// PassValue returns a value.
func (x PFNDestroyDescriptorPool) PassValue() (ref C.PFN_vkDestroyDescriptorPool, allocs *cgoAllocMap) {
	if pFNDestroyDescriptorPoolCD3FCFADFunc == nil {
		pFNDestroyDescriptorPoolCD3FCFADFunc = x
	}
	return (C.PFN_vkDestroyDescriptorPool)(C.PFN_vkDestroyDescriptorPool_cd3fcfad), nil
}

//export pFNDestroyDescriptorPoolCD3FCFAD
func pFNDestroyDescriptorPoolCD3FCFAD(cDevice C.VkDevice, cDescriptorPool C.VkDescriptorPool, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyDescriptorPoolCD3FCFADFunc != nil {
		Devicecd3fcfad := *(*Device)(unsafe.Pointer(&cDevice))
		DescriptorPoolcd3fcfad := *(*DescriptorPool)(unsafe.Pointer(&cDescriptorPool))
		var PAllocatorcd3fcfad []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorcd3fcfad, cPAllocator)
		pFNDestroyDescriptorPoolCD3FCFADFunc(Devicecd3fcfad, DescriptorPoolcd3fcfad, PAllocatorcd3fcfad)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyDescriptorPoolCD3FCFADFunc PFNDestroyDescriptorPool

// PassRef returns a reference.
func (x PFNResetDescriptorPool) PassRef() (ref *C.PFN_vkResetDescriptorPool, allocs *cgoAllocMap) {
	if pFNResetDescriptorPoolEAA63710Func == nil {
		pFNResetDescriptorPoolEAA63710Func = x
	}
	return (*C.PFN_vkResetDescriptorPool)(C.PFN_vkResetDescriptorPool_eaa63710), nil
}

// PassValue returns a value.
func (x PFNResetDescriptorPool) PassValue() (ref C.PFN_vkResetDescriptorPool, allocs *cgoAllocMap) {
	if pFNResetDescriptorPoolEAA63710Func == nil {
		pFNResetDescriptorPoolEAA63710Func = x
	}
	return (C.PFN_vkResetDescriptorPool)(C.PFN_vkResetDescriptorPool_eaa63710), nil
}

//export pFNResetDescriptorPoolEAA63710
func pFNResetDescriptorPoolEAA63710(cDevice C.VkDevice, cDescriptorPool C.VkDescriptorPool, cFlags C.VkDescriptorPoolResetFlags) C.VkResult {
	if pFNResetDescriptorPoolEAA63710Func != nil {
		Deviceeaa63710 := *(*Device)(unsafe.Pointer(&cDevice))
		DescriptorPooleaa63710 := *(*DescriptorPool)(unsafe.Pointer(&cDescriptorPool))
		Flagseaa63710 := (DescriptorPoolResetFlags)(cFlags)
		reteaa63710 := pFNResetDescriptorPoolEAA63710Func(Deviceeaa63710, DescriptorPooleaa63710, Flagseaa63710)
		ret, _ := (C.VkResult)(reteaa63710), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNResetDescriptorPoolEAA63710Func PFNResetDescriptorPool

// packSDescriptorSetAllocateInfo reads sliced Go data structure out from plain C format.
func packSDescriptorSetAllocateInfo(v []DescriptorSetAllocateInfo, ptr0 *C.VkDescriptorSetAllocateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorSetAllocateInfoValue]C.VkDescriptorSetAllocateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorSetAllocateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNAllocateDescriptorSets) PassRef() (ref *C.PFN_vkAllocateDescriptorSets, allocs *cgoAllocMap) {
	if pFNAllocateDescriptorSetsF727F5C9Func == nil {
		pFNAllocateDescriptorSetsF727F5C9Func = x
	}
	return (*C.PFN_vkAllocateDescriptorSets)(C.PFN_vkAllocateDescriptorSets_f727f5c9), nil
}

// PassValue returns a value.
func (x PFNAllocateDescriptorSets) PassValue() (ref C.PFN_vkAllocateDescriptorSets, allocs *cgoAllocMap) {
	if pFNAllocateDescriptorSetsF727F5C9Func == nil {
		pFNAllocateDescriptorSetsF727F5C9Func = x
	}
	return (C.PFN_vkAllocateDescriptorSets)(C.PFN_vkAllocateDescriptorSets_f727f5c9), nil
}

//export pFNAllocateDescriptorSetsF727F5C9
func pFNAllocateDescriptorSetsF727F5C9(cDevice C.VkDevice, cPAllocateInfo *C.VkDescriptorSetAllocateInfo, cPDescriptorSets *C.VkDescriptorSet) C.VkResult {
	if pFNAllocateDescriptorSetsF727F5C9Func != nil {
		Devicef727f5c9 := *(*Device)(unsafe.Pointer(&cDevice))
		var PAllocateInfof727f5c9 []DescriptorSetAllocateInfo
		packSDescriptorSetAllocateInfo(PAllocateInfof727f5c9, cPAllocateInfo)
		var PDescriptorSetsf727f5c9 []DescriptorSet
		hxf9b1633 := (*sliceHeader)(unsafe.Pointer(&PDescriptorSetsf727f5c9))
		hxf9b1633.Data = uintptr(unsafe.Pointer(cPDescriptorSets))
		hxf9b1633.Cap = 0x7fffffff
		// hxf9b1633.Len = ?

		retf727f5c9 := pFNAllocateDescriptorSetsF727F5C9Func(Devicef727f5c9, PAllocateInfof727f5c9, PDescriptorSetsf727f5c9)
		ret, _ := (C.VkResult)(retf727f5c9), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNAllocateDescriptorSetsF727F5C9Func PFNAllocateDescriptorSets

// PassRef returns a reference.
func (x PFNFreeDescriptorSets) PassRef() (ref *C.PFN_vkFreeDescriptorSets, allocs *cgoAllocMap) {
	if pFNFreeDescriptorSets54B3DB78Func == nil {
		pFNFreeDescriptorSets54B3DB78Func = x
	}
	return (*C.PFN_vkFreeDescriptorSets)(C.PFN_vkFreeDescriptorSets_54b3db78), nil
}

// PassValue returns a value.
func (x PFNFreeDescriptorSets) PassValue() (ref C.PFN_vkFreeDescriptorSets, allocs *cgoAllocMap) {
	if pFNFreeDescriptorSets54B3DB78Func == nil {
		pFNFreeDescriptorSets54B3DB78Func = x
	}
	return (C.PFN_vkFreeDescriptorSets)(C.PFN_vkFreeDescriptorSets_54b3db78), nil
}

//export pFNFreeDescriptorSets54B3DB78
func pFNFreeDescriptorSets54B3DB78(cDevice C.VkDevice, cDescriptorPool C.VkDescriptorPool, cDescriptorSetCount C.uint32_t, cPDescriptorSets *C.VkDescriptorSet) C.VkResult {
	if pFNFreeDescriptorSets54B3DB78Func != nil {
		Device54b3db78 := *(*Device)(unsafe.Pointer(&cDevice))
		DescriptorPool54b3db78 := *(*DescriptorPool)(unsafe.Pointer(&cDescriptorPool))
		DescriptorSetCount54b3db78 := (uint32)(cDescriptorSetCount)
		var PDescriptorSets54b3db78 []DescriptorSet
		hxf502c9a := (*sliceHeader)(unsafe.Pointer(&PDescriptorSets54b3db78))
		hxf502c9a.Data = uintptr(unsafe.Pointer(cPDescriptorSets))
		hxf502c9a.Cap = 0x7fffffff
		// hxf502c9a.Len = ?

		ret54b3db78 := pFNFreeDescriptorSets54B3DB78Func(Device54b3db78, DescriptorPool54b3db78, DescriptorSetCount54b3db78, PDescriptorSets54b3db78)
		ret, _ := (C.VkResult)(ret54b3db78), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNFreeDescriptorSets54B3DB78Func PFNFreeDescriptorSets

// packSWriteDescriptorSet reads sliced Go data structure out from plain C format.
func packSWriteDescriptorSet(v []WriteDescriptorSet, ptr0 *C.VkWriteDescriptorSet) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfWriteDescriptorSetValue]C.VkWriteDescriptorSet)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewWriteDescriptorSetRef(&ptr1)
	}
}

// packSCopyDescriptorSet reads sliced Go data structure out from plain C format.
func packSCopyDescriptorSet(v []CopyDescriptorSet, ptr0 *C.VkCopyDescriptorSet) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCopyDescriptorSetValue]C.VkCopyDescriptorSet)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCopyDescriptorSetRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNUpdateDescriptorSets) PassRef() (ref *C.PFN_vkUpdateDescriptorSets, allocs *cgoAllocMap) {
	if pFNUpdateDescriptorSets6F0B94ACFunc == nil {
		pFNUpdateDescriptorSets6F0B94ACFunc = x
	}
	return (*C.PFN_vkUpdateDescriptorSets)(C.PFN_vkUpdateDescriptorSets_6f0b94ac), nil
}

// PassValue returns a value.
func (x PFNUpdateDescriptorSets) PassValue() (ref C.PFN_vkUpdateDescriptorSets, allocs *cgoAllocMap) {
	if pFNUpdateDescriptorSets6F0B94ACFunc == nil {
		pFNUpdateDescriptorSets6F0B94ACFunc = x
	}
	return (C.PFN_vkUpdateDescriptorSets)(C.PFN_vkUpdateDescriptorSets_6f0b94ac), nil
}

//export pFNUpdateDescriptorSets6F0B94AC
func pFNUpdateDescriptorSets6F0B94AC(cDevice C.VkDevice, cDescriptorWriteCount C.uint32_t, cPDescriptorWrites *C.VkWriteDescriptorSet, cDescriptorCopyCount C.uint32_t, cPDescriptorCopies *C.VkCopyDescriptorSet) {
	if pFNUpdateDescriptorSets6F0B94ACFunc != nil {
		Device6f0b94ac := *(*Device)(unsafe.Pointer(&cDevice))
		DescriptorWriteCount6f0b94ac := (uint32)(cDescriptorWriteCount)
		var PDescriptorWrites6f0b94ac []WriteDescriptorSet
		packSWriteDescriptorSet(PDescriptorWrites6f0b94ac, cPDescriptorWrites)
		DescriptorCopyCount6f0b94ac := (uint32)(cDescriptorCopyCount)
		var PDescriptorCopies6f0b94ac []CopyDescriptorSet
		packSCopyDescriptorSet(PDescriptorCopies6f0b94ac, cPDescriptorCopies)
		pFNUpdateDescriptorSets6F0B94ACFunc(Device6f0b94ac, DescriptorWriteCount6f0b94ac, PDescriptorWrites6f0b94ac, DescriptorCopyCount6f0b94ac, PDescriptorCopies6f0b94ac)
	}
	panic("callback func has not been set (race?)")
}

var pFNUpdateDescriptorSets6F0B94ACFunc PFNUpdateDescriptorSets

// packSFramebufferCreateInfo reads sliced Go data structure out from plain C format.
func packSFramebufferCreateInfo(v []FramebufferCreateInfo, ptr0 *C.VkFramebufferCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFramebufferCreateInfoValue]C.VkFramebufferCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFramebufferCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateFramebuffer) PassRef() (ref *C.PFN_vkCreateFramebuffer, allocs *cgoAllocMap) {
	if pFNCreateFramebufferD64A4D97Func == nil {
		pFNCreateFramebufferD64A4D97Func = x
	}
	return (*C.PFN_vkCreateFramebuffer)(C.PFN_vkCreateFramebuffer_d64a4d97), nil
}

// PassValue returns a value.
func (x PFNCreateFramebuffer) PassValue() (ref C.PFN_vkCreateFramebuffer, allocs *cgoAllocMap) {
	if pFNCreateFramebufferD64A4D97Func == nil {
		pFNCreateFramebufferD64A4D97Func = x
	}
	return (C.PFN_vkCreateFramebuffer)(C.PFN_vkCreateFramebuffer_d64a4d97), nil
}

//export pFNCreateFramebufferD64A4D97
func pFNCreateFramebufferD64A4D97(cDevice C.VkDevice, cPCreateInfo *C.VkFramebufferCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPFramebuffer *C.VkFramebuffer) C.VkResult {
	if pFNCreateFramebufferD64A4D97Func != nil {
		Deviced64a4d97 := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfod64a4d97 []FramebufferCreateInfo
		packSFramebufferCreateInfo(PCreateInfod64a4d97, cPCreateInfo)
		var PAllocatord64a4d97 []AllocationCallbacks
		packSAllocationCallbacks(PAllocatord64a4d97, cPAllocator)
		var PFramebufferd64a4d97 []Framebuffer
		hxf4a9453 := (*sliceHeader)(unsafe.Pointer(&PFramebufferd64a4d97))
		hxf4a9453.Data = uintptr(unsafe.Pointer(cPFramebuffer))
		hxf4a9453.Cap = 0x7fffffff
		// hxf4a9453.Len = ?

		retd64a4d97 := pFNCreateFramebufferD64A4D97Func(Deviced64a4d97, PCreateInfod64a4d97, PAllocatord64a4d97, PFramebufferd64a4d97)
		ret, _ := (C.VkResult)(retd64a4d97), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateFramebufferD64A4D97Func PFNCreateFramebuffer

// PassRef returns a reference.
func (x PFNDestroyFramebuffer) PassRef() (ref *C.PFN_vkDestroyFramebuffer, allocs *cgoAllocMap) {
	if pFNDestroyFramebuffer28209FDAFunc == nil {
		pFNDestroyFramebuffer28209FDAFunc = x
	}
	return (*C.PFN_vkDestroyFramebuffer)(C.PFN_vkDestroyFramebuffer_28209fda), nil
}

// PassValue returns a value.
func (x PFNDestroyFramebuffer) PassValue() (ref C.PFN_vkDestroyFramebuffer, allocs *cgoAllocMap) {
	if pFNDestroyFramebuffer28209FDAFunc == nil {
		pFNDestroyFramebuffer28209FDAFunc = x
	}
	return (C.PFN_vkDestroyFramebuffer)(C.PFN_vkDestroyFramebuffer_28209fda), nil
}

//export pFNDestroyFramebuffer28209FDA
func pFNDestroyFramebuffer28209FDA(cDevice C.VkDevice, cFramebuffer C.VkFramebuffer, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyFramebuffer28209FDAFunc != nil {
		Device28209fda := *(*Device)(unsafe.Pointer(&cDevice))
		Framebuffer28209fda := *(*Framebuffer)(unsafe.Pointer(&cFramebuffer))
		var PAllocator28209fda []AllocationCallbacks
		packSAllocationCallbacks(PAllocator28209fda, cPAllocator)
		pFNDestroyFramebuffer28209FDAFunc(Device28209fda, Framebuffer28209fda, PAllocator28209fda)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyFramebuffer28209FDAFunc PFNDestroyFramebuffer

// packSRenderPassCreateInfo reads sliced Go data structure out from plain C format.
func packSRenderPassCreateInfo(v []RenderPassCreateInfo, ptr0 *C.VkRenderPassCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRenderPassCreateInfoValue]C.VkRenderPassCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRenderPassCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateRenderPass) PassRef() (ref *C.PFN_vkCreateRenderPass, allocs *cgoAllocMap) {
	if pFNCreateRenderPass8FADBEFFunc == nil {
		pFNCreateRenderPass8FADBEFFunc = x
	}
	return (*C.PFN_vkCreateRenderPass)(C.PFN_vkCreateRenderPass_8fadbef), nil
}

// PassValue returns a value.
func (x PFNCreateRenderPass) PassValue() (ref C.PFN_vkCreateRenderPass, allocs *cgoAllocMap) {
	if pFNCreateRenderPass8FADBEFFunc == nil {
		pFNCreateRenderPass8FADBEFFunc = x
	}
	return (C.PFN_vkCreateRenderPass)(C.PFN_vkCreateRenderPass_8fadbef), nil
}

//export pFNCreateRenderPass8FADBEF
func pFNCreateRenderPass8FADBEF(cDevice C.VkDevice, cPCreateInfo *C.VkRenderPassCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPRenderPass *C.VkRenderPass) C.VkResult {
	if pFNCreateRenderPass8FADBEFFunc != nil {
		Device8fadbef := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfo8fadbef []RenderPassCreateInfo
		packSRenderPassCreateInfo(PCreateInfo8fadbef, cPCreateInfo)
		var PAllocator8fadbef []AllocationCallbacks
		packSAllocationCallbacks(PAllocator8fadbef, cPAllocator)
		var PRenderPass8fadbef []RenderPass
		hxf1a1416 := (*sliceHeader)(unsafe.Pointer(&PRenderPass8fadbef))
		hxf1a1416.Data = uintptr(unsafe.Pointer(cPRenderPass))
		hxf1a1416.Cap = 0x7fffffff
		// hxf1a1416.Len = ?

		ret8fadbef := pFNCreateRenderPass8FADBEFFunc(Device8fadbef, PCreateInfo8fadbef, PAllocator8fadbef, PRenderPass8fadbef)
		ret, _ := (C.VkResult)(ret8fadbef), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateRenderPass8FADBEFFunc PFNCreateRenderPass

// PassRef returns a reference.
func (x PFNDestroyRenderPass) PassRef() (ref *C.PFN_vkDestroyRenderPass, allocs *cgoAllocMap) {
	if pFNDestroyRenderPassB633E077Func == nil {
		pFNDestroyRenderPassB633E077Func = x
	}
	return (*C.PFN_vkDestroyRenderPass)(C.PFN_vkDestroyRenderPass_b633e077), nil
}

// PassValue returns a value.
func (x PFNDestroyRenderPass) PassValue() (ref C.PFN_vkDestroyRenderPass, allocs *cgoAllocMap) {
	if pFNDestroyRenderPassB633E077Func == nil {
		pFNDestroyRenderPassB633E077Func = x
	}
	return (C.PFN_vkDestroyRenderPass)(C.PFN_vkDestroyRenderPass_b633e077), nil
}

//export pFNDestroyRenderPassB633E077
func pFNDestroyRenderPassB633E077(cDevice C.VkDevice, cRenderPass C.VkRenderPass, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyRenderPassB633E077Func != nil {
		Deviceb633e077 := *(*Device)(unsafe.Pointer(&cDevice))
		RenderPassb633e077 := *(*RenderPass)(unsafe.Pointer(&cRenderPass))
		var PAllocatorb633e077 []AllocationCallbacks
		packSAllocationCallbacks(PAllocatorb633e077, cPAllocator)
		pFNDestroyRenderPassB633E077Func(Deviceb633e077, RenderPassb633e077, PAllocatorb633e077)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyRenderPassB633E077Func PFNDestroyRenderPass

// packSExtent2D reads sliced Go data structure out from plain C format.
func packSExtent2D(v []Extent2D, ptr0 *C.VkExtent2D) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfExtent2DValue]C.VkExtent2D)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewExtent2DRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetRenderAreaGranularity) PassRef() (ref *C.PFN_vkGetRenderAreaGranularity, allocs *cgoAllocMap) {
	if pFNGetRenderAreaGranularityBF72D2FCFunc == nil {
		pFNGetRenderAreaGranularityBF72D2FCFunc = x
	}
	return (*C.PFN_vkGetRenderAreaGranularity)(C.PFN_vkGetRenderAreaGranularity_bf72d2fc), nil
}

// PassValue returns a value.
func (x PFNGetRenderAreaGranularity) PassValue() (ref C.PFN_vkGetRenderAreaGranularity, allocs *cgoAllocMap) {
	if pFNGetRenderAreaGranularityBF72D2FCFunc == nil {
		pFNGetRenderAreaGranularityBF72D2FCFunc = x
	}
	return (C.PFN_vkGetRenderAreaGranularity)(C.PFN_vkGetRenderAreaGranularity_bf72d2fc), nil
}

//export pFNGetRenderAreaGranularityBF72D2FC
func pFNGetRenderAreaGranularityBF72D2FC(cDevice C.VkDevice, cRenderPass C.VkRenderPass, cPGranularity *C.VkExtent2D) {
	if pFNGetRenderAreaGranularityBF72D2FCFunc != nil {
		Devicebf72d2fc := *(*Device)(unsafe.Pointer(&cDevice))
		RenderPassbf72d2fc := *(*RenderPass)(unsafe.Pointer(&cRenderPass))
		var PGranularitybf72d2fc []Extent2D
		packSExtent2D(PGranularitybf72d2fc, cPGranularity)
		pFNGetRenderAreaGranularityBF72D2FCFunc(Devicebf72d2fc, RenderPassbf72d2fc, PGranularitybf72d2fc)
	}
	panic("callback func has not been set (race?)")
}

var pFNGetRenderAreaGranularityBF72D2FCFunc PFNGetRenderAreaGranularity

// packSCommandPoolCreateInfo reads sliced Go data structure out from plain C format.
func packSCommandPoolCreateInfo(v []CommandPoolCreateInfo, ptr0 *C.VkCommandPoolCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCommandPoolCreateInfoValue]C.VkCommandPoolCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandPoolCreateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateCommandPool) PassRef() (ref *C.PFN_vkCreateCommandPool, allocs *cgoAllocMap) {
	if pFNCreateCommandPool97050BD8Func == nil {
		pFNCreateCommandPool97050BD8Func = x
	}
	return (*C.PFN_vkCreateCommandPool)(C.PFN_vkCreateCommandPool_97050bd8), nil
}

// PassValue returns a value.
func (x PFNCreateCommandPool) PassValue() (ref C.PFN_vkCreateCommandPool, allocs *cgoAllocMap) {
	if pFNCreateCommandPool97050BD8Func == nil {
		pFNCreateCommandPool97050BD8Func = x
	}
	return (C.PFN_vkCreateCommandPool)(C.PFN_vkCreateCommandPool_97050bd8), nil
}

//export pFNCreateCommandPool97050BD8
func pFNCreateCommandPool97050BD8(cDevice C.VkDevice, cPCreateInfo *C.VkCommandPoolCreateInfo, cPAllocator *C.VkAllocationCallbacks, cPCommandPool *C.VkCommandPool) C.VkResult {
	if pFNCreateCommandPool97050BD8Func != nil {
		Device97050bd8 := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfo97050bd8 []CommandPoolCreateInfo
		packSCommandPoolCreateInfo(PCreateInfo97050bd8, cPCreateInfo)
		var PAllocator97050bd8 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator97050bd8, cPAllocator)
		var PCommandPool97050bd8 []CommandPool
		hxf92be66 := (*sliceHeader)(unsafe.Pointer(&PCommandPool97050bd8))
		hxf92be66.Data = uintptr(unsafe.Pointer(cPCommandPool))
		hxf92be66.Cap = 0x7fffffff
		// hxf92be66.Len = ?

		ret97050bd8 := pFNCreateCommandPool97050BD8Func(Device97050bd8, PCreateInfo97050bd8, PAllocator97050bd8, PCommandPool97050bd8)
		ret, _ := (C.VkResult)(ret97050bd8), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateCommandPool97050BD8Func PFNCreateCommandPool

// PassRef returns a reference.
func (x PFNDestroyCommandPool) PassRef() (ref *C.PFN_vkDestroyCommandPool, allocs *cgoAllocMap) {
	if pFNDestroyCommandPool696FD995Func == nil {
		pFNDestroyCommandPool696FD995Func = x
	}
	return (*C.PFN_vkDestroyCommandPool)(C.PFN_vkDestroyCommandPool_696fd995), nil
}

// PassValue returns a value.
func (x PFNDestroyCommandPool) PassValue() (ref C.PFN_vkDestroyCommandPool, allocs *cgoAllocMap) {
	if pFNDestroyCommandPool696FD995Func == nil {
		pFNDestroyCommandPool696FD995Func = x
	}
	return (C.PFN_vkDestroyCommandPool)(C.PFN_vkDestroyCommandPool_696fd995), nil
}

//export pFNDestroyCommandPool696FD995
func pFNDestroyCommandPool696FD995(cDevice C.VkDevice, cCommandPool C.VkCommandPool, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyCommandPool696FD995Func != nil {
		Device696fd995 := *(*Device)(unsafe.Pointer(&cDevice))
		CommandPool696fd995 := *(*CommandPool)(unsafe.Pointer(&cCommandPool))
		var PAllocator696fd995 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator696fd995, cPAllocator)
		pFNDestroyCommandPool696FD995Func(Device696fd995, CommandPool696fd995, PAllocator696fd995)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyCommandPool696FD995Func PFNDestroyCommandPool

// PassRef returns a reference.
func (x PFNResetCommandPool) PassRef() (ref *C.PFN_vkResetCommandPool, allocs *cgoAllocMap) {
	if pFNResetCommandPoolB1D2D0FAFunc == nil {
		pFNResetCommandPoolB1D2D0FAFunc = x
	}
	return (*C.PFN_vkResetCommandPool)(C.PFN_vkResetCommandPool_b1d2d0fa), nil
}

// PassValue returns a value.
func (x PFNResetCommandPool) PassValue() (ref C.PFN_vkResetCommandPool, allocs *cgoAllocMap) {
	if pFNResetCommandPoolB1D2D0FAFunc == nil {
		pFNResetCommandPoolB1D2D0FAFunc = x
	}
	return (C.PFN_vkResetCommandPool)(C.PFN_vkResetCommandPool_b1d2d0fa), nil
}

//export pFNResetCommandPoolB1D2D0FA
func pFNResetCommandPoolB1D2D0FA(cDevice C.VkDevice, cCommandPool C.VkCommandPool, cFlags C.VkCommandPoolResetFlags) C.VkResult {
	if pFNResetCommandPoolB1D2D0FAFunc != nil {
		Deviceb1d2d0fa := *(*Device)(unsafe.Pointer(&cDevice))
		CommandPoolb1d2d0fa := *(*CommandPool)(unsafe.Pointer(&cCommandPool))
		Flagsb1d2d0fa := (CommandPoolResetFlags)(cFlags)
		retb1d2d0fa := pFNResetCommandPoolB1D2D0FAFunc(Deviceb1d2d0fa, CommandPoolb1d2d0fa, Flagsb1d2d0fa)
		ret, _ := (C.VkResult)(retb1d2d0fa), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNResetCommandPoolB1D2D0FAFunc PFNResetCommandPool

// packSCommandBufferAllocateInfo reads sliced Go data structure out from plain C format.
func packSCommandBufferAllocateInfo(v []CommandBufferAllocateInfo, ptr0 *C.VkCommandBufferAllocateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCommandBufferAllocateInfoValue]C.VkCommandBufferAllocateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandBufferAllocateInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNAllocateCommandBuffers) PassRef() (ref *C.PFN_vkAllocateCommandBuffers, allocs *cgoAllocMap) {
	if pFNAllocateCommandBuffers22D26BFAFunc == nil {
		pFNAllocateCommandBuffers22D26BFAFunc = x
	}
	return (*C.PFN_vkAllocateCommandBuffers)(C.PFN_vkAllocateCommandBuffers_22d26bfa), nil
}

// PassValue returns a value.
func (x PFNAllocateCommandBuffers) PassValue() (ref C.PFN_vkAllocateCommandBuffers, allocs *cgoAllocMap) {
	if pFNAllocateCommandBuffers22D26BFAFunc == nil {
		pFNAllocateCommandBuffers22D26BFAFunc = x
	}
	return (C.PFN_vkAllocateCommandBuffers)(C.PFN_vkAllocateCommandBuffers_22d26bfa), nil
}

//export pFNAllocateCommandBuffers22D26BFA
func pFNAllocateCommandBuffers22D26BFA(cDevice C.VkDevice, cPAllocateInfo *C.VkCommandBufferAllocateInfo, cPCommandBuffers *C.VkCommandBuffer) C.VkResult {
	if pFNAllocateCommandBuffers22D26BFAFunc != nil {
		Device22d26bfa := *(*Device)(unsafe.Pointer(&cDevice))
		var PAllocateInfo22d26bfa []CommandBufferAllocateInfo
		packSCommandBufferAllocateInfo(PAllocateInfo22d26bfa, cPAllocateInfo)
		var PCommandBuffers22d26bfa []CommandBuffer
		hxf4b5187 := (*sliceHeader)(unsafe.Pointer(&PCommandBuffers22d26bfa))
		hxf4b5187.Data = uintptr(unsafe.Pointer(cPCommandBuffers))
		hxf4b5187.Cap = 0x7fffffff
		// hxf4b5187.Len = ?

		ret22d26bfa := pFNAllocateCommandBuffers22D26BFAFunc(Device22d26bfa, PAllocateInfo22d26bfa, PCommandBuffers22d26bfa)
		ret, _ := (C.VkResult)(ret22d26bfa), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNAllocateCommandBuffers22D26BFAFunc PFNAllocateCommandBuffers

// PassRef returns a reference.
func (x PFNFreeCommandBuffers) PassRef() (ref *C.PFN_vkFreeCommandBuffers, allocs *cgoAllocMap) {
	if pFNFreeCommandBuffers8146454BFunc == nil {
		pFNFreeCommandBuffers8146454BFunc = x
	}
	return (*C.PFN_vkFreeCommandBuffers)(C.PFN_vkFreeCommandBuffers_8146454b), nil
}

// PassValue returns a value.
func (x PFNFreeCommandBuffers) PassValue() (ref C.PFN_vkFreeCommandBuffers, allocs *cgoAllocMap) {
	if pFNFreeCommandBuffers8146454BFunc == nil {
		pFNFreeCommandBuffers8146454BFunc = x
	}
	return (C.PFN_vkFreeCommandBuffers)(C.PFN_vkFreeCommandBuffers_8146454b), nil
}

//export pFNFreeCommandBuffers8146454B
func pFNFreeCommandBuffers8146454B(cDevice C.VkDevice, cCommandPool C.VkCommandPool, cCommandBufferCount C.uint32_t, cPCommandBuffers *C.VkCommandBuffer) {
	if pFNFreeCommandBuffers8146454BFunc != nil {
		Device8146454b := *(*Device)(unsafe.Pointer(&cDevice))
		CommandPool8146454b := *(*CommandPool)(unsafe.Pointer(&cCommandPool))
		CommandBufferCount8146454b := (uint32)(cCommandBufferCount)
		var PCommandBuffers8146454b []CommandBuffer
		hxf177f79 := (*sliceHeader)(unsafe.Pointer(&PCommandBuffers8146454b))
		hxf177f79.Data = uintptr(unsafe.Pointer(cPCommandBuffers))
		hxf177f79.Cap = 0x7fffffff
		// hxf177f79.Len = ?

		pFNFreeCommandBuffers8146454BFunc(Device8146454b, CommandPool8146454b, CommandBufferCount8146454b, PCommandBuffers8146454b)
	}
	panic("callback func has not been set (race?)")
}

var pFNFreeCommandBuffers8146454BFunc PFNFreeCommandBuffers

// packSCommandBufferBeginInfo reads sliced Go data structure out from plain C format.
func packSCommandBufferBeginInfo(v []CommandBufferBeginInfo, ptr0 *C.VkCommandBufferBeginInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCommandBufferBeginInfoValue]C.VkCommandBufferBeginInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandBufferBeginInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNBeginCommandBuffer) PassRef() (ref *C.PFN_vkBeginCommandBuffer, allocs *cgoAllocMap) {
	if pFNBeginCommandBuffer76CC70C1Func == nil {
		pFNBeginCommandBuffer76CC70C1Func = x
	}
	return (*C.PFN_vkBeginCommandBuffer)(C.PFN_vkBeginCommandBuffer_76cc70c1), nil
}

// PassValue returns a value.
func (x PFNBeginCommandBuffer) PassValue() (ref C.PFN_vkBeginCommandBuffer, allocs *cgoAllocMap) {
	if pFNBeginCommandBuffer76CC70C1Func == nil {
		pFNBeginCommandBuffer76CC70C1Func = x
	}
	return (C.PFN_vkBeginCommandBuffer)(C.PFN_vkBeginCommandBuffer_76cc70c1), nil
}

//export pFNBeginCommandBuffer76CC70C1
func pFNBeginCommandBuffer76CC70C1(cCommandBuffer C.VkCommandBuffer, cPBeginInfo *C.VkCommandBufferBeginInfo) C.VkResult {
	if pFNBeginCommandBuffer76CC70C1Func != nil {
		CommandBuffer76cc70c1 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		var PBeginInfo76cc70c1 []CommandBufferBeginInfo
		packSCommandBufferBeginInfo(PBeginInfo76cc70c1, cPBeginInfo)
		ret76cc70c1 := pFNBeginCommandBuffer76CC70C1Func(CommandBuffer76cc70c1, PBeginInfo76cc70c1)
		ret, _ := (C.VkResult)(ret76cc70c1), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNBeginCommandBuffer76CC70C1Func PFNBeginCommandBuffer

// PassRef returns a reference.
func (x PFNEndCommandBuffer) PassRef() (ref *C.PFN_vkEndCommandBuffer, allocs *cgoAllocMap) {
	if pFNEndCommandBuffer4956641Func == nil {
		pFNEndCommandBuffer4956641Func = x
	}
	return (*C.PFN_vkEndCommandBuffer)(C.PFN_vkEndCommandBuffer_4956641), nil
}

// PassValue returns a value.
func (x PFNEndCommandBuffer) PassValue() (ref C.PFN_vkEndCommandBuffer, allocs *cgoAllocMap) {
	if pFNEndCommandBuffer4956641Func == nil {
		pFNEndCommandBuffer4956641Func = x
	}
	return (C.PFN_vkEndCommandBuffer)(C.PFN_vkEndCommandBuffer_4956641), nil
}

//export pFNEndCommandBuffer4956641
func pFNEndCommandBuffer4956641(cCommandBuffer C.VkCommandBuffer) C.VkResult {
	if pFNEndCommandBuffer4956641Func != nil {
		CommandBuffer4956641 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		ret4956641 := pFNEndCommandBuffer4956641Func(CommandBuffer4956641)
		ret, _ := (C.VkResult)(ret4956641), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNEndCommandBuffer4956641Func PFNEndCommandBuffer

// PassRef returns a reference.
func (x PFNResetCommandBuffer) PassRef() (ref *C.PFN_vkResetCommandBuffer, allocs *cgoAllocMap) {
	if pFNResetCommandBuffer9B0911D3Func == nil {
		pFNResetCommandBuffer9B0911D3Func = x
	}
	return (*C.PFN_vkResetCommandBuffer)(C.PFN_vkResetCommandBuffer_9b0911d3), nil
}

// PassValue returns a value.
func (x PFNResetCommandBuffer) PassValue() (ref C.PFN_vkResetCommandBuffer, allocs *cgoAllocMap) {
	if pFNResetCommandBuffer9B0911D3Func == nil {
		pFNResetCommandBuffer9B0911D3Func = x
	}
	return (C.PFN_vkResetCommandBuffer)(C.PFN_vkResetCommandBuffer_9b0911d3), nil
}

//export pFNResetCommandBuffer9B0911D3
func pFNResetCommandBuffer9B0911D3(cCommandBuffer C.VkCommandBuffer, cFlags C.VkCommandBufferResetFlags) C.VkResult {
	if pFNResetCommandBuffer9B0911D3Func != nil {
		CommandBuffer9b0911d3 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		Flags9b0911d3 := (CommandBufferResetFlags)(cFlags)
		ret9b0911d3 := pFNResetCommandBuffer9B0911D3Func(CommandBuffer9b0911d3, Flags9b0911d3)
		ret, _ := (C.VkResult)(ret9b0911d3), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNResetCommandBuffer9B0911D3Func PFNResetCommandBuffer

// PassRef returns a reference.
func (x PFNCmdBindPipeline) PassRef() (ref *C.PFN_vkCmdBindPipeline, allocs *cgoAllocMap) {
	if pFNCmdBindPipelineA2C7555BFunc == nil {
		pFNCmdBindPipelineA2C7555BFunc = x
	}
	return (*C.PFN_vkCmdBindPipeline)(C.PFN_vkCmdBindPipeline_a2c7555b), nil
}

// PassValue returns a value.
func (x PFNCmdBindPipeline) PassValue() (ref C.PFN_vkCmdBindPipeline, allocs *cgoAllocMap) {
	if pFNCmdBindPipelineA2C7555BFunc == nil {
		pFNCmdBindPipelineA2C7555BFunc = x
	}
	return (C.PFN_vkCmdBindPipeline)(C.PFN_vkCmdBindPipeline_a2c7555b), nil
}

//export pFNCmdBindPipelineA2C7555B
func pFNCmdBindPipelineA2C7555B(cCommandBuffer C.VkCommandBuffer, cPipelineBindPoint C.VkPipelineBindPoint, cPipeline C.VkPipeline) {
	if pFNCmdBindPipelineA2C7555BFunc != nil {
		CommandBuffera2c7555b := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		PipelineBindPointa2c7555b := (PipelineBindPoint)(cPipelineBindPoint)
		Pipelinea2c7555b := *(*Pipeline)(unsafe.Pointer(&cPipeline))
		pFNCmdBindPipelineA2C7555BFunc(CommandBuffera2c7555b, PipelineBindPointa2c7555b, Pipelinea2c7555b)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdBindPipelineA2C7555BFunc PFNCmdBindPipeline

// PassRef returns a reference.
func (x PFNCmdSetViewport) PassRef() (ref *C.PFN_vkCmdSetViewport, allocs *cgoAllocMap) {
	if pFNCmdSetViewportEDC0E9F4Func == nil {
		pFNCmdSetViewportEDC0E9F4Func = x
	}
	return (*C.PFN_vkCmdSetViewport)(C.PFN_vkCmdSetViewport_edc0e9f4), nil
}

// PassValue returns a value.
func (x PFNCmdSetViewport) PassValue() (ref C.PFN_vkCmdSetViewport, allocs *cgoAllocMap) {
	if pFNCmdSetViewportEDC0E9F4Func == nil {
		pFNCmdSetViewportEDC0E9F4Func = x
	}
	return (C.PFN_vkCmdSetViewport)(C.PFN_vkCmdSetViewport_edc0e9f4), nil
}

//export pFNCmdSetViewportEDC0E9F4
func pFNCmdSetViewportEDC0E9F4(cCommandBuffer C.VkCommandBuffer, cFirstViewport C.uint32_t, cViewportCount C.uint32_t, cPViewports *C.VkViewport) {
	if pFNCmdSetViewportEDC0E9F4Func != nil {
		CommandBufferedc0e9f4 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		FirstViewportedc0e9f4 := (uint32)(cFirstViewport)
		ViewportCountedc0e9f4 := (uint32)(cViewportCount)
		var PViewportsedc0e9f4 []Viewport
		packSViewport(PViewportsedc0e9f4, cPViewports)
		pFNCmdSetViewportEDC0E9F4Func(CommandBufferedc0e9f4, FirstViewportedc0e9f4, ViewportCountedc0e9f4, PViewportsedc0e9f4)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdSetViewportEDC0E9F4Func PFNCmdSetViewport

// PassRef returns a reference.
func (x PFNCmdSetScissor) PassRef() (ref *C.PFN_vkCmdSetScissor, allocs *cgoAllocMap) {
	if pFNCmdSetScissorCC776C1CFunc == nil {
		pFNCmdSetScissorCC776C1CFunc = x
	}
	return (*C.PFN_vkCmdSetScissor)(C.PFN_vkCmdSetScissor_cc776c1c), nil
}

// PassValue returns a value.
func (x PFNCmdSetScissor) PassValue() (ref C.PFN_vkCmdSetScissor, allocs *cgoAllocMap) {
	if pFNCmdSetScissorCC776C1CFunc == nil {
		pFNCmdSetScissorCC776C1CFunc = x
	}
	return (C.PFN_vkCmdSetScissor)(C.PFN_vkCmdSetScissor_cc776c1c), nil
}

//export pFNCmdSetScissorCC776C1C
func pFNCmdSetScissorCC776C1C(cCommandBuffer C.VkCommandBuffer, cFirstScissor C.uint32_t, cScissorCount C.uint32_t, cPScissors *C.VkRect2D) {
	if pFNCmdSetScissorCC776C1CFunc != nil {
		CommandBuffercc776c1c := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		FirstScissorcc776c1c := (uint32)(cFirstScissor)
		ScissorCountcc776c1c := (uint32)(cScissorCount)
		var PScissorscc776c1c []Rect2D
		packSRect2D(PScissorscc776c1c, cPScissors)
		pFNCmdSetScissorCC776C1CFunc(CommandBuffercc776c1c, FirstScissorcc776c1c, ScissorCountcc776c1c, PScissorscc776c1c)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdSetScissorCC776C1CFunc PFNCmdSetScissor

// PassRef returns a reference.
func (x PFNCmdSetLineWidth) PassRef() (ref *C.PFN_vkCmdSetLineWidth, allocs *cgoAllocMap) {
	if pFNCmdSetLineWidth1080BC84Func == nil {
		pFNCmdSetLineWidth1080BC84Func = x
	}
	return (*C.PFN_vkCmdSetLineWidth)(C.PFN_vkCmdSetLineWidth_1080bc84), nil
}

// PassValue returns a value.
func (x PFNCmdSetLineWidth) PassValue() (ref C.PFN_vkCmdSetLineWidth, allocs *cgoAllocMap) {
	if pFNCmdSetLineWidth1080BC84Func == nil {
		pFNCmdSetLineWidth1080BC84Func = x
	}
	return (C.PFN_vkCmdSetLineWidth)(C.PFN_vkCmdSetLineWidth_1080bc84), nil
}

//export pFNCmdSetLineWidth1080BC84
func pFNCmdSetLineWidth1080BC84(cCommandBuffer C.VkCommandBuffer, cLineWidth C.float) {
	if pFNCmdSetLineWidth1080BC84Func != nil {
		CommandBuffer1080bc84 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		LineWidth1080bc84 := (float32)(cLineWidth)
		pFNCmdSetLineWidth1080BC84Func(CommandBuffer1080bc84, LineWidth1080bc84)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdSetLineWidth1080BC84Func PFNCmdSetLineWidth

// PassRef returns a reference.
func (x PFNCmdSetDepthBias) PassRef() (ref *C.PFN_vkCmdSetDepthBias, allocs *cgoAllocMap) {
	if pFNCmdSetDepthBiasE2D686BDFunc == nil {
		pFNCmdSetDepthBiasE2D686BDFunc = x
	}
	return (*C.PFN_vkCmdSetDepthBias)(C.PFN_vkCmdSetDepthBias_e2d686bd), nil
}

// PassValue returns a value.
func (x PFNCmdSetDepthBias) PassValue() (ref C.PFN_vkCmdSetDepthBias, allocs *cgoAllocMap) {
	if pFNCmdSetDepthBiasE2D686BDFunc == nil {
		pFNCmdSetDepthBiasE2D686BDFunc = x
	}
	return (C.PFN_vkCmdSetDepthBias)(C.PFN_vkCmdSetDepthBias_e2d686bd), nil
}

//export pFNCmdSetDepthBiasE2D686BD
func pFNCmdSetDepthBiasE2D686BD(cCommandBuffer C.VkCommandBuffer, cDepthBiasConstantFactor C.float, cDepthBiasClamp C.float, cDepthBiasSlopeFactor C.float) {
	if pFNCmdSetDepthBiasE2D686BDFunc != nil {
		CommandBuffere2d686bd := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		DepthBiasConstantFactore2d686bd := (float32)(cDepthBiasConstantFactor)
		DepthBiasClampe2d686bd := (float32)(cDepthBiasClamp)
		DepthBiasSlopeFactore2d686bd := (float32)(cDepthBiasSlopeFactor)
		pFNCmdSetDepthBiasE2D686BDFunc(CommandBuffere2d686bd, DepthBiasConstantFactore2d686bd, DepthBiasClampe2d686bd, DepthBiasSlopeFactore2d686bd)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdSetDepthBiasE2D686BDFunc PFNCmdSetDepthBias

// PassRef returns a reference.
func (x PFNCmdSetDepthBounds) PassRef() (ref *C.PFN_vkCmdSetDepthBounds, allocs *cgoAllocMap) {
	if pFNCmdSetDepthBounds98318DA7Func == nil {
		pFNCmdSetDepthBounds98318DA7Func = x
	}
	return (*C.PFN_vkCmdSetDepthBounds)(C.PFN_vkCmdSetDepthBounds_98318da7), nil
}

// PassValue returns a value.
func (x PFNCmdSetDepthBounds) PassValue() (ref C.PFN_vkCmdSetDepthBounds, allocs *cgoAllocMap) {
	if pFNCmdSetDepthBounds98318DA7Func == nil {
		pFNCmdSetDepthBounds98318DA7Func = x
	}
	return (C.PFN_vkCmdSetDepthBounds)(C.PFN_vkCmdSetDepthBounds_98318da7), nil
}

//export pFNCmdSetDepthBounds98318DA7
func pFNCmdSetDepthBounds98318DA7(cCommandBuffer C.VkCommandBuffer, cMinDepthBounds C.float, cMaxDepthBounds C.float) {
	if pFNCmdSetDepthBounds98318DA7Func != nil {
		CommandBuffer98318da7 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		MinDepthBounds98318da7 := (float32)(cMinDepthBounds)
		MaxDepthBounds98318da7 := (float32)(cMaxDepthBounds)
		pFNCmdSetDepthBounds98318DA7Func(CommandBuffer98318da7, MinDepthBounds98318da7, MaxDepthBounds98318da7)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdSetDepthBounds98318DA7Func PFNCmdSetDepthBounds

// PassRef returns a reference.
func (x PFNCmdSetStencilCompareMask) PassRef() (ref *C.PFN_vkCmdSetStencilCompareMask, allocs *cgoAllocMap) {
	if pFNCmdSetStencilCompareMask1C528E50Func == nil {
		pFNCmdSetStencilCompareMask1C528E50Func = x
	}
	return (*C.PFN_vkCmdSetStencilCompareMask)(C.PFN_vkCmdSetStencilCompareMask_1c528e50), nil
}

// PassValue returns a value.
func (x PFNCmdSetStencilCompareMask) PassValue() (ref C.PFN_vkCmdSetStencilCompareMask, allocs *cgoAllocMap) {
	if pFNCmdSetStencilCompareMask1C528E50Func == nil {
		pFNCmdSetStencilCompareMask1C528E50Func = x
	}
	return (C.PFN_vkCmdSetStencilCompareMask)(C.PFN_vkCmdSetStencilCompareMask_1c528e50), nil
}

//export pFNCmdSetStencilCompareMask1C528E50
func pFNCmdSetStencilCompareMask1C528E50(cCommandBuffer C.VkCommandBuffer, cFaceMask C.VkStencilFaceFlags, cCompareMask C.uint32_t) {
	if pFNCmdSetStencilCompareMask1C528E50Func != nil {
		CommandBuffer1c528e50 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		FaceMask1c528e50 := (StencilFaceFlags)(cFaceMask)
		CompareMask1c528e50 := (uint32)(cCompareMask)
		pFNCmdSetStencilCompareMask1C528E50Func(CommandBuffer1c528e50, FaceMask1c528e50, CompareMask1c528e50)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdSetStencilCompareMask1C528E50Func PFNCmdSetStencilCompareMask

// PassRef returns a reference.
func (x PFNCmdSetStencilWriteMask) PassRef() (ref *C.PFN_vkCmdSetStencilWriteMask, allocs *cgoAllocMap) {
	if pFNCmdSetStencilWriteMask663BC6F1Func == nil {
		pFNCmdSetStencilWriteMask663BC6F1Func = x
	}
	return (*C.PFN_vkCmdSetStencilWriteMask)(C.PFN_vkCmdSetStencilWriteMask_663bc6f1), nil
}

// PassValue returns a value.
func (x PFNCmdSetStencilWriteMask) PassValue() (ref C.PFN_vkCmdSetStencilWriteMask, allocs *cgoAllocMap) {
	if pFNCmdSetStencilWriteMask663BC6F1Func == nil {
		pFNCmdSetStencilWriteMask663BC6F1Func = x
	}
	return (C.PFN_vkCmdSetStencilWriteMask)(C.PFN_vkCmdSetStencilWriteMask_663bc6f1), nil
}

//export pFNCmdSetStencilWriteMask663BC6F1
func pFNCmdSetStencilWriteMask663BC6F1(cCommandBuffer C.VkCommandBuffer, cFaceMask C.VkStencilFaceFlags, cWriteMask C.uint32_t) {
	if pFNCmdSetStencilWriteMask663BC6F1Func != nil {
		CommandBuffer663bc6f1 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		FaceMask663bc6f1 := (StencilFaceFlags)(cFaceMask)
		WriteMask663bc6f1 := (uint32)(cWriteMask)
		pFNCmdSetStencilWriteMask663BC6F1Func(CommandBuffer663bc6f1, FaceMask663bc6f1, WriteMask663bc6f1)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdSetStencilWriteMask663BC6F1Func PFNCmdSetStencilWriteMask

// PassRef returns a reference.
func (x PFNCmdSetStencilReference) PassRef() (ref *C.PFN_vkCmdSetStencilReference, allocs *cgoAllocMap) {
	if pFNCmdSetStencilReference7570AE73Func == nil {
		pFNCmdSetStencilReference7570AE73Func = x
	}
	return (*C.PFN_vkCmdSetStencilReference)(C.PFN_vkCmdSetStencilReference_7570ae73), nil
}

// PassValue returns a value.
func (x PFNCmdSetStencilReference) PassValue() (ref C.PFN_vkCmdSetStencilReference, allocs *cgoAllocMap) {
	if pFNCmdSetStencilReference7570AE73Func == nil {
		pFNCmdSetStencilReference7570AE73Func = x
	}
	return (C.PFN_vkCmdSetStencilReference)(C.PFN_vkCmdSetStencilReference_7570ae73), nil
}

//export pFNCmdSetStencilReference7570AE73
func pFNCmdSetStencilReference7570AE73(cCommandBuffer C.VkCommandBuffer, cFaceMask C.VkStencilFaceFlags, cReference C.uint32_t) {
	if pFNCmdSetStencilReference7570AE73Func != nil {
		CommandBuffer7570ae73 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		FaceMask7570ae73 := (StencilFaceFlags)(cFaceMask)
		Reference7570ae73 := (uint32)(cReference)
		pFNCmdSetStencilReference7570AE73Func(CommandBuffer7570ae73, FaceMask7570ae73, Reference7570ae73)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdSetStencilReference7570AE73Func PFNCmdSetStencilReference

// PassRef returns a reference.
func (x PFNCmdBindDescriptorSets) PassRef() (ref *C.PFN_vkCmdBindDescriptorSets, allocs *cgoAllocMap) {
	if pFNCmdBindDescriptorSets92256A49Func == nil {
		pFNCmdBindDescriptorSets92256A49Func = x
	}
	return (*C.PFN_vkCmdBindDescriptorSets)(C.PFN_vkCmdBindDescriptorSets_92256a49), nil
}

// PassValue returns a value.
func (x PFNCmdBindDescriptorSets) PassValue() (ref C.PFN_vkCmdBindDescriptorSets, allocs *cgoAllocMap) {
	if pFNCmdBindDescriptorSets92256A49Func == nil {
		pFNCmdBindDescriptorSets92256A49Func = x
	}
	return (C.PFN_vkCmdBindDescriptorSets)(C.PFN_vkCmdBindDescriptorSets_92256a49), nil
}

//export pFNCmdBindDescriptorSets92256A49
func pFNCmdBindDescriptorSets92256A49(cCommandBuffer C.VkCommandBuffer, cPipelineBindPoint C.VkPipelineBindPoint, cLayout C.VkPipelineLayout, cFirstSet C.uint32_t, cDescriptorSetCount C.uint32_t, cPDescriptorSets *C.VkDescriptorSet, cDynamicOffsetCount C.uint32_t, cPDynamicOffsets *C.uint32_t) {
	if pFNCmdBindDescriptorSets92256A49Func != nil {
		CommandBuffer92256a49 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		PipelineBindPoint92256a49 := (PipelineBindPoint)(cPipelineBindPoint)
		Layout92256a49 := *(*PipelineLayout)(unsafe.Pointer(&cLayout))
		FirstSet92256a49 := (uint32)(cFirstSet)
		DescriptorSetCount92256a49 := (uint32)(cDescriptorSetCount)
		var PDescriptorSets92256a49 []DescriptorSet
		hxfaa359c := (*sliceHeader)(unsafe.Pointer(&PDescriptorSets92256a49))
		hxfaa359c.Data = uintptr(unsafe.Pointer(cPDescriptorSets))
		hxfaa359c.Cap = 0x7fffffff
		// hxfaa359c.Len = ?

		DynamicOffsetCount92256a49 := (uint32)(cDynamicOffsetCount)
		var PDynamicOffsets92256a49 []uint32
		hxfa897de := (*sliceHeader)(unsafe.Pointer(&PDynamicOffsets92256a49))
		hxfa897de.Data = uintptr(unsafe.Pointer(cPDynamicOffsets))
		hxfa897de.Cap = 0x7fffffff
		// hxfa897de.Len = ?

		pFNCmdBindDescriptorSets92256A49Func(CommandBuffer92256a49, PipelineBindPoint92256a49, Layout92256a49, FirstSet92256a49, DescriptorSetCount92256a49, PDescriptorSets92256a49, DynamicOffsetCount92256a49, PDynamicOffsets92256a49)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdBindDescriptorSets92256A49Func PFNCmdBindDescriptorSets

// PassRef returns a reference.
func (x PFNCmdBindIndexBuffer) PassRef() (ref *C.PFN_vkCmdBindIndexBuffer, allocs *cgoAllocMap) {
	if pFNCmdBindIndexBuffer8A8B689CFunc == nil {
		pFNCmdBindIndexBuffer8A8B689CFunc = x
	}
	return (*C.PFN_vkCmdBindIndexBuffer)(C.PFN_vkCmdBindIndexBuffer_8a8b689c), nil
}

// PassValue returns a value.
func (x PFNCmdBindIndexBuffer) PassValue() (ref C.PFN_vkCmdBindIndexBuffer, allocs *cgoAllocMap) {
	if pFNCmdBindIndexBuffer8A8B689CFunc == nil {
		pFNCmdBindIndexBuffer8A8B689CFunc = x
	}
	return (C.PFN_vkCmdBindIndexBuffer)(C.PFN_vkCmdBindIndexBuffer_8a8b689c), nil
}

//export pFNCmdBindIndexBuffer8A8B689C
func pFNCmdBindIndexBuffer8A8B689C(cCommandBuffer C.VkCommandBuffer, cBuffer C.VkBuffer, cOffset C.VkDeviceSize, cIndexType C.VkIndexType) {
	if pFNCmdBindIndexBuffer8A8B689CFunc != nil {
		CommandBuffer8a8b689c := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		Buffer8a8b689c := *(*Buffer)(unsafe.Pointer(&cBuffer))
		Offset8a8b689c := (DeviceSize)(cOffset)
		IndexType8a8b689c := (IndexType)(cIndexType)
		pFNCmdBindIndexBuffer8A8B689CFunc(CommandBuffer8a8b689c, Buffer8a8b689c, Offset8a8b689c, IndexType8a8b689c)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdBindIndexBuffer8A8B689CFunc PFNCmdBindIndexBuffer

// PassRef returns a reference.
func (x PFNCmdBindVertexBuffers) PassRef() (ref *C.PFN_vkCmdBindVertexBuffers, allocs *cgoAllocMap) {
	if pFNCmdBindVertexBuffersCD53A724Func == nil {
		pFNCmdBindVertexBuffersCD53A724Func = x
	}
	return (*C.PFN_vkCmdBindVertexBuffers)(C.PFN_vkCmdBindVertexBuffers_cd53a724), nil
}

// PassValue returns a value.
func (x PFNCmdBindVertexBuffers) PassValue() (ref C.PFN_vkCmdBindVertexBuffers, allocs *cgoAllocMap) {
	if pFNCmdBindVertexBuffersCD53A724Func == nil {
		pFNCmdBindVertexBuffersCD53A724Func = x
	}
	return (C.PFN_vkCmdBindVertexBuffers)(C.PFN_vkCmdBindVertexBuffers_cd53a724), nil
}

//export pFNCmdBindVertexBuffersCD53A724
func pFNCmdBindVertexBuffersCD53A724(cCommandBuffer C.VkCommandBuffer, cFirstBinding C.uint32_t, cBindingCount C.uint32_t, cPBuffers *C.VkBuffer, cPOffsets *C.VkDeviceSize) {
	if pFNCmdBindVertexBuffersCD53A724Func != nil {
		CommandBuffercd53a724 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		FirstBindingcd53a724 := (uint32)(cFirstBinding)
		BindingCountcd53a724 := (uint32)(cBindingCount)
		var PBufferscd53a724 []Buffer
		hxfe33f90 := (*sliceHeader)(unsafe.Pointer(&PBufferscd53a724))
		hxfe33f90.Data = uintptr(unsafe.Pointer(cPBuffers))
		hxfe33f90.Cap = 0x7fffffff
		// hxfe33f90.Len = ?

		var POffsetscd53a724 []DeviceSize
		hxf08bba9 := (*sliceHeader)(unsafe.Pointer(&POffsetscd53a724))
		hxf08bba9.Data = uintptr(unsafe.Pointer(cPOffsets))
		hxf08bba9.Cap = 0x7fffffff
		// hxf08bba9.Len = ?

		pFNCmdBindVertexBuffersCD53A724Func(CommandBuffercd53a724, FirstBindingcd53a724, BindingCountcd53a724, PBufferscd53a724, POffsetscd53a724)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdBindVertexBuffersCD53A724Func PFNCmdBindVertexBuffers

// PassRef returns a reference.
func (x PFNCmdDraw) PassRef() (ref *C.PFN_vkCmdDraw, allocs *cgoAllocMap) {
	if pFNCmdDraw4706E5BDFunc == nil {
		pFNCmdDraw4706E5BDFunc = x
	}
	return (*C.PFN_vkCmdDraw)(C.PFN_vkCmdDraw_4706e5bd), nil
}

// PassValue returns a value.
func (x PFNCmdDraw) PassValue() (ref C.PFN_vkCmdDraw, allocs *cgoAllocMap) {
	if pFNCmdDraw4706E5BDFunc == nil {
		pFNCmdDraw4706E5BDFunc = x
	}
	return (C.PFN_vkCmdDraw)(C.PFN_vkCmdDraw_4706e5bd), nil
}

//export pFNCmdDraw4706E5BD
func pFNCmdDraw4706E5BD(cCommandBuffer C.VkCommandBuffer, cVertexCount C.uint32_t, cInstanceCount C.uint32_t, cFirstVertex C.uint32_t, cFirstInstance C.uint32_t) {
	if pFNCmdDraw4706E5BDFunc != nil {
		CommandBuffer4706e5bd := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		VertexCount4706e5bd := (uint32)(cVertexCount)
		InstanceCount4706e5bd := (uint32)(cInstanceCount)
		FirstVertex4706e5bd := (uint32)(cFirstVertex)
		FirstInstance4706e5bd := (uint32)(cFirstInstance)
		pFNCmdDraw4706E5BDFunc(CommandBuffer4706e5bd, VertexCount4706e5bd, InstanceCount4706e5bd, FirstVertex4706e5bd, FirstInstance4706e5bd)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdDraw4706E5BDFunc PFNCmdDraw

// PassRef returns a reference.
func (x PFNCmdDrawIndexed) PassRef() (ref *C.PFN_vkCmdDrawIndexed, allocs *cgoAllocMap) {
	if pFNCmdDrawIndexed9854657CFunc == nil {
		pFNCmdDrawIndexed9854657CFunc = x
	}
	return (*C.PFN_vkCmdDrawIndexed)(C.PFN_vkCmdDrawIndexed_9854657c), nil
}

// PassValue returns a value.
func (x PFNCmdDrawIndexed) PassValue() (ref C.PFN_vkCmdDrawIndexed, allocs *cgoAllocMap) {
	if pFNCmdDrawIndexed9854657CFunc == nil {
		pFNCmdDrawIndexed9854657CFunc = x
	}
	return (C.PFN_vkCmdDrawIndexed)(C.PFN_vkCmdDrawIndexed_9854657c), nil
}

//export pFNCmdDrawIndexed9854657C
func pFNCmdDrawIndexed9854657C(cCommandBuffer C.VkCommandBuffer, cIndexCount C.uint32_t, cInstanceCount C.uint32_t, cFirstIndex C.uint32_t, cVertexOffset C.int32_t, cFirstInstance C.uint32_t) {
	if pFNCmdDrawIndexed9854657CFunc != nil {
		CommandBuffer9854657c := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		IndexCount9854657c := (uint32)(cIndexCount)
		InstanceCount9854657c := (uint32)(cInstanceCount)
		FirstIndex9854657c := (uint32)(cFirstIndex)
		VertexOffset9854657c := (int32)(cVertexOffset)
		FirstInstance9854657c := (uint32)(cFirstInstance)
		pFNCmdDrawIndexed9854657CFunc(CommandBuffer9854657c, IndexCount9854657c, InstanceCount9854657c, FirstIndex9854657c, VertexOffset9854657c, FirstInstance9854657c)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdDrawIndexed9854657CFunc PFNCmdDrawIndexed

// PassRef returns a reference.
func (x PFNCmdDrawIndirect) PassRef() (ref *C.PFN_vkCmdDrawIndirect, allocs *cgoAllocMap) {
	if pFNCmdDrawIndirect394DA878Func == nil {
		pFNCmdDrawIndirect394DA878Func = x
	}
	return (*C.PFN_vkCmdDrawIndirect)(C.PFN_vkCmdDrawIndirect_394da878), nil
}

// PassValue returns a value.
func (x PFNCmdDrawIndirect) PassValue() (ref C.PFN_vkCmdDrawIndirect, allocs *cgoAllocMap) {
	if pFNCmdDrawIndirect394DA878Func == nil {
		pFNCmdDrawIndirect394DA878Func = x
	}
	return (C.PFN_vkCmdDrawIndirect)(C.PFN_vkCmdDrawIndirect_394da878), nil
}

//export pFNCmdDrawIndirect394DA878
func pFNCmdDrawIndirect394DA878(cCommandBuffer C.VkCommandBuffer, cBuffer C.VkBuffer, cOffset C.VkDeviceSize, cDrawCount C.uint32_t, cStride C.uint32_t) {
	if pFNCmdDrawIndirect394DA878Func != nil {
		CommandBuffer394da878 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		Buffer394da878 := *(*Buffer)(unsafe.Pointer(&cBuffer))
		Offset394da878 := (DeviceSize)(cOffset)
		DrawCount394da878 := (uint32)(cDrawCount)
		Stride394da878 := (uint32)(cStride)
		pFNCmdDrawIndirect394DA878Func(CommandBuffer394da878, Buffer394da878, Offset394da878, DrawCount394da878, Stride394da878)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdDrawIndirect394DA878Func PFNCmdDrawIndirect

// PassRef returns a reference.
func (x PFNCmdDrawIndexedIndirect) PassRef() (ref *C.PFN_vkCmdDrawIndexedIndirect, allocs *cgoAllocMap) {
	if pFNCmdDrawIndexedIndirect4DB44457Func == nil {
		pFNCmdDrawIndexedIndirect4DB44457Func = x
	}
	return (*C.PFN_vkCmdDrawIndexedIndirect)(C.PFN_vkCmdDrawIndexedIndirect_4db44457), nil
}

// PassValue returns a value.
func (x PFNCmdDrawIndexedIndirect) PassValue() (ref C.PFN_vkCmdDrawIndexedIndirect, allocs *cgoAllocMap) {
	if pFNCmdDrawIndexedIndirect4DB44457Func == nil {
		pFNCmdDrawIndexedIndirect4DB44457Func = x
	}
	return (C.PFN_vkCmdDrawIndexedIndirect)(C.PFN_vkCmdDrawIndexedIndirect_4db44457), nil
}

//export pFNCmdDrawIndexedIndirect4DB44457
func pFNCmdDrawIndexedIndirect4DB44457(cCommandBuffer C.VkCommandBuffer, cBuffer C.VkBuffer, cOffset C.VkDeviceSize, cDrawCount C.uint32_t, cStride C.uint32_t) {
	if pFNCmdDrawIndexedIndirect4DB44457Func != nil {
		CommandBuffer4db44457 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		Buffer4db44457 := *(*Buffer)(unsafe.Pointer(&cBuffer))
		Offset4db44457 := (DeviceSize)(cOffset)
		DrawCount4db44457 := (uint32)(cDrawCount)
		Stride4db44457 := (uint32)(cStride)
		pFNCmdDrawIndexedIndirect4DB44457Func(CommandBuffer4db44457, Buffer4db44457, Offset4db44457, DrawCount4db44457, Stride4db44457)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdDrawIndexedIndirect4DB44457Func PFNCmdDrawIndexedIndirect

// PassRef returns a reference.
func (x PFNCmdDispatch) PassRef() (ref *C.PFN_vkCmdDispatch, allocs *cgoAllocMap) {
	if pFNCmdDispatch9BAB1EF5Func == nil {
		pFNCmdDispatch9BAB1EF5Func = x
	}
	return (*C.PFN_vkCmdDispatch)(C.PFN_vkCmdDispatch_9bab1ef5), nil
}

// PassValue returns a value.
func (x PFNCmdDispatch) PassValue() (ref C.PFN_vkCmdDispatch, allocs *cgoAllocMap) {
	if pFNCmdDispatch9BAB1EF5Func == nil {
		pFNCmdDispatch9BAB1EF5Func = x
	}
	return (C.PFN_vkCmdDispatch)(C.PFN_vkCmdDispatch_9bab1ef5), nil
}

//export pFNCmdDispatch9BAB1EF5
func pFNCmdDispatch9BAB1EF5(cCommandBuffer C.VkCommandBuffer, cX C.uint32_t, cY C.uint32_t, cZ C.uint32_t) {
	if pFNCmdDispatch9BAB1EF5Func != nil {
		CommandBuffer9bab1ef5 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		X9bab1ef5 := (uint32)(cX)
		Y9bab1ef5 := (uint32)(cY)
		Z9bab1ef5 := (uint32)(cZ)
		pFNCmdDispatch9BAB1EF5Func(CommandBuffer9bab1ef5, X9bab1ef5, Y9bab1ef5, Z9bab1ef5)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdDispatch9BAB1EF5Func PFNCmdDispatch

// PassRef returns a reference.
func (x PFNCmdDispatchIndirect) PassRef() (ref *C.PFN_vkCmdDispatchIndirect, allocs *cgoAllocMap) {
	if pFNCmdDispatchIndirect4CCB8F6BFunc == nil {
		pFNCmdDispatchIndirect4CCB8F6BFunc = x
	}
	return (*C.PFN_vkCmdDispatchIndirect)(C.PFN_vkCmdDispatchIndirect_4ccb8f6b), nil
}

// PassValue returns a value.
func (x PFNCmdDispatchIndirect) PassValue() (ref C.PFN_vkCmdDispatchIndirect, allocs *cgoAllocMap) {
	if pFNCmdDispatchIndirect4CCB8F6BFunc == nil {
		pFNCmdDispatchIndirect4CCB8F6BFunc = x
	}
	return (C.PFN_vkCmdDispatchIndirect)(C.PFN_vkCmdDispatchIndirect_4ccb8f6b), nil
}

//export pFNCmdDispatchIndirect4CCB8F6B
func pFNCmdDispatchIndirect4CCB8F6B(cCommandBuffer C.VkCommandBuffer, cBuffer C.VkBuffer, cOffset C.VkDeviceSize) {
	if pFNCmdDispatchIndirect4CCB8F6BFunc != nil {
		CommandBuffer4ccb8f6b := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		Buffer4ccb8f6b := *(*Buffer)(unsafe.Pointer(&cBuffer))
		Offset4ccb8f6b := (DeviceSize)(cOffset)
		pFNCmdDispatchIndirect4CCB8F6BFunc(CommandBuffer4ccb8f6b, Buffer4ccb8f6b, Offset4ccb8f6b)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdDispatchIndirect4CCB8F6BFunc PFNCmdDispatchIndirect

// packSBufferCopy reads sliced Go data structure out from plain C format.
func packSBufferCopy(v []BufferCopy, ptr0 *C.VkBufferCopy) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferCopyValue]C.VkBufferCopy)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferCopyRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCmdCopyBuffer) PassRef() (ref *C.PFN_vkCmdCopyBuffer, allocs *cgoAllocMap) {
	if pFNCmdCopyBuffer7F558DEEFunc == nil {
		pFNCmdCopyBuffer7F558DEEFunc = x
	}
	return (*C.PFN_vkCmdCopyBuffer)(C.PFN_vkCmdCopyBuffer_7f558dee), nil
}

// PassValue returns a value.
func (x PFNCmdCopyBuffer) PassValue() (ref C.PFN_vkCmdCopyBuffer, allocs *cgoAllocMap) {
	if pFNCmdCopyBuffer7F558DEEFunc == nil {
		pFNCmdCopyBuffer7F558DEEFunc = x
	}
	return (C.PFN_vkCmdCopyBuffer)(C.PFN_vkCmdCopyBuffer_7f558dee), nil
}

//export pFNCmdCopyBuffer7F558DEE
func pFNCmdCopyBuffer7F558DEE(cCommandBuffer C.VkCommandBuffer, cSrcBuffer C.VkBuffer, cDstBuffer C.VkBuffer, cRegionCount C.uint32_t, cPRegions *C.VkBufferCopy) {
	if pFNCmdCopyBuffer7F558DEEFunc != nil {
		CommandBuffer7f558dee := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		SrcBuffer7f558dee := *(*Buffer)(unsafe.Pointer(&cSrcBuffer))
		DstBuffer7f558dee := *(*Buffer)(unsafe.Pointer(&cDstBuffer))
		RegionCount7f558dee := (uint32)(cRegionCount)
		var PRegions7f558dee []BufferCopy
		packSBufferCopy(PRegions7f558dee, cPRegions)
		pFNCmdCopyBuffer7F558DEEFunc(CommandBuffer7f558dee, SrcBuffer7f558dee, DstBuffer7f558dee, RegionCount7f558dee, PRegions7f558dee)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdCopyBuffer7F558DEEFunc PFNCmdCopyBuffer

// packSImageCopy reads sliced Go data structure out from plain C format.
func packSImageCopy(v []ImageCopy, ptr0 *C.VkImageCopy) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageCopyValue]C.VkImageCopy)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageCopyRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCmdCopyImage) PassRef() (ref *C.PFN_vkCmdCopyImage, allocs *cgoAllocMap) {
	if pFNCmdCopyImageCEC34CBDFunc == nil {
		pFNCmdCopyImageCEC34CBDFunc = x
	}
	return (*C.PFN_vkCmdCopyImage)(C.PFN_vkCmdCopyImage_cec34cbd), nil
}

// PassValue returns a value.
func (x PFNCmdCopyImage) PassValue() (ref C.PFN_vkCmdCopyImage, allocs *cgoAllocMap) {
	if pFNCmdCopyImageCEC34CBDFunc == nil {
		pFNCmdCopyImageCEC34CBDFunc = x
	}
	return (C.PFN_vkCmdCopyImage)(C.PFN_vkCmdCopyImage_cec34cbd), nil
}

//export pFNCmdCopyImageCEC34CBD
func pFNCmdCopyImageCEC34CBD(cCommandBuffer C.VkCommandBuffer, cSrcImage C.VkImage, cSrcImageLayout C.VkImageLayout, cDstImage C.VkImage, cDstImageLayout C.VkImageLayout, cRegionCount C.uint32_t, cPRegions *C.VkImageCopy) {
	if pFNCmdCopyImageCEC34CBDFunc != nil {
		CommandBuffercec34cbd := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		SrcImagecec34cbd := *(*Image)(unsafe.Pointer(&cSrcImage))
		SrcImageLayoutcec34cbd := (ImageLayout)(cSrcImageLayout)
		DstImagecec34cbd := *(*Image)(unsafe.Pointer(&cDstImage))
		DstImageLayoutcec34cbd := (ImageLayout)(cDstImageLayout)
		RegionCountcec34cbd := (uint32)(cRegionCount)
		var PRegionscec34cbd []ImageCopy
		packSImageCopy(PRegionscec34cbd, cPRegions)
		pFNCmdCopyImageCEC34CBDFunc(CommandBuffercec34cbd, SrcImagecec34cbd, SrcImageLayoutcec34cbd, DstImagecec34cbd, DstImageLayoutcec34cbd, RegionCountcec34cbd, PRegionscec34cbd)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdCopyImageCEC34CBDFunc PFNCmdCopyImage

// packSImageBlit reads sliced Go data structure out from plain C format.
func packSImageBlit(v []ImageBlit, ptr0 *C.VkImageBlit) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageBlitValue]C.VkImageBlit)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageBlitRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCmdBlitImage) PassRef() (ref *C.PFN_vkCmdBlitImage, allocs *cgoAllocMap) {
	if pFNCmdBlitImage19EF95DEFunc == nil {
		pFNCmdBlitImage19EF95DEFunc = x
	}
	return (*C.PFN_vkCmdBlitImage)(C.PFN_vkCmdBlitImage_19ef95de), nil
}

// PassValue returns a value.
func (x PFNCmdBlitImage) PassValue() (ref C.PFN_vkCmdBlitImage, allocs *cgoAllocMap) {
	if pFNCmdBlitImage19EF95DEFunc == nil {
		pFNCmdBlitImage19EF95DEFunc = x
	}
	return (C.PFN_vkCmdBlitImage)(C.PFN_vkCmdBlitImage_19ef95de), nil
}

//export pFNCmdBlitImage19EF95DE
func pFNCmdBlitImage19EF95DE(cCommandBuffer C.VkCommandBuffer, cSrcImage C.VkImage, cSrcImageLayout C.VkImageLayout, cDstImage C.VkImage, cDstImageLayout C.VkImageLayout, cRegionCount C.uint32_t, cPRegions *C.VkImageBlit, cFilter C.VkFilter) {
	if pFNCmdBlitImage19EF95DEFunc != nil {
		CommandBuffer19ef95de := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		SrcImage19ef95de := *(*Image)(unsafe.Pointer(&cSrcImage))
		SrcImageLayout19ef95de := (ImageLayout)(cSrcImageLayout)
		DstImage19ef95de := *(*Image)(unsafe.Pointer(&cDstImage))
		DstImageLayout19ef95de := (ImageLayout)(cDstImageLayout)
		RegionCount19ef95de := (uint32)(cRegionCount)
		var PRegions19ef95de []ImageBlit
		packSImageBlit(PRegions19ef95de, cPRegions)
		Filter19ef95de := (Filter)(cFilter)
		pFNCmdBlitImage19EF95DEFunc(CommandBuffer19ef95de, SrcImage19ef95de, SrcImageLayout19ef95de, DstImage19ef95de, DstImageLayout19ef95de, RegionCount19ef95de, PRegions19ef95de, Filter19ef95de)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdBlitImage19EF95DEFunc PFNCmdBlitImage

// packSBufferImageCopy reads sliced Go data structure out from plain C format.
func packSBufferImageCopy(v []BufferImageCopy, ptr0 *C.VkBufferImageCopy) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferImageCopyValue]C.VkBufferImageCopy)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferImageCopyRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCmdCopyBufferToImage) PassRef() (ref *C.PFN_vkCmdCopyBufferToImage, allocs *cgoAllocMap) {
	if pFNCmdCopyBufferToImage4394592EFunc == nil {
		pFNCmdCopyBufferToImage4394592EFunc = x
	}
	return (*C.PFN_vkCmdCopyBufferToImage)(C.PFN_vkCmdCopyBufferToImage_4394592e), nil
}

// PassValue returns a value.
func (x PFNCmdCopyBufferToImage) PassValue() (ref C.PFN_vkCmdCopyBufferToImage, allocs *cgoAllocMap) {
	if pFNCmdCopyBufferToImage4394592EFunc == nil {
		pFNCmdCopyBufferToImage4394592EFunc = x
	}
	return (C.PFN_vkCmdCopyBufferToImage)(C.PFN_vkCmdCopyBufferToImage_4394592e), nil
}

//export pFNCmdCopyBufferToImage4394592E
func pFNCmdCopyBufferToImage4394592E(cCommandBuffer C.VkCommandBuffer, cSrcBuffer C.VkBuffer, cDstImage C.VkImage, cDstImageLayout C.VkImageLayout, cRegionCount C.uint32_t, cPRegions *C.VkBufferImageCopy) {
	if pFNCmdCopyBufferToImage4394592EFunc != nil {
		CommandBuffer4394592e := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		SrcBuffer4394592e := *(*Buffer)(unsafe.Pointer(&cSrcBuffer))
		DstImage4394592e := *(*Image)(unsafe.Pointer(&cDstImage))
		DstImageLayout4394592e := (ImageLayout)(cDstImageLayout)
		RegionCount4394592e := (uint32)(cRegionCount)
		var PRegions4394592e []BufferImageCopy
		packSBufferImageCopy(PRegions4394592e, cPRegions)
		pFNCmdCopyBufferToImage4394592EFunc(CommandBuffer4394592e, SrcBuffer4394592e, DstImage4394592e, DstImageLayout4394592e, RegionCount4394592e, PRegions4394592e)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdCopyBufferToImage4394592EFunc PFNCmdCopyBufferToImage

// PassRef returns a reference.
func (x PFNCmdCopyImageToBuffer) PassRef() (ref *C.PFN_vkCmdCopyImageToBuffer, allocs *cgoAllocMap) {
	if pFNCmdCopyImageToBuffer4185ACE5Func == nil {
		pFNCmdCopyImageToBuffer4185ACE5Func = x
	}
	return (*C.PFN_vkCmdCopyImageToBuffer)(C.PFN_vkCmdCopyImageToBuffer_4185ace5), nil
}

// PassValue returns a value.
func (x PFNCmdCopyImageToBuffer) PassValue() (ref C.PFN_vkCmdCopyImageToBuffer, allocs *cgoAllocMap) {
	if pFNCmdCopyImageToBuffer4185ACE5Func == nil {
		pFNCmdCopyImageToBuffer4185ACE5Func = x
	}
	return (C.PFN_vkCmdCopyImageToBuffer)(C.PFN_vkCmdCopyImageToBuffer_4185ace5), nil
}

//export pFNCmdCopyImageToBuffer4185ACE5
func pFNCmdCopyImageToBuffer4185ACE5(cCommandBuffer C.VkCommandBuffer, cSrcImage C.VkImage, cSrcImageLayout C.VkImageLayout, cDstBuffer C.VkBuffer, cRegionCount C.uint32_t, cPRegions *C.VkBufferImageCopy) {
	if pFNCmdCopyImageToBuffer4185ACE5Func != nil {
		CommandBuffer4185ace5 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		SrcImage4185ace5 := *(*Image)(unsafe.Pointer(&cSrcImage))
		SrcImageLayout4185ace5 := (ImageLayout)(cSrcImageLayout)
		DstBuffer4185ace5 := *(*Buffer)(unsafe.Pointer(&cDstBuffer))
		RegionCount4185ace5 := (uint32)(cRegionCount)
		var PRegions4185ace5 []BufferImageCopy
		packSBufferImageCopy(PRegions4185ace5, cPRegions)
		pFNCmdCopyImageToBuffer4185ACE5Func(CommandBuffer4185ace5, SrcImage4185ace5, SrcImageLayout4185ace5, DstBuffer4185ace5, RegionCount4185ace5, PRegions4185ace5)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdCopyImageToBuffer4185ACE5Func PFNCmdCopyImageToBuffer

// PassRef returns a reference.
func (x PFNCmdUpdateBuffer) PassRef() (ref *C.PFN_vkCmdUpdateBuffer, allocs *cgoAllocMap) {
	if pFNCmdUpdateBufferC541B249Func == nil {
		pFNCmdUpdateBufferC541B249Func = x
	}
	return (*C.PFN_vkCmdUpdateBuffer)(C.PFN_vkCmdUpdateBuffer_c541b249), nil
}

// PassValue returns a value.
func (x PFNCmdUpdateBuffer) PassValue() (ref C.PFN_vkCmdUpdateBuffer, allocs *cgoAllocMap) {
	if pFNCmdUpdateBufferC541B249Func == nil {
		pFNCmdUpdateBufferC541B249Func = x
	}
	return (C.PFN_vkCmdUpdateBuffer)(C.PFN_vkCmdUpdateBuffer_c541b249), nil
}

//export pFNCmdUpdateBufferC541B249
func pFNCmdUpdateBufferC541B249(cCommandBuffer C.VkCommandBuffer, cDstBuffer C.VkBuffer, cDstOffset C.VkDeviceSize, cDataSize C.VkDeviceSize, cPData *C.uint32_t) {
	if pFNCmdUpdateBufferC541B249Func != nil {
		CommandBufferc541b249 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		DstBufferc541b249 := *(*Buffer)(unsafe.Pointer(&cDstBuffer))
		DstOffsetc541b249 := (DeviceSize)(cDstOffset)
		DataSizec541b249 := (DeviceSize)(cDataSize)
		var PDatac541b249 []uint32
		hxfd3aa9c := (*sliceHeader)(unsafe.Pointer(&PDatac541b249))
		hxfd3aa9c.Data = uintptr(unsafe.Pointer(cPData))
		hxfd3aa9c.Cap = 0x7fffffff
		// hxfd3aa9c.Len = ?

		pFNCmdUpdateBufferC541B249Func(CommandBufferc541b249, DstBufferc541b249, DstOffsetc541b249, DataSizec541b249, PDatac541b249)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdUpdateBufferC541B249Func PFNCmdUpdateBuffer

// PassRef returns a reference.
func (x PFNCmdFillBuffer) PassRef() (ref *C.PFN_vkCmdFillBuffer, allocs *cgoAllocMap) {
	if pFNCmdFillBufferF494A82DFunc == nil {
		pFNCmdFillBufferF494A82DFunc = x
	}
	return (*C.PFN_vkCmdFillBuffer)(C.PFN_vkCmdFillBuffer_f494a82d), nil
}

// PassValue returns a value.
func (x PFNCmdFillBuffer) PassValue() (ref C.PFN_vkCmdFillBuffer, allocs *cgoAllocMap) {
	if pFNCmdFillBufferF494A82DFunc == nil {
		pFNCmdFillBufferF494A82DFunc = x
	}
	return (C.PFN_vkCmdFillBuffer)(C.PFN_vkCmdFillBuffer_f494a82d), nil
}

//export pFNCmdFillBufferF494A82D
func pFNCmdFillBufferF494A82D(cCommandBuffer C.VkCommandBuffer, cDstBuffer C.VkBuffer, cDstOffset C.VkDeviceSize, cSize C.VkDeviceSize, cData C.uint32_t) {
	if pFNCmdFillBufferF494A82DFunc != nil {
		CommandBufferf494a82d := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		DstBufferf494a82d := *(*Buffer)(unsafe.Pointer(&cDstBuffer))
		DstOffsetf494a82d := (DeviceSize)(cDstOffset)
		Sizef494a82d := (DeviceSize)(cSize)
		Dataf494a82d := (uint32)(cData)
		pFNCmdFillBufferF494A82DFunc(CommandBufferf494a82d, DstBufferf494a82d, DstOffsetf494a82d, Sizef494a82d, Dataf494a82d)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdFillBufferF494A82DFunc PFNCmdFillBuffer

// packSImageSubresourceRange reads sliced Go data structure out from plain C format.
func packSImageSubresourceRange(v []ImageSubresourceRange, ptr0 *C.VkImageSubresourceRange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageSubresourceRangeValue]C.VkImageSubresourceRange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageSubresourceRangeRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCmdClearColorImage) PassRef() (ref *C.PFN_vkCmdClearColorImage, allocs *cgoAllocMap) {
	if pFNCmdClearColorImage453252CFFunc == nil {
		pFNCmdClearColorImage453252CFFunc = x
	}
	return (*C.PFN_vkCmdClearColorImage)(C.PFN_vkCmdClearColorImage_453252cf), nil
}

// PassValue returns a value.
func (x PFNCmdClearColorImage) PassValue() (ref C.PFN_vkCmdClearColorImage, allocs *cgoAllocMap) {
	if pFNCmdClearColorImage453252CFFunc == nil {
		pFNCmdClearColorImage453252CFFunc = x
	}
	return (C.PFN_vkCmdClearColorImage)(C.PFN_vkCmdClearColorImage_453252cf), nil
}

//export pFNCmdClearColorImage453252CF
func pFNCmdClearColorImage453252CF(cCommandBuffer C.VkCommandBuffer, cImage C.VkImage, cImageLayout C.VkImageLayout, cPColor *C.VkClearColorValue, cRangeCount C.uint32_t, cPRanges *C.VkImageSubresourceRange) {
	if pFNCmdClearColorImage453252CFFunc != nil {
		CommandBuffer453252cf := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		Image453252cf := *(*Image)(unsafe.Pointer(&cImage))
		ImageLayout453252cf := (ImageLayout)(cImageLayout)
		var PColor453252cf []ClearColorValue
		hxfb2f596 := (*sliceHeader)(unsafe.Pointer(&PColor453252cf))
		hxfb2f596.Data = uintptr(unsafe.Pointer(cPColor))
		hxfb2f596.Cap = 0x7fffffff
		// hxfb2f596.Len = ?

		RangeCount453252cf := (uint32)(cRangeCount)
		var PRanges453252cf []ImageSubresourceRange
		packSImageSubresourceRange(PRanges453252cf, cPRanges)
		pFNCmdClearColorImage453252CFFunc(CommandBuffer453252cf, Image453252cf, ImageLayout453252cf, PColor453252cf, RangeCount453252cf, PRanges453252cf)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdClearColorImage453252CFFunc PFNCmdClearColorImage

// packSClearDepthStencilValue reads sliced Go data structure out from plain C format.
func packSClearDepthStencilValue(v []ClearDepthStencilValue, ptr0 *C.VkClearDepthStencilValue) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfClearDepthStencilValueValue]C.VkClearDepthStencilValue)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewClearDepthStencilValueRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCmdClearDepthStencilImage) PassRef() (ref *C.PFN_vkCmdClearDepthStencilImage, allocs *cgoAllocMap) {
	if pFNCmdClearDepthStencilImage1045179CFunc == nil {
		pFNCmdClearDepthStencilImage1045179CFunc = x
	}
	return (*C.PFN_vkCmdClearDepthStencilImage)(C.PFN_vkCmdClearDepthStencilImage_1045179c), nil
}

// PassValue returns a value.
func (x PFNCmdClearDepthStencilImage) PassValue() (ref C.PFN_vkCmdClearDepthStencilImage, allocs *cgoAllocMap) {
	if pFNCmdClearDepthStencilImage1045179CFunc == nil {
		pFNCmdClearDepthStencilImage1045179CFunc = x
	}
	return (C.PFN_vkCmdClearDepthStencilImage)(C.PFN_vkCmdClearDepthStencilImage_1045179c), nil
}

//export pFNCmdClearDepthStencilImage1045179C
func pFNCmdClearDepthStencilImage1045179C(cCommandBuffer C.VkCommandBuffer, cImage C.VkImage, cImageLayout C.VkImageLayout, cPDepthStencil *C.VkClearDepthStencilValue, cRangeCount C.uint32_t, cPRanges *C.VkImageSubresourceRange) {
	if pFNCmdClearDepthStencilImage1045179CFunc != nil {
		CommandBuffer1045179c := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		Image1045179c := *(*Image)(unsafe.Pointer(&cImage))
		ImageLayout1045179c := (ImageLayout)(cImageLayout)
		var PDepthStencil1045179c []ClearDepthStencilValue
		packSClearDepthStencilValue(PDepthStencil1045179c, cPDepthStencil)
		RangeCount1045179c := (uint32)(cRangeCount)
		var PRanges1045179c []ImageSubresourceRange
		packSImageSubresourceRange(PRanges1045179c, cPRanges)
		pFNCmdClearDepthStencilImage1045179CFunc(CommandBuffer1045179c, Image1045179c, ImageLayout1045179c, PDepthStencil1045179c, RangeCount1045179c, PRanges1045179c)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdClearDepthStencilImage1045179CFunc PFNCmdClearDepthStencilImage

// packSClearAttachment reads sliced Go data structure out from plain C format.
func packSClearAttachment(v []ClearAttachment, ptr0 *C.VkClearAttachment) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfClearAttachmentValue]C.VkClearAttachment)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewClearAttachmentRef(&ptr1)
	}
}

// packSClearRect reads sliced Go data structure out from plain C format.
func packSClearRect(v []ClearRect, ptr0 *C.VkClearRect) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfClearRectValue]C.VkClearRect)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewClearRectRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCmdClearAttachments) PassRef() (ref *C.PFN_vkCmdClearAttachments, allocs *cgoAllocMap) {
	if pFNCmdClearAttachments4B13DDDCFunc == nil {
		pFNCmdClearAttachments4B13DDDCFunc = x
	}
	return (*C.PFN_vkCmdClearAttachments)(C.PFN_vkCmdClearAttachments_4b13dddc), nil
}

// PassValue returns a value.
func (x PFNCmdClearAttachments) PassValue() (ref C.PFN_vkCmdClearAttachments, allocs *cgoAllocMap) {
	if pFNCmdClearAttachments4B13DDDCFunc == nil {
		pFNCmdClearAttachments4B13DDDCFunc = x
	}
	return (C.PFN_vkCmdClearAttachments)(C.PFN_vkCmdClearAttachments_4b13dddc), nil
}

//export pFNCmdClearAttachments4B13DDDC
func pFNCmdClearAttachments4B13DDDC(cCommandBuffer C.VkCommandBuffer, cAttachmentCount C.uint32_t, cPAttachments *C.VkClearAttachment, cRectCount C.uint32_t, cPRects *C.VkClearRect) {
	if pFNCmdClearAttachments4B13DDDCFunc != nil {
		CommandBuffer4b13dddc := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		AttachmentCount4b13dddc := (uint32)(cAttachmentCount)
		var PAttachments4b13dddc []ClearAttachment
		packSClearAttachment(PAttachments4b13dddc, cPAttachments)
		RectCount4b13dddc := (uint32)(cRectCount)
		var PRects4b13dddc []ClearRect
		packSClearRect(PRects4b13dddc, cPRects)
		pFNCmdClearAttachments4B13DDDCFunc(CommandBuffer4b13dddc, AttachmentCount4b13dddc, PAttachments4b13dddc, RectCount4b13dddc, PRects4b13dddc)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdClearAttachments4B13DDDCFunc PFNCmdClearAttachments

// packSImageResolve reads sliced Go data structure out from plain C format.
func packSImageResolve(v []ImageResolve, ptr0 *C.VkImageResolve) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageResolveValue]C.VkImageResolve)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageResolveRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCmdResolveImage) PassRef() (ref *C.PFN_vkCmdResolveImage, allocs *cgoAllocMap) {
	if pFNCmdResolveImage8773C849Func == nil {
		pFNCmdResolveImage8773C849Func = x
	}
	return (*C.PFN_vkCmdResolveImage)(C.PFN_vkCmdResolveImage_8773c849), nil
}

// PassValue returns a value.
func (x PFNCmdResolveImage) PassValue() (ref C.PFN_vkCmdResolveImage, allocs *cgoAllocMap) {
	if pFNCmdResolveImage8773C849Func == nil {
		pFNCmdResolveImage8773C849Func = x
	}
	return (C.PFN_vkCmdResolveImage)(C.PFN_vkCmdResolveImage_8773c849), nil
}

//export pFNCmdResolveImage8773C849
func pFNCmdResolveImage8773C849(cCommandBuffer C.VkCommandBuffer, cSrcImage C.VkImage, cSrcImageLayout C.VkImageLayout, cDstImage C.VkImage, cDstImageLayout C.VkImageLayout, cRegionCount C.uint32_t, cPRegions *C.VkImageResolve) {
	if pFNCmdResolveImage8773C849Func != nil {
		CommandBuffer8773c849 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		SrcImage8773c849 := *(*Image)(unsafe.Pointer(&cSrcImage))
		SrcImageLayout8773c849 := (ImageLayout)(cSrcImageLayout)
		DstImage8773c849 := *(*Image)(unsafe.Pointer(&cDstImage))
		DstImageLayout8773c849 := (ImageLayout)(cDstImageLayout)
		RegionCount8773c849 := (uint32)(cRegionCount)
		var PRegions8773c849 []ImageResolve
		packSImageResolve(PRegions8773c849, cPRegions)
		pFNCmdResolveImage8773C849Func(CommandBuffer8773c849, SrcImage8773c849, SrcImageLayout8773c849, DstImage8773c849, DstImageLayout8773c849, RegionCount8773c849, PRegions8773c849)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdResolveImage8773C849Func PFNCmdResolveImage

// PassRef returns a reference.
func (x PFNCmdSetEvent) PassRef() (ref *C.PFN_vkCmdSetEvent, allocs *cgoAllocMap) {
	if pFNCmdSetEvent2F34CF9EFunc == nil {
		pFNCmdSetEvent2F34CF9EFunc = x
	}
	return (*C.PFN_vkCmdSetEvent)(C.PFN_vkCmdSetEvent_2f34cf9e), nil
}

// PassValue returns a value.
func (x PFNCmdSetEvent) PassValue() (ref C.PFN_vkCmdSetEvent, allocs *cgoAllocMap) {
	if pFNCmdSetEvent2F34CF9EFunc == nil {
		pFNCmdSetEvent2F34CF9EFunc = x
	}
	return (C.PFN_vkCmdSetEvent)(C.PFN_vkCmdSetEvent_2f34cf9e), nil
}

//export pFNCmdSetEvent2F34CF9E
func pFNCmdSetEvent2F34CF9E(cCommandBuffer C.VkCommandBuffer, cEvent C.VkEvent, cStageMask C.VkPipelineStageFlags) {
	if pFNCmdSetEvent2F34CF9EFunc != nil {
		CommandBuffer2f34cf9e := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		Event2f34cf9e := *(*Event)(unsafe.Pointer(&cEvent))
		StageMask2f34cf9e := (PipelineStageFlags)(cStageMask)
		pFNCmdSetEvent2F34CF9EFunc(CommandBuffer2f34cf9e, Event2f34cf9e, StageMask2f34cf9e)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdSetEvent2F34CF9EFunc PFNCmdSetEvent

// PassRef returns a reference.
func (x PFNCmdResetEvent) PassRef() (ref *C.PFN_vkCmdResetEvent, allocs *cgoAllocMap) {
	if pFNCmdResetEvent272CD5F1Func == nil {
		pFNCmdResetEvent272CD5F1Func = x
	}
	return (*C.PFN_vkCmdResetEvent)(C.PFN_vkCmdResetEvent_272cd5f1), nil
}

// PassValue returns a value.
func (x PFNCmdResetEvent) PassValue() (ref C.PFN_vkCmdResetEvent, allocs *cgoAllocMap) {
	if pFNCmdResetEvent272CD5F1Func == nil {
		pFNCmdResetEvent272CD5F1Func = x
	}
	return (C.PFN_vkCmdResetEvent)(C.PFN_vkCmdResetEvent_272cd5f1), nil
}

//export pFNCmdResetEvent272CD5F1
func pFNCmdResetEvent272CD5F1(cCommandBuffer C.VkCommandBuffer, cEvent C.VkEvent, cStageMask C.VkPipelineStageFlags) {
	if pFNCmdResetEvent272CD5F1Func != nil {
		CommandBuffer272cd5f1 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		Event272cd5f1 := *(*Event)(unsafe.Pointer(&cEvent))
		StageMask272cd5f1 := (PipelineStageFlags)(cStageMask)
		pFNCmdResetEvent272CD5F1Func(CommandBuffer272cd5f1, Event272cd5f1, StageMask272cd5f1)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdResetEvent272CD5F1Func PFNCmdResetEvent

// packSMemoryBarrier reads sliced Go data structure out from plain C format.
func packSMemoryBarrier(v []MemoryBarrier, ptr0 *C.VkMemoryBarrier) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMemoryBarrierValue]C.VkMemoryBarrier)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMemoryBarrierRef(&ptr1)
	}
}

// packSBufferMemoryBarrier reads sliced Go data structure out from plain C format.
func packSBufferMemoryBarrier(v []BufferMemoryBarrier, ptr0 *C.VkBufferMemoryBarrier) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferMemoryBarrierValue]C.VkBufferMemoryBarrier)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferMemoryBarrierRef(&ptr1)
	}
}

// packSImageMemoryBarrier reads sliced Go data structure out from plain C format.
func packSImageMemoryBarrier(v []ImageMemoryBarrier, ptr0 *C.VkImageMemoryBarrier) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageMemoryBarrierValue]C.VkImageMemoryBarrier)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageMemoryBarrierRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCmdWaitEvents) PassRef() (ref *C.PFN_vkCmdWaitEvents, allocs *cgoAllocMap) {
	if pFNCmdWaitEventsF92C9B96Func == nil {
		pFNCmdWaitEventsF92C9B96Func = x
	}
	return (*C.PFN_vkCmdWaitEvents)(C.PFN_vkCmdWaitEvents_f92c9b96), nil
}

// PassValue returns a value.
func (x PFNCmdWaitEvents) PassValue() (ref C.PFN_vkCmdWaitEvents, allocs *cgoAllocMap) {
	if pFNCmdWaitEventsF92C9B96Func == nil {
		pFNCmdWaitEventsF92C9B96Func = x
	}
	return (C.PFN_vkCmdWaitEvents)(C.PFN_vkCmdWaitEvents_f92c9b96), nil
}

//export pFNCmdWaitEventsF92C9B96
func pFNCmdWaitEventsF92C9B96(cCommandBuffer C.VkCommandBuffer, cEventCount C.uint32_t, cPEvents *C.VkEvent, cSrcStageMask C.VkPipelineStageFlags, cDstStageMask C.VkPipelineStageFlags, cMemoryBarrierCount C.uint32_t, cPMemoryBarriers *C.VkMemoryBarrier, cBufferMemoryBarrierCount C.uint32_t, cPBufferMemoryBarriers *C.VkBufferMemoryBarrier, cImageMemoryBarrierCount C.uint32_t, cPImageMemoryBarriers *C.VkImageMemoryBarrier) {
	if pFNCmdWaitEventsF92C9B96Func != nil {
		CommandBufferf92c9b96 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		EventCountf92c9b96 := (uint32)(cEventCount)
		var PEventsf92c9b96 []Event
		hxf11683e := (*sliceHeader)(unsafe.Pointer(&PEventsf92c9b96))
		hxf11683e.Data = uintptr(unsafe.Pointer(cPEvents))
		hxf11683e.Cap = 0x7fffffff
		// hxf11683e.Len = ?

		SrcStageMaskf92c9b96 := (PipelineStageFlags)(cSrcStageMask)
		DstStageMaskf92c9b96 := (PipelineStageFlags)(cDstStageMask)
		MemoryBarrierCountf92c9b96 := (uint32)(cMemoryBarrierCount)
		var PMemoryBarriersf92c9b96 []MemoryBarrier
		packSMemoryBarrier(PMemoryBarriersf92c9b96, cPMemoryBarriers)
		BufferMemoryBarrierCountf92c9b96 := (uint32)(cBufferMemoryBarrierCount)
		var PBufferMemoryBarriersf92c9b96 []BufferMemoryBarrier
		packSBufferMemoryBarrier(PBufferMemoryBarriersf92c9b96, cPBufferMemoryBarriers)
		ImageMemoryBarrierCountf92c9b96 := (uint32)(cImageMemoryBarrierCount)
		var PImageMemoryBarriersf92c9b96 []ImageMemoryBarrier
		packSImageMemoryBarrier(PImageMemoryBarriersf92c9b96, cPImageMemoryBarriers)
		pFNCmdWaitEventsF92C9B96Func(CommandBufferf92c9b96, EventCountf92c9b96, PEventsf92c9b96, SrcStageMaskf92c9b96, DstStageMaskf92c9b96, MemoryBarrierCountf92c9b96, PMemoryBarriersf92c9b96, BufferMemoryBarrierCountf92c9b96, PBufferMemoryBarriersf92c9b96, ImageMemoryBarrierCountf92c9b96, PImageMemoryBarriersf92c9b96)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdWaitEventsF92C9B96Func PFNCmdWaitEvents

// PassRef returns a reference.
func (x PFNCmdPipelineBarrier) PassRef() (ref *C.PFN_vkCmdPipelineBarrier, allocs *cgoAllocMap) {
	if pFNCmdPipelineBarrierD83EC454Func == nil {
		pFNCmdPipelineBarrierD83EC454Func = x
	}
	return (*C.PFN_vkCmdPipelineBarrier)(C.PFN_vkCmdPipelineBarrier_d83ec454), nil
}

// PassValue returns a value.
func (x PFNCmdPipelineBarrier) PassValue() (ref C.PFN_vkCmdPipelineBarrier, allocs *cgoAllocMap) {
	if pFNCmdPipelineBarrierD83EC454Func == nil {
		pFNCmdPipelineBarrierD83EC454Func = x
	}
	return (C.PFN_vkCmdPipelineBarrier)(C.PFN_vkCmdPipelineBarrier_d83ec454), nil
}

//export pFNCmdPipelineBarrierD83EC454
func pFNCmdPipelineBarrierD83EC454(cCommandBuffer C.VkCommandBuffer, cSrcStageMask C.VkPipelineStageFlags, cDstStageMask C.VkPipelineStageFlags, cDependencyFlags C.VkDependencyFlags, cMemoryBarrierCount C.uint32_t, cPMemoryBarriers *C.VkMemoryBarrier, cBufferMemoryBarrierCount C.uint32_t, cPBufferMemoryBarriers *C.VkBufferMemoryBarrier, cImageMemoryBarrierCount C.uint32_t, cPImageMemoryBarriers *C.VkImageMemoryBarrier) {
	if pFNCmdPipelineBarrierD83EC454Func != nil {
		CommandBufferd83ec454 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		SrcStageMaskd83ec454 := (PipelineStageFlags)(cSrcStageMask)
		DstStageMaskd83ec454 := (PipelineStageFlags)(cDstStageMask)
		DependencyFlagsd83ec454 := (DependencyFlags)(cDependencyFlags)
		MemoryBarrierCountd83ec454 := (uint32)(cMemoryBarrierCount)
		var PMemoryBarriersd83ec454 []MemoryBarrier
		packSMemoryBarrier(PMemoryBarriersd83ec454, cPMemoryBarriers)
		BufferMemoryBarrierCountd83ec454 := (uint32)(cBufferMemoryBarrierCount)
		var PBufferMemoryBarriersd83ec454 []BufferMemoryBarrier
		packSBufferMemoryBarrier(PBufferMemoryBarriersd83ec454, cPBufferMemoryBarriers)
		ImageMemoryBarrierCountd83ec454 := (uint32)(cImageMemoryBarrierCount)
		var PImageMemoryBarriersd83ec454 []ImageMemoryBarrier
		packSImageMemoryBarrier(PImageMemoryBarriersd83ec454, cPImageMemoryBarriers)
		pFNCmdPipelineBarrierD83EC454Func(CommandBufferd83ec454, SrcStageMaskd83ec454, DstStageMaskd83ec454, DependencyFlagsd83ec454, MemoryBarrierCountd83ec454, PMemoryBarriersd83ec454, BufferMemoryBarrierCountd83ec454, PBufferMemoryBarriersd83ec454, ImageMemoryBarrierCountd83ec454, PImageMemoryBarriersd83ec454)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdPipelineBarrierD83EC454Func PFNCmdPipelineBarrier

// PassRef returns a reference.
func (x PFNCmdBeginQuery) PassRef() (ref *C.PFN_vkCmdBeginQuery, allocs *cgoAllocMap) {
	if pFNCmdBeginQuery828D9F0DFunc == nil {
		pFNCmdBeginQuery828D9F0DFunc = x
	}
	return (*C.PFN_vkCmdBeginQuery)(C.PFN_vkCmdBeginQuery_828d9f0d), nil
}

// PassValue returns a value.
func (x PFNCmdBeginQuery) PassValue() (ref C.PFN_vkCmdBeginQuery, allocs *cgoAllocMap) {
	if pFNCmdBeginQuery828D9F0DFunc == nil {
		pFNCmdBeginQuery828D9F0DFunc = x
	}
	return (C.PFN_vkCmdBeginQuery)(C.PFN_vkCmdBeginQuery_828d9f0d), nil
}

//export pFNCmdBeginQuery828D9F0D
func pFNCmdBeginQuery828D9F0D(cCommandBuffer C.VkCommandBuffer, cQueryPool C.VkQueryPool, cQuery C.uint32_t, cFlags C.VkQueryControlFlags) {
	if pFNCmdBeginQuery828D9F0DFunc != nil {
		CommandBuffer828d9f0d := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		QueryPool828d9f0d := *(*QueryPool)(unsafe.Pointer(&cQueryPool))
		Query828d9f0d := (uint32)(cQuery)
		Flags828d9f0d := (QueryControlFlags)(cFlags)
		pFNCmdBeginQuery828D9F0DFunc(CommandBuffer828d9f0d, QueryPool828d9f0d, Query828d9f0d, Flags828d9f0d)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdBeginQuery828D9F0DFunc PFNCmdBeginQuery

// PassRef returns a reference.
func (x PFNCmdEndQuery) PassRef() (ref *C.PFN_vkCmdEndQuery, allocs *cgoAllocMap) {
	if pFNCmdEndQuery8B221E1FFunc == nil {
		pFNCmdEndQuery8B221E1FFunc = x
	}
	return (*C.PFN_vkCmdEndQuery)(C.PFN_vkCmdEndQuery_8b221e1f), nil
}

// PassValue returns a value.
func (x PFNCmdEndQuery) PassValue() (ref C.PFN_vkCmdEndQuery, allocs *cgoAllocMap) {
	if pFNCmdEndQuery8B221E1FFunc == nil {
		pFNCmdEndQuery8B221E1FFunc = x
	}
	return (C.PFN_vkCmdEndQuery)(C.PFN_vkCmdEndQuery_8b221e1f), nil
}

//export pFNCmdEndQuery8B221E1F
func pFNCmdEndQuery8B221E1F(cCommandBuffer C.VkCommandBuffer, cQueryPool C.VkQueryPool, cQuery C.uint32_t) {
	if pFNCmdEndQuery8B221E1FFunc != nil {
		CommandBuffer8b221e1f := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		QueryPool8b221e1f := *(*QueryPool)(unsafe.Pointer(&cQueryPool))
		Query8b221e1f := (uint32)(cQuery)
		pFNCmdEndQuery8B221E1FFunc(CommandBuffer8b221e1f, QueryPool8b221e1f, Query8b221e1f)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdEndQuery8B221E1FFunc PFNCmdEndQuery

// PassRef returns a reference.
func (x PFNCmdResetQueryPool) PassRef() (ref *C.PFN_vkCmdResetQueryPool, allocs *cgoAllocMap) {
	if pFNCmdResetQueryPoolD5274CABFunc == nil {
		pFNCmdResetQueryPoolD5274CABFunc = x
	}
	return (*C.PFN_vkCmdResetQueryPool)(C.PFN_vkCmdResetQueryPool_d5274cab), nil
}

// PassValue returns a value.
func (x PFNCmdResetQueryPool) PassValue() (ref C.PFN_vkCmdResetQueryPool, allocs *cgoAllocMap) {
	if pFNCmdResetQueryPoolD5274CABFunc == nil {
		pFNCmdResetQueryPoolD5274CABFunc = x
	}
	return (C.PFN_vkCmdResetQueryPool)(C.PFN_vkCmdResetQueryPool_d5274cab), nil
}

//export pFNCmdResetQueryPoolD5274CAB
func pFNCmdResetQueryPoolD5274CAB(cCommandBuffer C.VkCommandBuffer, cQueryPool C.VkQueryPool, cFirstQuery C.uint32_t, cQueryCount C.uint32_t) {
	if pFNCmdResetQueryPoolD5274CABFunc != nil {
		CommandBufferd5274cab := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		QueryPoold5274cab := *(*QueryPool)(unsafe.Pointer(&cQueryPool))
		FirstQueryd5274cab := (uint32)(cFirstQuery)
		QueryCountd5274cab := (uint32)(cQueryCount)
		pFNCmdResetQueryPoolD5274CABFunc(CommandBufferd5274cab, QueryPoold5274cab, FirstQueryd5274cab, QueryCountd5274cab)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdResetQueryPoolD5274CABFunc PFNCmdResetQueryPool

// PassRef returns a reference.
func (x PFNCmdWriteTimestamp) PassRef() (ref *C.PFN_vkCmdWriteTimestamp, allocs *cgoAllocMap) {
	if pFNCmdWriteTimestampDC3D5864Func == nil {
		pFNCmdWriteTimestampDC3D5864Func = x
	}
	return (*C.PFN_vkCmdWriteTimestamp)(C.PFN_vkCmdWriteTimestamp_dc3d5864), nil
}

// PassValue returns a value.
func (x PFNCmdWriteTimestamp) PassValue() (ref C.PFN_vkCmdWriteTimestamp, allocs *cgoAllocMap) {
	if pFNCmdWriteTimestampDC3D5864Func == nil {
		pFNCmdWriteTimestampDC3D5864Func = x
	}
	return (C.PFN_vkCmdWriteTimestamp)(C.PFN_vkCmdWriteTimestamp_dc3d5864), nil
}

//export pFNCmdWriteTimestampDC3D5864
func pFNCmdWriteTimestampDC3D5864(cCommandBuffer C.VkCommandBuffer, cPipelineStage C.VkPipelineStageFlagBits, cQueryPool C.VkQueryPool, cQuery C.uint32_t) {
	if pFNCmdWriteTimestampDC3D5864Func != nil {
		CommandBufferdc3d5864 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		PipelineStagedc3d5864 := (PipelineStageFlagBits)(cPipelineStage)
		QueryPooldc3d5864 := *(*QueryPool)(unsafe.Pointer(&cQueryPool))
		Querydc3d5864 := (uint32)(cQuery)
		pFNCmdWriteTimestampDC3D5864Func(CommandBufferdc3d5864, PipelineStagedc3d5864, QueryPooldc3d5864, Querydc3d5864)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdWriteTimestampDC3D5864Func PFNCmdWriteTimestamp

// PassRef returns a reference.
func (x PFNCmdCopyQueryPoolResults) PassRef() (ref *C.PFN_vkCmdCopyQueryPoolResults, allocs *cgoAllocMap) {
	if pFNCmdCopyQueryPoolResultsA38FBCD6Func == nil {
		pFNCmdCopyQueryPoolResultsA38FBCD6Func = x
	}
	return (*C.PFN_vkCmdCopyQueryPoolResults)(C.PFN_vkCmdCopyQueryPoolResults_a38fbcd6), nil
}

// PassValue returns a value.
func (x PFNCmdCopyQueryPoolResults) PassValue() (ref C.PFN_vkCmdCopyQueryPoolResults, allocs *cgoAllocMap) {
	if pFNCmdCopyQueryPoolResultsA38FBCD6Func == nil {
		pFNCmdCopyQueryPoolResultsA38FBCD6Func = x
	}
	return (C.PFN_vkCmdCopyQueryPoolResults)(C.PFN_vkCmdCopyQueryPoolResults_a38fbcd6), nil
}

//export pFNCmdCopyQueryPoolResultsA38FBCD6
func pFNCmdCopyQueryPoolResultsA38FBCD6(cCommandBuffer C.VkCommandBuffer, cQueryPool C.VkQueryPool, cFirstQuery C.uint32_t, cQueryCount C.uint32_t, cDstBuffer C.VkBuffer, cDstOffset C.VkDeviceSize, cStride C.VkDeviceSize, cFlags C.VkQueryResultFlags) {
	if pFNCmdCopyQueryPoolResultsA38FBCD6Func != nil {
		CommandBuffera38fbcd6 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		QueryPoola38fbcd6 := *(*QueryPool)(unsafe.Pointer(&cQueryPool))
		FirstQuerya38fbcd6 := (uint32)(cFirstQuery)
		QueryCounta38fbcd6 := (uint32)(cQueryCount)
		DstBuffera38fbcd6 := *(*Buffer)(unsafe.Pointer(&cDstBuffer))
		DstOffseta38fbcd6 := (DeviceSize)(cDstOffset)
		Stridea38fbcd6 := (DeviceSize)(cStride)
		Flagsa38fbcd6 := (QueryResultFlags)(cFlags)
		pFNCmdCopyQueryPoolResultsA38FBCD6Func(CommandBuffera38fbcd6, QueryPoola38fbcd6, FirstQuerya38fbcd6, QueryCounta38fbcd6, DstBuffera38fbcd6, DstOffseta38fbcd6, Stridea38fbcd6, Flagsa38fbcd6)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdCopyQueryPoolResultsA38FBCD6Func PFNCmdCopyQueryPoolResults

// PassRef returns a reference.
func (x PFNCmdPushConstants) PassRef() (ref *C.PFN_vkCmdPushConstants, allocs *cgoAllocMap) {
	if pFNCmdPushConstants32B3FC16Func == nil {
		pFNCmdPushConstants32B3FC16Func = x
	}
	return (*C.PFN_vkCmdPushConstants)(C.PFN_vkCmdPushConstants_32b3fc16), nil
}

// PassValue returns a value.
func (x PFNCmdPushConstants) PassValue() (ref C.PFN_vkCmdPushConstants, allocs *cgoAllocMap) {
	if pFNCmdPushConstants32B3FC16Func == nil {
		pFNCmdPushConstants32B3FC16Func = x
	}
	return (C.PFN_vkCmdPushConstants)(C.PFN_vkCmdPushConstants_32b3fc16), nil
}

//export pFNCmdPushConstants32B3FC16
func pFNCmdPushConstants32B3FC16(cCommandBuffer C.VkCommandBuffer, cLayout C.VkPipelineLayout, cStageFlags C.VkShaderStageFlags, cOffset C.uint32_t, cSize C.uint32_t, cPValues unsafe.Pointer) {
	if pFNCmdPushConstants32B3FC16Func != nil {
		CommandBuffer32b3fc16 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		Layout32b3fc16 := *(*PipelineLayout)(unsafe.Pointer(&cLayout))
		StageFlags32b3fc16 := (ShaderStageFlags)(cStageFlags)
		Offset32b3fc16 := (uint32)(cOffset)
		Size32b3fc16 := (uint32)(cSize)
		PValues32b3fc16 := (unsafe.Pointer)(unsafe.Pointer(cPValues))
		pFNCmdPushConstants32B3FC16Func(CommandBuffer32b3fc16, Layout32b3fc16, StageFlags32b3fc16, Offset32b3fc16, Size32b3fc16, PValues32b3fc16)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdPushConstants32B3FC16Func PFNCmdPushConstants

// packSRenderPassBeginInfo reads sliced Go data structure out from plain C format.
func packSRenderPassBeginInfo(v []RenderPassBeginInfo, ptr0 *C.VkRenderPassBeginInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRenderPassBeginInfoValue]C.VkRenderPassBeginInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRenderPassBeginInfoRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCmdBeginRenderPass) PassRef() (ref *C.PFN_vkCmdBeginRenderPass, allocs *cgoAllocMap) {
	if pFNCmdBeginRenderPass9D5A29DDFunc == nil {
		pFNCmdBeginRenderPass9D5A29DDFunc = x
	}
	return (*C.PFN_vkCmdBeginRenderPass)(C.PFN_vkCmdBeginRenderPass_9d5a29dd), nil
}

// PassValue returns a value.
func (x PFNCmdBeginRenderPass) PassValue() (ref C.PFN_vkCmdBeginRenderPass, allocs *cgoAllocMap) {
	if pFNCmdBeginRenderPass9D5A29DDFunc == nil {
		pFNCmdBeginRenderPass9D5A29DDFunc = x
	}
	return (C.PFN_vkCmdBeginRenderPass)(C.PFN_vkCmdBeginRenderPass_9d5a29dd), nil
}

//export pFNCmdBeginRenderPass9D5A29DD
func pFNCmdBeginRenderPass9D5A29DD(cCommandBuffer C.VkCommandBuffer, cPRenderPassBegin *C.VkRenderPassBeginInfo, cContents C.VkSubpassContents) {
	if pFNCmdBeginRenderPass9D5A29DDFunc != nil {
		CommandBuffer9d5a29dd := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		var PRenderPassBegin9d5a29dd []RenderPassBeginInfo
		packSRenderPassBeginInfo(PRenderPassBegin9d5a29dd, cPRenderPassBegin)
		Contents9d5a29dd := (SubpassContents)(cContents)
		pFNCmdBeginRenderPass9D5A29DDFunc(CommandBuffer9d5a29dd, PRenderPassBegin9d5a29dd, Contents9d5a29dd)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdBeginRenderPass9D5A29DDFunc PFNCmdBeginRenderPass

// PassRef returns a reference.
func (x PFNCmdNextSubpass) PassRef() (ref *C.PFN_vkCmdNextSubpass, allocs *cgoAllocMap) {
	if pFNCmdNextSubpassFFE19F9AFunc == nil {
		pFNCmdNextSubpassFFE19F9AFunc = x
	}
	return (*C.PFN_vkCmdNextSubpass)(C.PFN_vkCmdNextSubpass_ffe19f9a), nil
}

// PassValue returns a value.
func (x PFNCmdNextSubpass) PassValue() (ref C.PFN_vkCmdNextSubpass, allocs *cgoAllocMap) {
	if pFNCmdNextSubpassFFE19F9AFunc == nil {
		pFNCmdNextSubpassFFE19F9AFunc = x
	}
	return (C.PFN_vkCmdNextSubpass)(C.PFN_vkCmdNextSubpass_ffe19f9a), nil
}

//export pFNCmdNextSubpassFFE19F9A
func pFNCmdNextSubpassFFE19F9A(cCommandBuffer C.VkCommandBuffer, cContents C.VkSubpassContents) {
	if pFNCmdNextSubpassFFE19F9AFunc != nil {
		CommandBufferffe19f9a := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		Contentsffe19f9a := (SubpassContents)(cContents)
		pFNCmdNextSubpassFFE19F9AFunc(CommandBufferffe19f9a, Contentsffe19f9a)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdNextSubpassFFE19F9AFunc PFNCmdNextSubpass

// PassRef returns a reference.
func (x PFNCmdEndRenderPass) PassRef() (ref *C.PFN_vkCmdEndRenderPass, allocs *cgoAllocMap) {
	if pFNCmdEndRenderPassD1799D75Func == nil {
		pFNCmdEndRenderPassD1799D75Func = x
	}
	return (*C.PFN_vkCmdEndRenderPass)(C.PFN_vkCmdEndRenderPass_d1799d75), nil
}

// PassValue returns a value.
func (x PFNCmdEndRenderPass) PassValue() (ref C.PFN_vkCmdEndRenderPass, allocs *cgoAllocMap) {
	if pFNCmdEndRenderPassD1799D75Func == nil {
		pFNCmdEndRenderPassD1799D75Func = x
	}
	return (C.PFN_vkCmdEndRenderPass)(C.PFN_vkCmdEndRenderPass_d1799d75), nil
}

//export pFNCmdEndRenderPassD1799D75
func pFNCmdEndRenderPassD1799D75(cCommandBuffer C.VkCommandBuffer) {
	if pFNCmdEndRenderPassD1799D75Func != nil {
		CommandBufferd1799d75 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		pFNCmdEndRenderPassD1799D75Func(CommandBufferd1799d75)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdEndRenderPassD1799D75Func PFNCmdEndRenderPass

// PassRef returns a reference.
func (x PFNCmdExecuteCommands) PassRef() (ref *C.PFN_vkCmdExecuteCommands, allocs *cgoAllocMap) {
	if pFNCmdExecuteCommandsBA33FAEEFunc == nil {
		pFNCmdExecuteCommandsBA33FAEEFunc = x
	}
	return (*C.PFN_vkCmdExecuteCommands)(C.PFN_vkCmdExecuteCommands_ba33faee), nil
}

// PassValue returns a value.
func (x PFNCmdExecuteCommands) PassValue() (ref C.PFN_vkCmdExecuteCommands, allocs *cgoAllocMap) {
	if pFNCmdExecuteCommandsBA33FAEEFunc == nil {
		pFNCmdExecuteCommandsBA33FAEEFunc = x
	}
	return (C.PFN_vkCmdExecuteCommands)(C.PFN_vkCmdExecuteCommands_ba33faee), nil
}

//export pFNCmdExecuteCommandsBA33FAEE
func pFNCmdExecuteCommandsBA33FAEE(cCommandBuffer C.VkCommandBuffer, cCommandBufferCount C.uint32_t, cPCommandBuffers *C.VkCommandBuffer) {
	if pFNCmdExecuteCommandsBA33FAEEFunc != nil {
		CommandBufferba33faee := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		CommandBufferCountba33faee := (uint32)(cCommandBufferCount)
		var PCommandBuffersba33faee []CommandBuffer
		hxfd9261b := (*sliceHeader)(unsafe.Pointer(&PCommandBuffersba33faee))
		hxfd9261b.Data = uintptr(unsafe.Pointer(cPCommandBuffers))
		hxfd9261b.Cap = 0x7fffffff
		// hxfd9261b.Len = ?

		pFNCmdExecuteCommandsBA33FAEEFunc(CommandBufferba33faee, CommandBufferCountba33faee, PCommandBuffersba33faee)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdExecuteCommandsBA33FAEEFunc PFNCmdExecuteCommands

// allocSurfaceCapabilitiesKHRMemory allocates memory for type C.VkSurfaceCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceCapabilitiesKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceCapabilitiesKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSurfaceCapabilitiesKHRValue = unsafe.Sizeof([1]C.VkSurfaceCapabilitiesKHR{})

// Ref returns a reference.
func (x *SurfaceCapabilitiesKHR) Ref() *C.VkSurfaceCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.ref11d5f596
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SurfaceCapabilitiesKHR) Free() {
	if x != nil && x.allocs11d5f596 != nil {
		x.allocs11d5f596.(*cgoAllocMap).Free()
		x.ref11d5f596 = nil
	}
}

// NewSurfaceCapabilitiesKHRRef initialises a new struct holding the reference to the originaitng C struct.
func NewSurfaceCapabilitiesKHRRef(ref *C.VkSurfaceCapabilitiesKHR) *SurfaceCapabilitiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceCapabilitiesKHR)
	obj.ref11d5f596 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SurfaceCapabilitiesKHR) PassRef() (*C.VkSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11d5f596 != nil {
		return x.ref11d5f596, nil
	}
	mem11d5f596 := allocSurfaceCapabilitiesKHRMemory(1)
	ref11d5f596 := (*C.VkSurfaceCapabilitiesKHR)(mem11d5f596)
	allocs11d5f596 := new(cgoAllocMap)
	var cminImageCount_allocs *cgoAllocMap
	ref11d5f596.minImageCount, cminImageCount_allocs = (C.uint32_t)(x.MinImageCount), cgoAllocsUnknown
	allocs11d5f596.Borrow(cminImageCount_allocs)

	var cmaxImageCount_allocs *cgoAllocMap
	ref11d5f596.maxImageCount, cmaxImageCount_allocs = (C.uint32_t)(x.MaxImageCount), cgoAllocsUnknown
	allocs11d5f596.Borrow(cmaxImageCount_allocs)

	var ccurrentExtent_allocs *cgoAllocMap
	ref11d5f596.currentExtent, ccurrentExtent_allocs = x.CurrentExtent.PassValue()
	allocs11d5f596.Borrow(ccurrentExtent_allocs)

	var cminImageExtent_allocs *cgoAllocMap
	ref11d5f596.minImageExtent, cminImageExtent_allocs = x.MinImageExtent.PassValue()
	allocs11d5f596.Borrow(cminImageExtent_allocs)

	var cmaxImageExtent_allocs *cgoAllocMap
	ref11d5f596.maxImageExtent, cmaxImageExtent_allocs = x.MaxImageExtent.PassValue()
	allocs11d5f596.Borrow(cmaxImageExtent_allocs)

	var cmaxImageArrayLayers_allocs *cgoAllocMap
	ref11d5f596.maxImageArrayLayers, cmaxImageArrayLayers_allocs = (C.uint32_t)(x.MaxImageArrayLayers), cgoAllocsUnknown
	allocs11d5f596.Borrow(cmaxImageArrayLayers_allocs)

	var csupportedTransforms_allocs *cgoAllocMap
	ref11d5f596.supportedTransforms, csupportedTransforms_allocs = (C.VkSurfaceTransformFlagsKHR)(x.SupportedTransforms), cgoAllocsUnknown
	allocs11d5f596.Borrow(csupportedTransforms_allocs)

	var ccurrentTransform_allocs *cgoAllocMap
	ref11d5f596.currentTransform, ccurrentTransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.CurrentTransform), cgoAllocsUnknown
	allocs11d5f596.Borrow(ccurrentTransform_allocs)

	var csupportedCompositeAlpha_allocs *cgoAllocMap
	ref11d5f596.supportedCompositeAlpha, csupportedCompositeAlpha_allocs = (C.VkCompositeAlphaFlagsKHR)(x.SupportedCompositeAlpha), cgoAllocsUnknown
	allocs11d5f596.Borrow(csupportedCompositeAlpha_allocs)

	var csupportedUsageFlags_allocs *cgoAllocMap
	ref11d5f596.supportedUsageFlags, csupportedUsageFlags_allocs = (C.VkImageUsageFlags)(x.SupportedUsageFlags), cgoAllocsUnknown
	allocs11d5f596.Borrow(csupportedUsageFlags_allocs)

	x.ref11d5f596 = ref11d5f596
	x.allocs11d5f596 = allocs11d5f596
	return ref11d5f596, allocs11d5f596

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SurfaceCapabilitiesKHR) PassValue() (C.VkSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		x = NewSurfaceCapabilitiesKHRRef(nil)
	} else if x.ref11d5f596 != nil {
		return *x.ref11d5f596, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SurfaceCapabilitiesKHR) Deref() {
	if x.ref11d5f596 == nil {
		return
	}
	x.MinImageCount = (uint32)(x.ref11d5f596.minImageCount)
	x.MaxImageCount = (uint32)(x.ref11d5f596.maxImageCount)
	x.CurrentExtent = *NewExtent2DRef(&x.ref11d5f596.currentExtent)
	x.MinImageExtent = *NewExtent2DRef(&x.ref11d5f596.minImageExtent)
	x.MaxImageExtent = *NewExtent2DRef(&x.ref11d5f596.maxImageExtent)
	x.MaxImageArrayLayers = (uint32)(x.ref11d5f596.maxImageArrayLayers)
	x.SupportedTransforms = (SurfaceTransformFlagsKHR)(x.ref11d5f596.supportedTransforms)
	x.CurrentTransform = (SurfaceTransformFlagBitsKHR)(x.ref11d5f596.currentTransform)
	x.SupportedCompositeAlpha = (CompositeAlphaFlagsKHR)(x.ref11d5f596.supportedCompositeAlpha)
	x.SupportedUsageFlags = (ImageUsageFlags)(x.ref11d5f596.supportedUsageFlags)
}

// allocSurfaceFormatKHRMemory allocates memory for type C.VkSurfaceFormatKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceFormatKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceFormatKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSurfaceFormatKHRValue = unsafe.Sizeof([1]C.VkSurfaceFormatKHR{})

// Ref returns a reference.
func (x *SurfaceFormatKHR) Ref() *C.VkSurfaceFormatKHR {
	if x == nil {
		return nil
	}
	return x.refedaf82ca
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SurfaceFormatKHR) Free() {
	if x != nil && x.allocsedaf82ca != nil {
		x.allocsedaf82ca.(*cgoAllocMap).Free()
		x.refedaf82ca = nil
	}
}

// NewSurfaceFormatKHRRef initialises a new struct holding the reference to the originaitng C struct.
func NewSurfaceFormatKHRRef(ref *C.VkSurfaceFormatKHR) *SurfaceFormatKHR {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceFormatKHR)
	obj.refedaf82ca = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SurfaceFormatKHR) PassRef() (*C.VkSurfaceFormatKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refedaf82ca != nil {
		return x.refedaf82ca, nil
	}
	memedaf82ca := allocSurfaceFormatKHRMemory(1)
	refedaf82ca := (*C.VkSurfaceFormatKHR)(memedaf82ca)
	allocsedaf82ca := new(cgoAllocMap)
	var cformat_allocs *cgoAllocMap
	refedaf82ca.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsedaf82ca.Borrow(cformat_allocs)

	var ccolorSpace_allocs *cgoAllocMap
	refedaf82ca.colorSpace, ccolorSpace_allocs = (C.VkColorSpaceKHR)(x.ColorSpace), cgoAllocsUnknown
	allocsedaf82ca.Borrow(ccolorSpace_allocs)

	x.refedaf82ca = refedaf82ca
	x.allocsedaf82ca = allocsedaf82ca
	return refedaf82ca, allocsedaf82ca

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SurfaceFormatKHR) PassValue() (C.VkSurfaceFormatKHR, *cgoAllocMap) {
	if x == nil {
		x = NewSurfaceFormatKHRRef(nil)
	} else if x.refedaf82ca != nil {
		return *x.refedaf82ca, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SurfaceFormatKHR) Deref() {
	if x.refedaf82ca == nil {
		return
	}
	x.Format = (Format)(x.refedaf82ca.format)
	x.ColorSpace = (ColorSpaceKHR)(x.refedaf82ca.colorSpace)
}

// PassRef returns a reference.
func (x PFNDestroySurfaceKHR) PassRef() (ref *C.PFN_vkDestroySurfaceKHR, allocs *cgoAllocMap) {
	if pFNDestroySurfaceKHRD5F3492Func == nil {
		pFNDestroySurfaceKHRD5F3492Func = x
	}
	return (*C.PFN_vkDestroySurfaceKHR)(C.PFN_vkDestroySurfaceKHR_d5f3492), nil
}

// PassValue returns a value.
func (x PFNDestroySurfaceKHR) PassValue() (ref C.PFN_vkDestroySurfaceKHR, allocs *cgoAllocMap) {
	if pFNDestroySurfaceKHRD5F3492Func == nil {
		pFNDestroySurfaceKHRD5F3492Func = x
	}
	return (C.PFN_vkDestroySurfaceKHR)(C.PFN_vkDestroySurfaceKHR_d5f3492), nil
}

//export pFNDestroySurfaceKHRD5F3492
func pFNDestroySurfaceKHRD5F3492(cInstance C.VkInstance, cSurface C.VkSurfaceKHR, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroySurfaceKHRD5F3492Func != nil {
		Instanced5f3492 := *(*Instance)(unsafe.Pointer(&cInstance))
		Surfaced5f3492 := *(*SurfaceKHR)(unsafe.Pointer(&cSurface))
		var PAllocatord5f3492 []AllocationCallbacks
		packSAllocationCallbacks(PAllocatord5f3492, cPAllocator)
		pFNDestroySurfaceKHRD5F3492Func(Instanced5f3492, Surfaced5f3492, PAllocatord5f3492)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroySurfaceKHRD5F3492Func PFNDestroySurfaceKHR

// PassRef returns a reference.
func (x PFNGetPhysicalDeviceSurfaceSupportKHR) PassRef() (ref *C.PFN_vkGetPhysicalDeviceSurfaceSupportKHR, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceSurfaceSupportKHR1F637F55Func == nil {
		pFNGetPhysicalDeviceSurfaceSupportKHR1F637F55Func = x
	}
	return (*C.PFN_vkGetPhysicalDeviceSurfaceSupportKHR)(C.PFN_vkGetPhysicalDeviceSurfaceSupportKHR_1f637f55), nil
}

// PassValue returns a value.
func (x PFNGetPhysicalDeviceSurfaceSupportKHR) PassValue() (ref C.PFN_vkGetPhysicalDeviceSurfaceSupportKHR, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceSurfaceSupportKHR1F637F55Func == nil {
		pFNGetPhysicalDeviceSurfaceSupportKHR1F637F55Func = x
	}
	return (C.PFN_vkGetPhysicalDeviceSurfaceSupportKHR)(C.PFN_vkGetPhysicalDeviceSurfaceSupportKHR_1f637f55), nil
}

//export pFNGetPhysicalDeviceSurfaceSupportKHR1F637F55
func pFNGetPhysicalDeviceSurfaceSupportKHR1F637F55(cPhysicalDevice C.VkPhysicalDevice, cQueueFamilyIndex C.uint32_t, cSurface C.VkSurfaceKHR, cPSupported *C.VkBool32) C.VkResult {
	if pFNGetPhysicalDeviceSurfaceSupportKHR1F637F55Func != nil {
		PhysicalDevice1f637f55 := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		QueueFamilyIndex1f637f55 := (uint32)(cQueueFamilyIndex)
		Surface1f637f55 := *(*SurfaceKHR)(unsafe.Pointer(&cSurface))
		var PSupported1f637f55 []Bool32
		hxf77d2ac := (*sliceHeader)(unsafe.Pointer(&PSupported1f637f55))
		hxf77d2ac.Data = uintptr(unsafe.Pointer(cPSupported))
		hxf77d2ac.Cap = 0x7fffffff
		// hxf77d2ac.Len = ?

		ret1f637f55 := pFNGetPhysicalDeviceSurfaceSupportKHR1F637F55Func(PhysicalDevice1f637f55, QueueFamilyIndex1f637f55, Surface1f637f55, PSupported1f637f55)
		ret, _ := (C.VkResult)(ret1f637f55), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNGetPhysicalDeviceSurfaceSupportKHR1F637F55Func PFNGetPhysicalDeviceSurfaceSupportKHR

// packSSurfaceCapabilitiesKHR reads sliced Go data structure out from plain C format.
func packSSurfaceCapabilitiesKHR(v []SurfaceCapabilitiesKHR, ptr0 *C.VkSurfaceCapabilitiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSurfaceCapabilitiesKHRValue]C.VkSurfaceCapabilitiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSurfaceCapabilitiesKHRRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetPhysicalDeviceSurfaceCapabilitiesKHR) PassRef() (ref *C.PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceSurfaceCapabilitiesKHR7E3A1B89Func == nil {
		pFNGetPhysicalDeviceSurfaceCapabilitiesKHR7E3A1B89Func = x
	}
	return (*C.PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(C.PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR_7e3a1b89), nil
}

// PassValue returns a value.
func (x PFNGetPhysicalDeviceSurfaceCapabilitiesKHR) PassValue() (ref C.PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceSurfaceCapabilitiesKHR7E3A1B89Func == nil {
		pFNGetPhysicalDeviceSurfaceCapabilitiesKHR7E3A1B89Func = x
	}
	return (C.PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(C.PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR_7e3a1b89), nil
}

//export pFNGetPhysicalDeviceSurfaceCapabilitiesKHR7E3A1B89
func pFNGetPhysicalDeviceSurfaceCapabilitiesKHR7E3A1B89(cPhysicalDevice C.VkPhysicalDevice, cSurface C.VkSurfaceKHR, cPSurfaceCapabilities *C.VkSurfaceCapabilitiesKHR) C.VkResult {
	if pFNGetPhysicalDeviceSurfaceCapabilitiesKHR7E3A1B89Func != nil {
		PhysicalDevice7e3a1b89 := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		Surface7e3a1b89 := *(*SurfaceKHR)(unsafe.Pointer(&cSurface))
		var PSurfaceCapabilities7e3a1b89 []SurfaceCapabilitiesKHR
		packSSurfaceCapabilitiesKHR(PSurfaceCapabilities7e3a1b89, cPSurfaceCapabilities)
		ret7e3a1b89 := pFNGetPhysicalDeviceSurfaceCapabilitiesKHR7E3A1B89Func(PhysicalDevice7e3a1b89, Surface7e3a1b89, PSurfaceCapabilities7e3a1b89)
		ret, _ := (C.VkResult)(ret7e3a1b89), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNGetPhysicalDeviceSurfaceCapabilitiesKHR7E3A1B89Func PFNGetPhysicalDeviceSurfaceCapabilitiesKHR

// packSSurfaceFormatKHR reads sliced Go data structure out from plain C format.
func packSSurfaceFormatKHR(v []SurfaceFormatKHR, ptr0 *C.VkSurfaceFormatKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSurfaceFormatKHRValue]C.VkSurfaceFormatKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSurfaceFormatKHRRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetPhysicalDeviceSurfaceFormatsKHR) PassRef() (ref *C.PFN_vkGetPhysicalDeviceSurfaceFormatsKHR, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceSurfaceFormatsKHR8BBBAB0CFunc == nil {
		pFNGetPhysicalDeviceSurfaceFormatsKHR8BBBAB0CFunc = x
	}
	return (*C.PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)(C.PFN_vkGetPhysicalDeviceSurfaceFormatsKHR_8bbbab0c), nil
}

// PassValue returns a value.
func (x PFNGetPhysicalDeviceSurfaceFormatsKHR) PassValue() (ref C.PFN_vkGetPhysicalDeviceSurfaceFormatsKHR, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceSurfaceFormatsKHR8BBBAB0CFunc == nil {
		pFNGetPhysicalDeviceSurfaceFormatsKHR8BBBAB0CFunc = x
	}
	return (C.PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)(C.PFN_vkGetPhysicalDeviceSurfaceFormatsKHR_8bbbab0c), nil
}

//export pFNGetPhysicalDeviceSurfaceFormatsKHR8BBBAB0C
func pFNGetPhysicalDeviceSurfaceFormatsKHR8BBBAB0C(cPhysicalDevice C.VkPhysicalDevice, cSurface C.VkSurfaceKHR, cPSurfaceFormatCount *C.uint32_t, cPSurfaceFormats *C.VkSurfaceFormatKHR) C.VkResult {
	if pFNGetPhysicalDeviceSurfaceFormatsKHR8BBBAB0CFunc != nil {
		PhysicalDevice8bbbab0c := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		Surface8bbbab0c := *(*SurfaceKHR)(unsafe.Pointer(&cSurface))
		var PSurfaceFormatCount8bbbab0c []uint32
		hxff6a91e := (*sliceHeader)(unsafe.Pointer(&PSurfaceFormatCount8bbbab0c))
		hxff6a91e.Data = uintptr(unsafe.Pointer(cPSurfaceFormatCount))
		hxff6a91e.Cap = 0x7fffffff
		// hxff6a91e.Len = ?

		var PSurfaceFormats8bbbab0c []SurfaceFormatKHR
		packSSurfaceFormatKHR(PSurfaceFormats8bbbab0c, cPSurfaceFormats)
		ret8bbbab0c := pFNGetPhysicalDeviceSurfaceFormatsKHR8BBBAB0CFunc(PhysicalDevice8bbbab0c, Surface8bbbab0c, PSurfaceFormatCount8bbbab0c, PSurfaceFormats8bbbab0c)
		ret, _ := (C.VkResult)(ret8bbbab0c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNGetPhysicalDeviceSurfaceFormatsKHR8BBBAB0CFunc PFNGetPhysicalDeviceSurfaceFormatsKHR

// PassRef returns a reference.
func (x PFNGetPhysicalDeviceSurfacePresentModesKHR) PassRef() (ref *C.PFN_vkGetPhysicalDeviceSurfacePresentModesKHR, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceSurfacePresentModesKHR79C877Func == nil {
		pFNGetPhysicalDeviceSurfacePresentModesKHR79C877Func = x
	}
	return (*C.PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)(C.PFN_vkGetPhysicalDeviceSurfacePresentModesKHR_79c877), nil
}

// PassValue returns a value.
func (x PFNGetPhysicalDeviceSurfacePresentModesKHR) PassValue() (ref C.PFN_vkGetPhysicalDeviceSurfacePresentModesKHR, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceSurfacePresentModesKHR79C877Func == nil {
		pFNGetPhysicalDeviceSurfacePresentModesKHR79C877Func = x
	}
	return (C.PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)(C.PFN_vkGetPhysicalDeviceSurfacePresentModesKHR_79c877), nil
}

//export pFNGetPhysicalDeviceSurfacePresentModesKHR79C877
func pFNGetPhysicalDeviceSurfacePresentModesKHR79C877(cPhysicalDevice C.VkPhysicalDevice, cSurface C.VkSurfaceKHR, cPPresentModeCount *C.uint32_t, cPPresentModes *C.VkPresentModeKHR) C.VkResult {
	if pFNGetPhysicalDeviceSurfacePresentModesKHR79C877Func != nil {
		PhysicalDevice79c877 := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		Surface79c877 := *(*SurfaceKHR)(unsafe.Pointer(&cSurface))
		var PPresentModeCount79c877 []uint32
		hxf971c70 := (*sliceHeader)(unsafe.Pointer(&PPresentModeCount79c877))
		hxf971c70.Data = uintptr(unsafe.Pointer(cPPresentModeCount))
		hxf971c70.Cap = 0x7fffffff
		// hxf971c70.Len = ?

		var PPresentModes79c877 []PresentModeKHR
		hxf047235 := (*sliceHeader)(unsafe.Pointer(&PPresentModes79c877))
		hxf047235.Data = uintptr(unsafe.Pointer(cPPresentModes))
		hxf047235.Cap = 0x7fffffff
		// hxf047235.Len = ?

		ret79c877 := pFNGetPhysicalDeviceSurfacePresentModesKHR79C877Func(PhysicalDevice79c877, Surface79c877, PPresentModeCount79c877, PPresentModes79c877)
		ret, _ := (C.VkResult)(ret79c877), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNGetPhysicalDeviceSurfacePresentModesKHR79C877Func PFNGetPhysicalDeviceSurfacePresentModesKHR

// allocSwapchainCreateInfoKHRMemory allocates memory for type C.VkSwapchainCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSwapchainCreateInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSwapchainCreateInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSwapchainCreateInfoKHRValue = unsafe.Sizeof([1]C.VkSwapchainCreateInfoKHR{})

// Ref returns a reference.
func (x *SwapchainCreateInfoKHR) Ref() *C.VkSwapchainCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.refdb619e1c
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SwapchainCreateInfoKHR) Free() {
	if x != nil && x.allocsdb619e1c != nil {
		x.allocsdb619e1c.(*cgoAllocMap).Free()
		x.refdb619e1c = nil
	}
}

// NewSwapchainCreateInfoKHRRef initialises a new struct holding the reference to the originaitng C struct.
func NewSwapchainCreateInfoKHRRef(ref *C.VkSwapchainCreateInfoKHR) *SwapchainCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(SwapchainCreateInfoKHR)
	obj.refdb619e1c = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SwapchainCreateInfoKHR) PassRef() (*C.VkSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb619e1c != nil {
		return x.refdb619e1c, nil
	}
	memdb619e1c := allocSwapchainCreateInfoKHRMemory(1)
	refdb619e1c := (*C.VkSwapchainCreateInfoKHR)(memdb619e1c)
	allocsdb619e1c := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refdb619e1c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdb619e1c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdb619e1c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refdb619e1c.flags, cflags_allocs = (C.VkSwapchainCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cflags_allocs)

	var csurface_allocs *cgoAllocMap
	refdb619e1c.surface, csurface_allocs = *(*C.VkSurfaceKHR)(unsafe.Pointer(&x.Surface)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(csurface_allocs)

	var cminImageCount_allocs *cgoAllocMap
	refdb619e1c.minImageCount, cminImageCount_allocs = (C.uint32_t)(x.MinImageCount), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cminImageCount_allocs)

	var cimageFormat_allocs *cgoAllocMap
	refdb619e1c.imageFormat, cimageFormat_allocs = (C.VkFormat)(x.ImageFormat), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageFormat_allocs)

	var cimageColorSpace_allocs *cgoAllocMap
	refdb619e1c.imageColorSpace, cimageColorSpace_allocs = (C.VkColorSpaceKHR)(x.ImageColorSpace), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageColorSpace_allocs)

	var cimageExtent_allocs *cgoAllocMap
	refdb619e1c.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocsdb619e1c.Borrow(cimageExtent_allocs)

	var cimageArrayLayers_allocs *cgoAllocMap
	refdb619e1c.imageArrayLayers, cimageArrayLayers_allocs = (C.uint32_t)(x.ImageArrayLayers), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageArrayLayers_allocs)

	var cimageUsage_allocs *cgoAllocMap
	refdb619e1c.imageUsage, cimageUsage_allocs = (C.VkImageUsageFlags)(x.ImageUsage), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageUsage_allocs)

	var cimageSharingMode_allocs *cgoAllocMap
	refdb619e1c.imageSharingMode, cimageSharingMode_allocs = (C.VkSharingMode)(x.ImageSharingMode), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageSharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	refdb619e1c.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	refdb619e1c.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)).Data)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpQueueFamilyIndices_allocs)

	var cpreTransform_allocs *cgoAllocMap
	refdb619e1c.preTransform, cpreTransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.PreTransform), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpreTransform_allocs)

	var ccompositeAlpha_allocs *cgoAllocMap
	refdb619e1c.compositeAlpha, ccompositeAlpha_allocs = (C.VkCompositeAlphaFlagBitsKHR)(x.CompositeAlpha), cgoAllocsUnknown
	allocsdb619e1c.Borrow(ccompositeAlpha_allocs)

	var cpresentMode_allocs *cgoAllocMap
	refdb619e1c.presentMode, cpresentMode_allocs = (C.VkPresentModeKHR)(x.PresentMode), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpresentMode_allocs)

	var cclipped_allocs *cgoAllocMap
	refdb619e1c.clipped, cclipped_allocs = (C.VkBool32)(x.Clipped), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cclipped_allocs)

	var coldSwapchain_allocs *cgoAllocMap
	refdb619e1c.oldSwapchain, coldSwapchain_allocs = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.OldSwapchain)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(coldSwapchain_allocs)

	x.refdb619e1c = refdb619e1c
	x.allocsdb619e1c = allocsdb619e1c
	return refdb619e1c, allocsdb619e1c

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SwapchainCreateInfoKHR) PassValue() (C.VkSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		x = NewSwapchainCreateInfoKHRRef(nil)
	} else if x.refdb619e1c != nil {
		return *x.refdb619e1c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SwapchainCreateInfoKHR) Deref() {
	if x.refdb619e1c == nil {
		return
	}
	x.SType = (StructureType)(x.refdb619e1c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdb619e1c.pNext))
	x.Flags = (SwapchainCreateFlagsKHR)(x.refdb619e1c.flags)
	x.Surface = *(*SurfaceKHR)(unsafe.Pointer(&x.refdb619e1c.surface))
	x.MinImageCount = (uint32)(x.refdb619e1c.minImageCount)
	x.ImageFormat = (Format)(x.refdb619e1c.imageFormat)
	x.ImageColorSpace = (ColorSpaceKHR)(x.refdb619e1c.imageColorSpace)
	x.ImageExtent = *NewExtent2DRef(&x.refdb619e1c.imageExtent)
	x.ImageArrayLayers = (uint32)(x.refdb619e1c.imageArrayLayers)
	x.ImageUsage = (ImageUsageFlags)(x.refdb619e1c.imageUsage)
	x.ImageSharingMode = (SharingMode)(x.refdb619e1c.imageSharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.refdb619e1c.queueFamilyIndexCount)
	hxf612a5d := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf612a5d.Data = uintptr(unsafe.Pointer(x.refdb619e1c.pQueueFamilyIndices))
	hxf612a5d.Cap = 0x7fffffff
	// hxf612a5d.Len = ?

	x.PreTransform = (SurfaceTransformFlagBitsKHR)(x.refdb619e1c.preTransform)
	x.CompositeAlpha = (CompositeAlphaFlagBitsKHR)(x.refdb619e1c.compositeAlpha)
	x.PresentMode = (PresentModeKHR)(x.refdb619e1c.presentMode)
	x.Clipped = (Bool32)(x.refdb619e1c.clipped)
	x.OldSwapchain = *(*SwapchainKHR)(unsafe.Pointer(&x.refdb619e1c.oldSwapchain))
}

// allocPresentInfoKHRMemory allocates memory for type C.VkPresentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPresentInfoKHRValue = unsafe.Sizeof([1]C.VkPresentInfoKHR{})

// Ref returns a reference.
func (x *PresentInfoKHR) Ref() *C.VkPresentInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref1d0e82d4
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PresentInfoKHR) Free() {
	if x != nil && x.allocs1d0e82d4 != nil {
		x.allocs1d0e82d4.(*cgoAllocMap).Free()
		x.ref1d0e82d4 = nil
	}
}

// NewPresentInfoKHRRef initialises a new struct holding the reference to the originaitng C struct.
func NewPresentInfoKHRRef(ref *C.VkPresentInfoKHR) *PresentInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(PresentInfoKHR)
	obj.ref1d0e82d4 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PresentInfoKHR) PassRef() (*C.VkPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d0e82d4 != nil {
		return x.ref1d0e82d4, nil
	}
	mem1d0e82d4 := allocPresentInfoKHRMemory(1)
	ref1d0e82d4 := (*C.VkPresentInfoKHR)(mem1d0e82d4)
	allocs1d0e82d4 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref1d0e82d4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1d0e82d4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	ref1d0e82d4.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphores_allocs *cgoAllocMap
	ref1d0e82d4.pWaitSemaphores, cpWaitSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpWaitSemaphores_allocs)

	var cswapchainCount_allocs *cgoAllocMap
	ref1d0e82d4.swapchainCount, cswapchainCount_allocs = (C.uint32_t)(x.SwapchainCount), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cswapchainCount_allocs)

	var cpSwapchains_allocs *cgoAllocMap
	ref1d0e82d4.pSwapchains, cpSwapchains_allocs = (*C.VkSwapchainKHR)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSwapchains)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpSwapchains_allocs)

	var cpImageIndices_allocs *cgoAllocMap
	ref1d0e82d4.pImageIndices, cpImageIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PImageIndices)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpImageIndices_allocs)

	var cpResults_allocs *cgoAllocMap
	ref1d0e82d4.pResults, cpResults_allocs = (*C.VkResult)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PResults)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpResults_allocs)

	x.ref1d0e82d4 = ref1d0e82d4
	x.allocs1d0e82d4 = allocs1d0e82d4
	return ref1d0e82d4, allocs1d0e82d4

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PresentInfoKHR) PassValue() (C.VkPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		x = NewPresentInfoKHRRef(nil)
	} else if x.ref1d0e82d4 != nil {
		return *x.ref1d0e82d4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PresentInfoKHR) Deref() {
	if x.ref1d0e82d4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1d0e82d4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1d0e82d4.pNext))
	x.WaitSemaphoreCount = (uint32)(x.ref1d0e82d4.waitSemaphoreCount)
	hxff58be3 := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxff58be3.Data = uintptr(unsafe.Pointer(x.ref1d0e82d4.pWaitSemaphores))
	hxff58be3.Cap = 0x7fffffff
	// hxff58be3.Len = ?

	x.SwapchainCount = (uint32)(x.ref1d0e82d4.swapchainCount)
	hxf79f3d5 := (*sliceHeader)(unsafe.Pointer(&x.PSwapchains))
	hxf79f3d5.Data = uintptr(unsafe.Pointer(x.ref1d0e82d4.pSwapchains))
	hxf79f3d5.Cap = 0x7fffffff
	// hxf79f3d5.Len = ?

	hxfbb2d22 := (*sliceHeader)(unsafe.Pointer(&x.PImageIndices))
	hxfbb2d22.Data = uintptr(unsafe.Pointer(x.ref1d0e82d4.pImageIndices))
	hxfbb2d22.Cap = 0x7fffffff
	// hxfbb2d22.Len = ?

	hxff3831d := (*sliceHeader)(unsafe.Pointer(&x.PResults))
	hxff3831d.Data = uintptr(unsafe.Pointer(x.ref1d0e82d4.pResults))
	hxff3831d.Cap = 0x7fffffff
	// hxff3831d.Len = ?

}

// packSSwapchainCreateInfoKHR reads sliced Go data structure out from plain C format.
func packSSwapchainCreateInfoKHR(v []SwapchainCreateInfoKHR, ptr0 *C.VkSwapchainCreateInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSwapchainCreateInfoKHRValue]C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSwapchainCreateInfoKHRRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateSwapchainKHR) PassRef() (ref *C.PFN_vkCreateSwapchainKHR, allocs *cgoAllocMap) {
	if pFNCreateSwapchainKHR2B7F1C9EFunc == nil {
		pFNCreateSwapchainKHR2B7F1C9EFunc = x
	}
	return (*C.PFN_vkCreateSwapchainKHR)(C.PFN_vkCreateSwapchainKHR_2b7f1c9e), nil
}

// PassValue returns a value.
func (x PFNCreateSwapchainKHR) PassValue() (ref C.PFN_vkCreateSwapchainKHR, allocs *cgoAllocMap) {
	if pFNCreateSwapchainKHR2B7F1C9EFunc == nil {
		pFNCreateSwapchainKHR2B7F1C9EFunc = x
	}
	return (C.PFN_vkCreateSwapchainKHR)(C.PFN_vkCreateSwapchainKHR_2b7f1c9e), nil
}

//export pFNCreateSwapchainKHR2B7F1C9E
func pFNCreateSwapchainKHR2B7F1C9E(cDevice C.VkDevice, cPCreateInfo *C.VkSwapchainCreateInfoKHR, cPAllocator *C.VkAllocationCallbacks, cPSwapchain *C.VkSwapchainKHR) C.VkResult {
	if pFNCreateSwapchainKHR2B7F1C9EFunc != nil {
		Device2b7f1c9e := *(*Device)(unsafe.Pointer(&cDevice))
		var PCreateInfo2b7f1c9e []SwapchainCreateInfoKHR
		packSSwapchainCreateInfoKHR(PCreateInfo2b7f1c9e, cPCreateInfo)
		var PAllocator2b7f1c9e []AllocationCallbacks
		packSAllocationCallbacks(PAllocator2b7f1c9e, cPAllocator)
		var PSwapchain2b7f1c9e []SwapchainKHR
		hxf3b2498 := (*sliceHeader)(unsafe.Pointer(&PSwapchain2b7f1c9e))
		hxf3b2498.Data = uintptr(unsafe.Pointer(cPSwapchain))
		hxf3b2498.Cap = 0x7fffffff
		// hxf3b2498.Len = ?

		ret2b7f1c9e := pFNCreateSwapchainKHR2B7F1C9EFunc(Device2b7f1c9e, PCreateInfo2b7f1c9e, PAllocator2b7f1c9e, PSwapchain2b7f1c9e)
		ret, _ := (C.VkResult)(ret2b7f1c9e), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateSwapchainKHR2B7F1C9EFunc PFNCreateSwapchainKHR

// PassRef returns a reference.
func (x PFNDestroySwapchainKHR) PassRef() (ref *C.PFN_vkDestroySwapchainKHR, allocs *cgoAllocMap) {
	if pFNDestroySwapchainKHR23EC4B61Func == nil {
		pFNDestroySwapchainKHR23EC4B61Func = x
	}
	return (*C.PFN_vkDestroySwapchainKHR)(C.PFN_vkDestroySwapchainKHR_23ec4b61), nil
}

// PassValue returns a value.
func (x PFNDestroySwapchainKHR) PassValue() (ref C.PFN_vkDestroySwapchainKHR, allocs *cgoAllocMap) {
	if pFNDestroySwapchainKHR23EC4B61Func == nil {
		pFNDestroySwapchainKHR23EC4B61Func = x
	}
	return (C.PFN_vkDestroySwapchainKHR)(C.PFN_vkDestroySwapchainKHR_23ec4b61), nil
}

//export pFNDestroySwapchainKHR23EC4B61
func pFNDestroySwapchainKHR23EC4B61(cDevice C.VkDevice, cSwapchain C.VkSwapchainKHR, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroySwapchainKHR23EC4B61Func != nil {
		Device23ec4b61 := *(*Device)(unsafe.Pointer(&cDevice))
		Swapchain23ec4b61 := *(*SwapchainKHR)(unsafe.Pointer(&cSwapchain))
		var PAllocator23ec4b61 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator23ec4b61, cPAllocator)
		pFNDestroySwapchainKHR23EC4B61Func(Device23ec4b61, Swapchain23ec4b61, PAllocator23ec4b61)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroySwapchainKHR23EC4B61Func PFNDestroySwapchainKHR

// PassRef returns a reference.
func (x PFNGetSwapchainImagesKHR) PassRef() (ref *C.PFN_vkGetSwapchainImagesKHR, allocs *cgoAllocMap) {
	if pFNGetSwapchainImagesKHRCAEF1C13Func == nil {
		pFNGetSwapchainImagesKHRCAEF1C13Func = x
	}
	return (*C.PFN_vkGetSwapchainImagesKHR)(C.PFN_vkGetSwapchainImagesKHR_caef1c13), nil
}

// PassValue returns a value.
func (x PFNGetSwapchainImagesKHR) PassValue() (ref C.PFN_vkGetSwapchainImagesKHR, allocs *cgoAllocMap) {
	if pFNGetSwapchainImagesKHRCAEF1C13Func == nil {
		pFNGetSwapchainImagesKHRCAEF1C13Func = x
	}
	return (C.PFN_vkGetSwapchainImagesKHR)(C.PFN_vkGetSwapchainImagesKHR_caef1c13), nil
}

//export pFNGetSwapchainImagesKHRCAEF1C13
func pFNGetSwapchainImagesKHRCAEF1C13(cDevice C.VkDevice, cSwapchain C.VkSwapchainKHR, cPSwapchainImageCount *C.uint32_t, cPSwapchainImages *C.VkImage) C.VkResult {
	if pFNGetSwapchainImagesKHRCAEF1C13Func != nil {
		Devicecaef1c13 := *(*Device)(unsafe.Pointer(&cDevice))
		Swapchaincaef1c13 := *(*SwapchainKHR)(unsafe.Pointer(&cSwapchain))
		var PSwapchainImageCountcaef1c13 []uint32
		hxfe80fc5 := (*sliceHeader)(unsafe.Pointer(&PSwapchainImageCountcaef1c13))
		hxfe80fc5.Data = uintptr(unsafe.Pointer(cPSwapchainImageCount))
		hxfe80fc5.Cap = 0x7fffffff
		// hxfe80fc5.Len = ?

		var PSwapchainImagescaef1c13 []Image
		hxfc03c44 := (*sliceHeader)(unsafe.Pointer(&PSwapchainImagescaef1c13))
		hxfc03c44.Data = uintptr(unsafe.Pointer(cPSwapchainImages))
		hxfc03c44.Cap = 0x7fffffff
		// hxfc03c44.Len = ?

		retcaef1c13 := pFNGetSwapchainImagesKHRCAEF1C13Func(Devicecaef1c13, Swapchaincaef1c13, PSwapchainImageCountcaef1c13, PSwapchainImagescaef1c13)
		ret, _ := (C.VkResult)(retcaef1c13), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNGetSwapchainImagesKHRCAEF1C13Func PFNGetSwapchainImagesKHR

// PassRef returns a reference.
func (x PFNAcquireNextImageKHR) PassRef() (ref *C.PFN_vkAcquireNextImageKHR, allocs *cgoAllocMap) {
	if pFNAcquireNextImageKHRBCE813C0Func == nil {
		pFNAcquireNextImageKHRBCE813C0Func = x
	}
	return (*C.PFN_vkAcquireNextImageKHR)(C.PFN_vkAcquireNextImageKHR_bce813c0), nil
}

// PassValue returns a value.
func (x PFNAcquireNextImageKHR) PassValue() (ref C.PFN_vkAcquireNextImageKHR, allocs *cgoAllocMap) {
	if pFNAcquireNextImageKHRBCE813C0Func == nil {
		pFNAcquireNextImageKHRBCE813C0Func = x
	}
	return (C.PFN_vkAcquireNextImageKHR)(C.PFN_vkAcquireNextImageKHR_bce813c0), nil
}

//export pFNAcquireNextImageKHRBCE813C0
func pFNAcquireNextImageKHRBCE813C0(cDevice C.VkDevice, cSwapchain C.VkSwapchainKHR, cTimeout C.uint64_t, cSemaphore C.VkSemaphore, cFence C.VkFence, cPImageIndex *C.uint32_t) C.VkResult {
	if pFNAcquireNextImageKHRBCE813C0Func != nil {
		Devicebce813c0 := *(*Device)(unsafe.Pointer(&cDevice))
		Swapchainbce813c0 := *(*SwapchainKHR)(unsafe.Pointer(&cSwapchain))
		Timeoutbce813c0 := (uint64)(cTimeout)
		Semaphorebce813c0 := *(*Semaphore)(unsafe.Pointer(&cSemaphore))
		Fencebce813c0 := *(*Fence)(unsafe.Pointer(&cFence))
		var PImageIndexbce813c0 []uint32
		hxf32b611 := (*sliceHeader)(unsafe.Pointer(&PImageIndexbce813c0))
		hxf32b611.Data = uintptr(unsafe.Pointer(cPImageIndex))
		hxf32b611.Cap = 0x7fffffff
		// hxf32b611.Len = ?

		retbce813c0 := pFNAcquireNextImageKHRBCE813C0Func(Devicebce813c0, Swapchainbce813c0, Timeoutbce813c0, Semaphorebce813c0, Fencebce813c0, PImageIndexbce813c0)
		ret, _ := (C.VkResult)(retbce813c0), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNAcquireNextImageKHRBCE813C0Func PFNAcquireNextImageKHR

// packSPresentInfoKHR reads sliced Go data structure out from plain C format.
func packSPresentInfoKHR(v []PresentInfoKHR, ptr0 *C.VkPresentInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPresentInfoKHRValue]C.VkPresentInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPresentInfoKHRRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNQueuePresentKHR) PassRef() (ref *C.PFN_vkQueuePresentKHR, allocs *cgoAllocMap) {
	if pFNQueuePresentKHRFA5AB313Func == nil {
		pFNQueuePresentKHRFA5AB313Func = x
	}
	return (*C.PFN_vkQueuePresentKHR)(C.PFN_vkQueuePresentKHR_fa5ab313), nil
}

// PassValue returns a value.
func (x PFNQueuePresentKHR) PassValue() (ref C.PFN_vkQueuePresentKHR, allocs *cgoAllocMap) {
	if pFNQueuePresentKHRFA5AB313Func == nil {
		pFNQueuePresentKHRFA5AB313Func = x
	}
	return (C.PFN_vkQueuePresentKHR)(C.PFN_vkQueuePresentKHR_fa5ab313), nil
}

//export pFNQueuePresentKHRFA5AB313
func pFNQueuePresentKHRFA5AB313(cQueue C.VkQueue, cPPresentInfo *C.VkPresentInfoKHR) C.VkResult {
	if pFNQueuePresentKHRFA5AB313Func != nil {
		Queuefa5ab313 := *(*Queue)(unsafe.Pointer(&cQueue))
		var PPresentInfofa5ab313 []PresentInfoKHR
		packSPresentInfoKHR(PPresentInfofa5ab313, cPPresentInfo)
		retfa5ab313 := pFNQueuePresentKHRFA5AB313Func(Queuefa5ab313, PPresentInfofa5ab313)
		ret, _ := (C.VkResult)(retfa5ab313), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNQueuePresentKHRFA5AB313Func PFNQueuePresentKHR

// allocDisplayPropertiesKHRMemory allocates memory for type C.VkDisplayPropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPropertiesKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPropertiesKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPropertiesKHRValue = unsafe.Sizeof([1]C.VkDisplayPropertiesKHR{})

// Ref returns a reference.
func (x *DisplayPropertiesKHR) Ref() *C.VkDisplayPropertiesKHR {
	if x == nil {
		return nil
	}
	return x.reffe2a7187
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplayPropertiesKHR) Free() {
	if x != nil && x.allocsfe2a7187 != nil {
		x.allocsfe2a7187.(*cgoAllocMap).Free()
		x.reffe2a7187 = nil
	}
}

// NewDisplayPropertiesKHRRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplayPropertiesKHRRef(ref *C.VkDisplayPropertiesKHR) *DisplayPropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPropertiesKHR)
	obj.reffe2a7187 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplayPropertiesKHR) PassRef() (*C.VkDisplayPropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe2a7187 != nil {
		return x.reffe2a7187, nil
	}
	memfe2a7187 := allocDisplayPropertiesKHRMemory(1)
	reffe2a7187 := (*C.VkDisplayPropertiesKHR)(memfe2a7187)
	allocsfe2a7187 := new(cgoAllocMap)
	var cdisplay_allocs *cgoAllocMap
	reffe2a7187.display, cdisplay_allocs = *(*C.VkDisplayKHR)(unsafe.Pointer(&x.Display)), cgoAllocsUnknown
	allocsfe2a7187.Borrow(cdisplay_allocs)

	var cdisplayName_allocs *cgoAllocMap
	reffe2a7187.displayName, cdisplayName_allocs = unpackPCharString(x.DisplayName)
	allocsfe2a7187.Borrow(cdisplayName_allocs)

	var cphysicalDimensions_allocs *cgoAllocMap
	reffe2a7187.physicalDimensions, cphysicalDimensions_allocs = x.PhysicalDimensions.PassValue()
	allocsfe2a7187.Borrow(cphysicalDimensions_allocs)

	var cphysicalResolution_allocs *cgoAllocMap
	reffe2a7187.physicalResolution, cphysicalResolution_allocs = x.PhysicalResolution.PassValue()
	allocsfe2a7187.Borrow(cphysicalResolution_allocs)

	var csupportedTransforms_allocs *cgoAllocMap
	reffe2a7187.supportedTransforms, csupportedTransforms_allocs = (C.VkSurfaceTransformFlagsKHR)(x.SupportedTransforms), cgoAllocsUnknown
	allocsfe2a7187.Borrow(csupportedTransforms_allocs)

	var cplaneReorderPossible_allocs *cgoAllocMap
	reffe2a7187.planeReorderPossible, cplaneReorderPossible_allocs = (C.VkBool32)(x.PlaneReorderPossible), cgoAllocsUnknown
	allocsfe2a7187.Borrow(cplaneReorderPossible_allocs)

	var cpersistentContent_allocs *cgoAllocMap
	reffe2a7187.persistentContent, cpersistentContent_allocs = (C.VkBool32)(x.PersistentContent), cgoAllocsUnknown
	allocsfe2a7187.Borrow(cpersistentContent_allocs)

	x.reffe2a7187 = reffe2a7187
	x.allocsfe2a7187 = allocsfe2a7187
	return reffe2a7187, allocsfe2a7187

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DisplayPropertiesKHR) PassValue() (C.VkDisplayPropertiesKHR, *cgoAllocMap) {
	if x == nil {
		x = NewDisplayPropertiesKHRRef(nil)
	} else if x.reffe2a7187 != nil {
		return *x.reffe2a7187, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplayPropertiesKHR) Deref() {
	if x.reffe2a7187 == nil {
		return
	}
	x.Display = *(*DisplayKHR)(unsafe.Pointer(&x.reffe2a7187.display))
	x.DisplayName = packPCharString(x.reffe2a7187.displayName)
	x.PhysicalDimensions = *NewExtent2DRef(&x.reffe2a7187.physicalDimensions)
	x.PhysicalResolution = *NewExtent2DRef(&x.reffe2a7187.physicalResolution)
	x.SupportedTransforms = (SurfaceTransformFlagsKHR)(x.reffe2a7187.supportedTransforms)
	x.PlaneReorderPossible = (Bool32)(x.reffe2a7187.planeReorderPossible)
	x.PersistentContent = (Bool32)(x.reffe2a7187.persistentContent)
}

// allocDisplayModeParametersKHRMemory allocates memory for type C.VkDisplayModeParametersKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModeParametersKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModeParametersKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayModeParametersKHRValue = unsafe.Sizeof([1]C.VkDisplayModeParametersKHR{})

// Ref returns a reference.
func (x *DisplayModeParametersKHR) Ref() *C.VkDisplayModeParametersKHR {
	if x == nil {
		return nil
	}
	return x.refe016f77f
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplayModeParametersKHR) Free() {
	if x != nil && x.allocse016f77f != nil {
		x.allocse016f77f.(*cgoAllocMap).Free()
		x.refe016f77f = nil
	}
}

// NewDisplayModeParametersKHRRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplayModeParametersKHRRef(ref *C.VkDisplayModeParametersKHR) *DisplayModeParametersKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModeParametersKHR)
	obj.refe016f77f = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplayModeParametersKHR) PassRef() (*C.VkDisplayModeParametersKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe016f77f != nil {
		return x.refe016f77f, nil
	}
	meme016f77f := allocDisplayModeParametersKHRMemory(1)
	refe016f77f := (*C.VkDisplayModeParametersKHR)(meme016f77f)
	allocse016f77f := new(cgoAllocMap)
	var cvisibleRegion_allocs *cgoAllocMap
	refe016f77f.visibleRegion, cvisibleRegion_allocs = x.VisibleRegion.PassValue()
	allocse016f77f.Borrow(cvisibleRegion_allocs)

	var crefreshRate_allocs *cgoAllocMap
	refe016f77f.refreshRate, crefreshRate_allocs = (C.uint32_t)(x.RefreshRate), cgoAllocsUnknown
	allocse016f77f.Borrow(crefreshRate_allocs)

	x.refe016f77f = refe016f77f
	x.allocse016f77f = allocse016f77f
	return refe016f77f, allocse016f77f

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DisplayModeParametersKHR) PassValue() (C.VkDisplayModeParametersKHR, *cgoAllocMap) {
	if x == nil {
		x = NewDisplayModeParametersKHRRef(nil)
	} else if x.refe016f77f != nil {
		return *x.refe016f77f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplayModeParametersKHR) Deref() {
	if x.refe016f77f == nil {
		return
	}
	x.VisibleRegion = *NewExtent2DRef(&x.refe016f77f.visibleRegion)
	x.RefreshRate = (uint32)(x.refe016f77f.refreshRate)
}

// allocDisplayModePropertiesKHRMemory allocates memory for type C.VkDisplayModePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModePropertiesKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModePropertiesKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayModePropertiesKHRValue = unsafe.Sizeof([1]C.VkDisplayModePropertiesKHR{})

// Ref returns a reference.
func (x *DisplayModePropertiesKHR) Ref() *C.VkDisplayModePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref5e3abaaa
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplayModePropertiesKHR) Free() {
	if x != nil && x.allocs5e3abaaa != nil {
		x.allocs5e3abaaa.(*cgoAllocMap).Free()
		x.ref5e3abaaa = nil
	}
}

// NewDisplayModePropertiesKHRRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplayModePropertiesKHRRef(ref *C.VkDisplayModePropertiesKHR) *DisplayModePropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModePropertiesKHR)
	obj.ref5e3abaaa = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplayModePropertiesKHR) PassRef() (*C.VkDisplayModePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e3abaaa != nil {
		return x.ref5e3abaaa, nil
	}
	mem5e3abaaa := allocDisplayModePropertiesKHRMemory(1)
	ref5e3abaaa := (*C.VkDisplayModePropertiesKHR)(mem5e3abaaa)
	allocs5e3abaaa := new(cgoAllocMap)
	var cdisplayMode_allocs *cgoAllocMap
	ref5e3abaaa.displayMode, cdisplayMode_allocs = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.DisplayMode)), cgoAllocsUnknown
	allocs5e3abaaa.Borrow(cdisplayMode_allocs)

	var cparameters_allocs *cgoAllocMap
	ref5e3abaaa.parameters, cparameters_allocs = x.Parameters.PassValue()
	allocs5e3abaaa.Borrow(cparameters_allocs)

	x.ref5e3abaaa = ref5e3abaaa
	x.allocs5e3abaaa = allocs5e3abaaa
	return ref5e3abaaa, allocs5e3abaaa

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DisplayModePropertiesKHR) PassValue() (C.VkDisplayModePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		x = NewDisplayModePropertiesKHRRef(nil)
	} else if x.ref5e3abaaa != nil {
		return *x.ref5e3abaaa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplayModePropertiesKHR) Deref() {
	if x.ref5e3abaaa == nil {
		return
	}
	x.DisplayMode = *(*DisplayModeKHR)(unsafe.Pointer(&x.ref5e3abaaa.displayMode))
	x.Parameters = *NewDisplayModeParametersKHRRef(&x.ref5e3abaaa.parameters)
}

// allocDisplayModeCreateInfoKHRMemory allocates memory for type C.VkDisplayModeCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModeCreateInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModeCreateInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayModeCreateInfoKHRValue = unsafe.Sizeof([1]C.VkDisplayModeCreateInfoKHR{})

// Ref returns a reference.
func (x *DisplayModeCreateInfoKHR) Ref() *C.VkDisplayModeCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref392fca31
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplayModeCreateInfoKHR) Free() {
	if x != nil && x.allocs392fca31 != nil {
		x.allocs392fca31.(*cgoAllocMap).Free()
		x.ref392fca31 = nil
	}
}

// NewDisplayModeCreateInfoKHRRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplayModeCreateInfoKHRRef(ref *C.VkDisplayModeCreateInfoKHR) *DisplayModeCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModeCreateInfoKHR)
	obj.ref392fca31 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplayModeCreateInfoKHR) PassRef() (*C.VkDisplayModeCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref392fca31 != nil {
		return x.ref392fca31, nil
	}
	mem392fca31 := allocDisplayModeCreateInfoKHRMemory(1)
	ref392fca31 := (*C.VkDisplayModeCreateInfoKHR)(mem392fca31)
	allocs392fca31 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref392fca31.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs392fca31.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref392fca31.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs392fca31.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref392fca31.flags, cflags_allocs = (C.VkDisplayModeCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs392fca31.Borrow(cflags_allocs)

	var cparameters_allocs *cgoAllocMap
	ref392fca31.parameters, cparameters_allocs = x.Parameters.PassValue()
	allocs392fca31.Borrow(cparameters_allocs)

	x.ref392fca31 = ref392fca31
	x.allocs392fca31 = allocs392fca31
	return ref392fca31, allocs392fca31

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DisplayModeCreateInfoKHR) PassValue() (C.VkDisplayModeCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		x = NewDisplayModeCreateInfoKHRRef(nil)
	} else if x.ref392fca31 != nil {
		return *x.ref392fca31, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplayModeCreateInfoKHR) Deref() {
	if x.ref392fca31 == nil {
		return
	}
	x.SType = (StructureType)(x.ref392fca31.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref392fca31.pNext))
	x.Flags = (DisplayModeCreateFlagsKHR)(x.ref392fca31.flags)
	x.Parameters = *NewDisplayModeParametersKHRRef(&x.ref392fca31.parameters)
}

// allocDisplayPlaneCapabilitiesKHRMemory allocates memory for type C.VkDisplayPlaneCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneCapabilitiesKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneCapabilitiesKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPlaneCapabilitiesKHRValue = unsafe.Sizeof([1]C.VkDisplayPlaneCapabilitiesKHR{})

// Ref returns a reference.
func (x *DisplayPlaneCapabilitiesKHR) Ref() *C.VkDisplayPlaneCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.ref6f31fcaf
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplayPlaneCapabilitiesKHR) Free() {
	if x != nil && x.allocs6f31fcaf != nil {
		x.allocs6f31fcaf.(*cgoAllocMap).Free()
		x.ref6f31fcaf = nil
	}
}

// NewDisplayPlaneCapabilitiesKHRRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplayPlaneCapabilitiesKHRRef(ref *C.VkDisplayPlaneCapabilitiesKHR) *DisplayPlaneCapabilitiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneCapabilitiesKHR)
	obj.ref6f31fcaf = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplayPlaneCapabilitiesKHR) PassRef() (*C.VkDisplayPlaneCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6f31fcaf != nil {
		return x.ref6f31fcaf, nil
	}
	mem6f31fcaf := allocDisplayPlaneCapabilitiesKHRMemory(1)
	ref6f31fcaf := (*C.VkDisplayPlaneCapabilitiesKHR)(mem6f31fcaf)
	allocs6f31fcaf := new(cgoAllocMap)
	var csupportedAlpha_allocs *cgoAllocMap
	ref6f31fcaf.supportedAlpha, csupportedAlpha_allocs = (C.VkDisplayPlaneAlphaFlagsKHR)(x.SupportedAlpha), cgoAllocsUnknown
	allocs6f31fcaf.Borrow(csupportedAlpha_allocs)

	var cminSrcPosition_allocs *cgoAllocMap
	ref6f31fcaf.minSrcPosition, cminSrcPosition_allocs = x.MinSrcPosition.PassValue()
	allocs6f31fcaf.Borrow(cminSrcPosition_allocs)

	var cmaxSrcPosition_allocs *cgoAllocMap
	ref6f31fcaf.maxSrcPosition, cmaxSrcPosition_allocs = x.MaxSrcPosition.PassValue()
	allocs6f31fcaf.Borrow(cmaxSrcPosition_allocs)

	var cminSrcExtent_allocs *cgoAllocMap
	ref6f31fcaf.minSrcExtent, cminSrcExtent_allocs = x.MinSrcExtent.PassValue()
	allocs6f31fcaf.Borrow(cminSrcExtent_allocs)

	var cmaxSrcExtent_allocs *cgoAllocMap
	ref6f31fcaf.maxSrcExtent, cmaxSrcExtent_allocs = x.MaxSrcExtent.PassValue()
	allocs6f31fcaf.Borrow(cmaxSrcExtent_allocs)

	var cminDstPosition_allocs *cgoAllocMap
	ref6f31fcaf.minDstPosition, cminDstPosition_allocs = x.MinDstPosition.PassValue()
	allocs6f31fcaf.Borrow(cminDstPosition_allocs)

	var cmaxDstPosition_allocs *cgoAllocMap
	ref6f31fcaf.maxDstPosition, cmaxDstPosition_allocs = x.MaxDstPosition.PassValue()
	allocs6f31fcaf.Borrow(cmaxDstPosition_allocs)

	var cminDstExtent_allocs *cgoAllocMap
	ref6f31fcaf.minDstExtent, cminDstExtent_allocs = x.MinDstExtent.PassValue()
	allocs6f31fcaf.Borrow(cminDstExtent_allocs)

	var cmaxDstExtent_allocs *cgoAllocMap
	ref6f31fcaf.maxDstExtent, cmaxDstExtent_allocs = x.MaxDstExtent.PassValue()
	allocs6f31fcaf.Borrow(cmaxDstExtent_allocs)

	x.ref6f31fcaf = ref6f31fcaf
	x.allocs6f31fcaf = allocs6f31fcaf
	return ref6f31fcaf, allocs6f31fcaf

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DisplayPlaneCapabilitiesKHR) PassValue() (C.VkDisplayPlaneCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		x = NewDisplayPlaneCapabilitiesKHRRef(nil)
	} else if x.ref6f31fcaf != nil {
		return *x.ref6f31fcaf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplayPlaneCapabilitiesKHR) Deref() {
	if x.ref6f31fcaf == nil {
		return
	}
	x.SupportedAlpha = (DisplayPlaneAlphaFlagsKHR)(x.ref6f31fcaf.supportedAlpha)
	x.MinSrcPosition = *NewOffset2DRef(&x.ref6f31fcaf.minSrcPosition)
	x.MaxSrcPosition = *NewOffset2DRef(&x.ref6f31fcaf.maxSrcPosition)
	x.MinSrcExtent = *NewExtent2DRef(&x.ref6f31fcaf.minSrcExtent)
	x.MaxSrcExtent = *NewExtent2DRef(&x.ref6f31fcaf.maxSrcExtent)
	x.MinDstPosition = *NewOffset2DRef(&x.ref6f31fcaf.minDstPosition)
	x.MaxDstPosition = *NewOffset2DRef(&x.ref6f31fcaf.maxDstPosition)
	x.MinDstExtent = *NewExtent2DRef(&x.ref6f31fcaf.minDstExtent)
	x.MaxDstExtent = *NewExtent2DRef(&x.ref6f31fcaf.maxDstExtent)
}

// allocDisplayPlanePropertiesKHRMemory allocates memory for type C.VkDisplayPlanePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlanePropertiesKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlanePropertiesKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPlanePropertiesKHRValue = unsafe.Sizeof([1]C.VkDisplayPlanePropertiesKHR{})

// Ref returns a reference.
func (x *DisplayPlanePropertiesKHR) Ref() *C.VkDisplayPlanePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.refce3db3f6
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplayPlanePropertiesKHR) Free() {
	if x != nil && x.allocsce3db3f6 != nil {
		x.allocsce3db3f6.(*cgoAllocMap).Free()
		x.refce3db3f6 = nil
	}
}

// NewDisplayPlanePropertiesKHRRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplayPlanePropertiesKHRRef(ref *C.VkDisplayPlanePropertiesKHR) *DisplayPlanePropertiesKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlanePropertiesKHR)
	obj.refce3db3f6 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplayPlanePropertiesKHR) PassRef() (*C.VkDisplayPlanePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refce3db3f6 != nil {
		return x.refce3db3f6, nil
	}
	memce3db3f6 := allocDisplayPlanePropertiesKHRMemory(1)
	refce3db3f6 := (*C.VkDisplayPlanePropertiesKHR)(memce3db3f6)
	allocsce3db3f6 := new(cgoAllocMap)
	var ccurrentDisplay_allocs *cgoAllocMap
	refce3db3f6.currentDisplay, ccurrentDisplay_allocs = *(*C.VkDisplayKHR)(unsafe.Pointer(&x.CurrentDisplay)), cgoAllocsUnknown
	allocsce3db3f6.Borrow(ccurrentDisplay_allocs)

	var ccurrentStackIndex_allocs *cgoAllocMap
	refce3db3f6.currentStackIndex, ccurrentStackIndex_allocs = (C.uint32_t)(x.CurrentStackIndex), cgoAllocsUnknown
	allocsce3db3f6.Borrow(ccurrentStackIndex_allocs)

	x.refce3db3f6 = refce3db3f6
	x.allocsce3db3f6 = allocsce3db3f6
	return refce3db3f6, allocsce3db3f6

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DisplayPlanePropertiesKHR) PassValue() (C.VkDisplayPlanePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		x = NewDisplayPlanePropertiesKHRRef(nil)
	} else if x.refce3db3f6 != nil {
		return *x.refce3db3f6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplayPlanePropertiesKHR) Deref() {
	if x.refce3db3f6 == nil {
		return
	}
	x.CurrentDisplay = *(*DisplayKHR)(unsafe.Pointer(&x.refce3db3f6.currentDisplay))
	x.CurrentStackIndex = (uint32)(x.refce3db3f6.currentStackIndex)
}

// allocDisplaySurfaceCreateInfoKHRMemory allocates memory for type C.VkDisplaySurfaceCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplaySurfaceCreateInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplaySurfaceCreateInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplaySurfaceCreateInfoKHRValue = unsafe.Sizeof([1]C.VkDisplaySurfaceCreateInfoKHR{})

// Ref returns a reference.
func (x *DisplaySurfaceCreateInfoKHR) Ref() *C.VkDisplaySurfaceCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref58445c35
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplaySurfaceCreateInfoKHR) Free() {
	if x != nil && x.allocs58445c35 != nil {
		x.allocs58445c35.(*cgoAllocMap).Free()
		x.ref58445c35 = nil
	}
}

// NewDisplaySurfaceCreateInfoKHRRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplaySurfaceCreateInfoKHRRef(ref *C.VkDisplaySurfaceCreateInfoKHR) *DisplaySurfaceCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplaySurfaceCreateInfoKHR)
	obj.ref58445c35 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplaySurfaceCreateInfoKHR) PassRef() (*C.VkDisplaySurfaceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58445c35 != nil {
		return x.ref58445c35, nil
	}
	mem58445c35 := allocDisplaySurfaceCreateInfoKHRMemory(1)
	ref58445c35 := (*C.VkDisplaySurfaceCreateInfoKHR)(mem58445c35)
	allocs58445c35 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref58445c35.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs58445c35.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref58445c35.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs58445c35.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref58445c35.flags, cflags_allocs = (C.VkDisplaySurfaceCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs58445c35.Borrow(cflags_allocs)

	var cdisplayMode_allocs *cgoAllocMap
	ref58445c35.displayMode, cdisplayMode_allocs = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.DisplayMode)), cgoAllocsUnknown
	allocs58445c35.Borrow(cdisplayMode_allocs)

	var cplaneIndex_allocs *cgoAllocMap
	ref58445c35.planeIndex, cplaneIndex_allocs = (C.uint32_t)(x.PlaneIndex), cgoAllocsUnknown
	allocs58445c35.Borrow(cplaneIndex_allocs)

	var cplaneStackIndex_allocs *cgoAllocMap
	ref58445c35.planeStackIndex, cplaneStackIndex_allocs = (C.uint32_t)(x.PlaneStackIndex), cgoAllocsUnknown
	allocs58445c35.Borrow(cplaneStackIndex_allocs)

	var ctransform_allocs *cgoAllocMap
	ref58445c35.transform, ctransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.Transform), cgoAllocsUnknown
	allocs58445c35.Borrow(ctransform_allocs)

	var cglobalAlpha_allocs *cgoAllocMap
	ref58445c35.globalAlpha, cglobalAlpha_allocs = (C.float)(x.GlobalAlpha), cgoAllocsUnknown
	allocs58445c35.Borrow(cglobalAlpha_allocs)

	var calphaMode_allocs *cgoAllocMap
	ref58445c35.alphaMode, calphaMode_allocs = (C.VkDisplayPlaneAlphaFlagBitsKHR)(x.AlphaMode), cgoAllocsUnknown
	allocs58445c35.Borrow(calphaMode_allocs)

	var cimageExtent_allocs *cgoAllocMap
	ref58445c35.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocs58445c35.Borrow(cimageExtent_allocs)

	x.ref58445c35 = ref58445c35
	x.allocs58445c35 = allocs58445c35
	return ref58445c35, allocs58445c35

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DisplaySurfaceCreateInfoKHR) PassValue() (C.VkDisplaySurfaceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		x = NewDisplaySurfaceCreateInfoKHRRef(nil)
	} else if x.ref58445c35 != nil {
		return *x.ref58445c35, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplaySurfaceCreateInfoKHR) Deref() {
	if x.ref58445c35 == nil {
		return
	}
	x.SType = (StructureType)(x.ref58445c35.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref58445c35.pNext))
	x.Flags = (DisplaySurfaceCreateFlagsKHR)(x.ref58445c35.flags)
	x.DisplayMode = *(*DisplayModeKHR)(unsafe.Pointer(&x.ref58445c35.displayMode))
	x.PlaneIndex = (uint32)(x.ref58445c35.planeIndex)
	x.PlaneStackIndex = (uint32)(x.ref58445c35.planeStackIndex)
	x.Transform = (SurfaceTransformFlagBitsKHR)(x.ref58445c35.transform)
	x.GlobalAlpha = (float32)(x.ref58445c35.globalAlpha)
	x.AlphaMode = (DisplayPlaneAlphaFlagBitsKHR)(x.ref58445c35.alphaMode)
	x.ImageExtent = *NewExtent2DRef(&x.ref58445c35.imageExtent)
}

// packSDisplayPropertiesKHR reads sliced Go data structure out from plain C format.
func packSDisplayPropertiesKHR(v []DisplayPropertiesKHR, ptr0 *C.VkDisplayPropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPropertiesKHRValue]C.VkDisplayPropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPropertiesKHRRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetPhysicalDeviceDisplayPropertiesKHR) PassRef() (ref *C.PFN_vkGetPhysicalDeviceDisplayPropertiesKHR, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceDisplayPropertiesKHR625CAFBEFunc == nil {
		pFNGetPhysicalDeviceDisplayPropertiesKHR625CAFBEFunc = x
	}
	return (*C.PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)(C.PFN_vkGetPhysicalDeviceDisplayPropertiesKHR_625cafbe), nil
}

// PassValue returns a value.
func (x PFNGetPhysicalDeviceDisplayPropertiesKHR) PassValue() (ref C.PFN_vkGetPhysicalDeviceDisplayPropertiesKHR, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceDisplayPropertiesKHR625CAFBEFunc == nil {
		pFNGetPhysicalDeviceDisplayPropertiesKHR625CAFBEFunc = x
	}
	return (C.PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)(C.PFN_vkGetPhysicalDeviceDisplayPropertiesKHR_625cafbe), nil
}

//export pFNGetPhysicalDeviceDisplayPropertiesKHR625CAFBE
func pFNGetPhysicalDeviceDisplayPropertiesKHR625CAFBE(cPhysicalDevice C.VkPhysicalDevice, cPPropertyCount *C.uint32_t, cPProperties *C.VkDisplayPropertiesKHR) C.VkResult {
	if pFNGetPhysicalDeviceDisplayPropertiesKHR625CAFBEFunc != nil {
		PhysicalDevice625cafbe := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		var PPropertyCount625cafbe []uint32
		hxf187e71 := (*sliceHeader)(unsafe.Pointer(&PPropertyCount625cafbe))
		hxf187e71.Data = uintptr(unsafe.Pointer(cPPropertyCount))
		hxf187e71.Cap = 0x7fffffff
		// hxf187e71.Len = ?

		var PProperties625cafbe []DisplayPropertiesKHR
		packSDisplayPropertiesKHR(PProperties625cafbe, cPProperties)
		ret625cafbe := pFNGetPhysicalDeviceDisplayPropertiesKHR625CAFBEFunc(PhysicalDevice625cafbe, PPropertyCount625cafbe, PProperties625cafbe)
		ret, _ := (C.VkResult)(ret625cafbe), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNGetPhysicalDeviceDisplayPropertiesKHR625CAFBEFunc PFNGetPhysicalDeviceDisplayPropertiesKHR

// packSDisplayPlanePropertiesKHR reads sliced Go data structure out from plain C format.
func packSDisplayPlanePropertiesKHR(v []DisplayPlanePropertiesKHR, ptr0 *C.VkDisplayPlanePropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPlanePropertiesKHRValue]C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPlanePropertiesKHRRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetPhysicalDeviceDisplayPlanePropertiesKHR) PassRef() (ref *C.PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceDisplayPlanePropertiesKHR290F765FFunc == nil {
		pFNGetPhysicalDeviceDisplayPlanePropertiesKHR290F765FFunc = x
	}
	return (*C.PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(C.PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR_290f765f), nil
}

// PassValue returns a value.
func (x PFNGetPhysicalDeviceDisplayPlanePropertiesKHR) PassValue() (ref C.PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR, allocs *cgoAllocMap) {
	if pFNGetPhysicalDeviceDisplayPlanePropertiesKHR290F765FFunc == nil {
		pFNGetPhysicalDeviceDisplayPlanePropertiesKHR290F765FFunc = x
	}
	return (C.PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(C.PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR_290f765f), nil
}

//export pFNGetPhysicalDeviceDisplayPlanePropertiesKHR290F765F
func pFNGetPhysicalDeviceDisplayPlanePropertiesKHR290F765F(cPhysicalDevice C.VkPhysicalDevice, cPPropertyCount *C.uint32_t, cPProperties *C.VkDisplayPlanePropertiesKHR) C.VkResult {
	if pFNGetPhysicalDeviceDisplayPlanePropertiesKHR290F765FFunc != nil {
		PhysicalDevice290f765f := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		var PPropertyCount290f765f []uint32
		hxf13e50a := (*sliceHeader)(unsafe.Pointer(&PPropertyCount290f765f))
		hxf13e50a.Data = uintptr(unsafe.Pointer(cPPropertyCount))
		hxf13e50a.Cap = 0x7fffffff
		// hxf13e50a.Len = ?

		var PProperties290f765f []DisplayPlanePropertiesKHR
		packSDisplayPlanePropertiesKHR(PProperties290f765f, cPProperties)
		ret290f765f := pFNGetPhysicalDeviceDisplayPlanePropertiesKHR290F765FFunc(PhysicalDevice290f765f, PPropertyCount290f765f, PProperties290f765f)
		ret, _ := (C.VkResult)(ret290f765f), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNGetPhysicalDeviceDisplayPlanePropertiesKHR290F765FFunc PFNGetPhysicalDeviceDisplayPlanePropertiesKHR

// PassRef returns a reference.
func (x PFNGetDisplayPlaneSupportedDisplaysKHR) PassRef() (ref *C.PFN_vkGetDisplayPlaneSupportedDisplaysKHR, allocs *cgoAllocMap) {
	if pFNGetDisplayPlaneSupportedDisplaysKHRC06C75A8Func == nil {
		pFNGetDisplayPlaneSupportedDisplaysKHRC06C75A8Func = x
	}
	return (*C.PFN_vkGetDisplayPlaneSupportedDisplaysKHR)(C.PFN_vkGetDisplayPlaneSupportedDisplaysKHR_c06c75a8), nil
}

// PassValue returns a value.
func (x PFNGetDisplayPlaneSupportedDisplaysKHR) PassValue() (ref C.PFN_vkGetDisplayPlaneSupportedDisplaysKHR, allocs *cgoAllocMap) {
	if pFNGetDisplayPlaneSupportedDisplaysKHRC06C75A8Func == nil {
		pFNGetDisplayPlaneSupportedDisplaysKHRC06C75A8Func = x
	}
	return (C.PFN_vkGetDisplayPlaneSupportedDisplaysKHR)(C.PFN_vkGetDisplayPlaneSupportedDisplaysKHR_c06c75a8), nil
}

//export pFNGetDisplayPlaneSupportedDisplaysKHRC06C75A8
func pFNGetDisplayPlaneSupportedDisplaysKHRC06C75A8(cPhysicalDevice C.VkPhysicalDevice, cPlaneIndex C.uint32_t, cPDisplayCount *C.uint32_t, cPDisplays *C.VkDisplayKHR) C.VkResult {
	if pFNGetDisplayPlaneSupportedDisplaysKHRC06C75A8Func != nil {
		PhysicalDevicec06c75a8 := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		PlaneIndexc06c75a8 := (uint32)(cPlaneIndex)
		var PDisplayCountc06c75a8 []uint32
		hxf9227c2 := (*sliceHeader)(unsafe.Pointer(&PDisplayCountc06c75a8))
		hxf9227c2.Data = uintptr(unsafe.Pointer(cPDisplayCount))
		hxf9227c2.Cap = 0x7fffffff
		// hxf9227c2.Len = ?

		var PDisplaysc06c75a8 []DisplayKHR
		hxfa7b2ab := (*sliceHeader)(unsafe.Pointer(&PDisplaysc06c75a8))
		hxfa7b2ab.Data = uintptr(unsafe.Pointer(cPDisplays))
		hxfa7b2ab.Cap = 0x7fffffff
		// hxfa7b2ab.Len = ?

		retc06c75a8 := pFNGetDisplayPlaneSupportedDisplaysKHRC06C75A8Func(PhysicalDevicec06c75a8, PlaneIndexc06c75a8, PDisplayCountc06c75a8, PDisplaysc06c75a8)
		ret, _ := (C.VkResult)(retc06c75a8), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNGetDisplayPlaneSupportedDisplaysKHRC06C75A8Func PFNGetDisplayPlaneSupportedDisplaysKHR

// packSDisplayModePropertiesKHR reads sliced Go data structure out from plain C format.
func packSDisplayModePropertiesKHR(v []DisplayModePropertiesKHR, ptr0 *C.VkDisplayModePropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayModePropertiesKHRValue]C.VkDisplayModePropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayModePropertiesKHRRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetDisplayModePropertiesKHR) PassRef() (ref *C.PFN_vkGetDisplayModePropertiesKHR, allocs *cgoAllocMap) {
	if pFNGetDisplayModePropertiesKHRFA283554Func == nil {
		pFNGetDisplayModePropertiesKHRFA283554Func = x
	}
	return (*C.PFN_vkGetDisplayModePropertiesKHR)(C.PFN_vkGetDisplayModePropertiesKHR_fa283554), nil
}

// PassValue returns a value.
func (x PFNGetDisplayModePropertiesKHR) PassValue() (ref C.PFN_vkGetDisplayModePropertiesKHR, allocs *cgoAllocMap) {
	if pFNGetDisplayModePropertiesKHRFA283554Func == nil {
		pFNGetDisplayModePropertiesKHRFA283554Func = x
	}
	return (C.PFN_vkGetDisplayModePropertiesKHR)(C.PFN_vkGetDisplayModePropertiesKHR_fa283554), nil
}

//export pFNGetDisplayModePropertiesKHRFA283554
func pFNGetDisplayModePropertiesKHRFA283554(cPhysicalDevice C.VkPhysicalDevice, cDisplay C.VkDisplayKHR, cPPropertyCount *C.uint32_t, cPProperties *C.VkDisplayModePropertiesKHR) C.VkResult {
	if pFNGetDisplayModePropertiesKHRFA283554Func != nil {
		PhysicalDevicefa283554 := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		Displayfa283554 := *(*DisplayKHR)(unsafe.Pointer(&cDisplay))
		var PPropertyCountfa283554 []uint32
		hxfa34053 := (*sliceHeader)(unsafe.Pointer(&PPropertyCountfa283554))
		hxfa34053.Data = uintptr(unsafe.Pointer(cPPropertyCount))
		hxfa34053.Cap = 0x7fffffff
		// hxfa34053.Len = ?

		var PPropertiesfa283554 []DisplayModePropertiesKHR
		packSDisplayModePropertiesKHR(PPropertiesfa283554, cPProperties)
		retfa283554 := pFNGetDisplayModePropertiesKHRFA283554Func(PhysicalDevicefa283554, Displayfa283554, PPropertyCountfa283554, PPropertiesfa283554)
		ret, _ := (C.VkResult)(retfa283554), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNGetDisplayModePropertiesKHRFA283554Func PFNGetDisplayModePropertiesKHR

// packSDisplayModeCreateInfoKHR reads sliced Go data structure out from plain C format.
func packSDisplayModeCreateInfoKHR(v []DisplayModeCreateInfoKHR, ptr0 *C.VkDisplayModeCreateInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayModeCreateInfoKHRValue]C.VkDisplayModeCreateInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayModeCreateInfoKHRRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateDisplayModeKHR) PassRef() (ref *C.PFN_vkCreateDisplayModeKHR, allocs *cgoAllocMap) {
	if pFNCreateDisplayModeKHRAA042680Func == nil {
		pFNCreateDisplayModeKHRAA042680Func = x
	}
	return (*C.PFN_vkCreateDisplayModeKHR)(C.PFN_vkCreateDisplayModeKHR_aa042680), nil
}

// PassValue returns a value.
func (x PFNCreateDisplayModeKHR) PassValue() (ref C.PFN_vkCreateDisplayModeKHR, allocs *cgoAllocMap) {
	if pFNCreateDisplayModeKHRAA042680Func == nil {
		pFNCreateDisplayModeKHRAA042680Func = x
	}
	return (C.PFN_vkCreateDisplayModeKHR)(C.PFN_vkCreateDisplayModeKHR_aa042680), nil
}

//export pFNCreateDisplayModeKHRAA042680
func pFNCreateDisplayModeKHRAA042680(cPhysicalDevice C.VkPhysicalDevice, cDisplay C.VkDisplayKHR, cPCreateInfo *C.VkDisplayModeCreateInfoKHR, cPAllocator *C.VkAllocationCallbacks, cPMode *C.VkDisplayModeKHR) C.VkResult {
	if pFNCreateDisplayModeKHRAA042680Func != nil {
		PhysicalDeviceaa042680 := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		Displayaa042680 := *(*DisplayKHR)(unsafe.Pointer(&cDisplay))
		var PCreateInfoaa042680 []DisplayModeCreateInfoKHR
		packSDisplayModeCreateInfoKHR(PCreateInfoaa042680, cPCreateInfo)
		var PAllocatoraa042680 []AllocationCallbacks
		packSAllocationCallbacks(PAllocatoraa042680, cPAllocator)
		var PModeaa042680 []DisplayModeKHR
		hxfe3c193 := (*sliceHeader)(unsafe.Pointer(&PModeaa042680))
		hxfe3c193.Data = uintptr(unsafe.Pointer(cPMode))
		hxfe3c193.Cap = 0x7fffffff
		// hxfe3c193.Len = ?

		retaa042680 := pFNCreateDisplayModeKHRAA042680Func(PhysicalDeviceaa042680, Displayaa042680, PCreateInfoaa042680, PAllocatoraa042680, PModeaa042680)
		ret, _ := (C.VkResult)(retaa042680), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateDisplayModeKHRAA042680Func PFNCreateDisplayModeKHR

// packSDisplayPlaneCapabilitiesKHR reads sliced Go data structure out from plain C format.
func packSDisplayPlaneCapabilitiesKHR(v []DisplayPlaneCapabilitiesKHR, ptr0 *C.VkDisplayPlaneCapabilitiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPlaneCapabilitiesKHRValue]C.VkDisplayPlaneCapabilitiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPlaneCapabilitiesKHRRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNGetDisplayPlaneCapabilitiesKHR) PassRef() (ref *C.PFN_vkGetDisplayPlaneCapabilitiesKHR, allocs *cgoAllocMap) {
	if pFNGetDisplayPlaneCapabilitiesKHR9FC9571DFunc == nil {
		pFNGetDisplayPlaneCapabilitiesKHR9FC9571DFunc = x
	}
	return (*C.PFN_vkGetDisplayPlaneCapabilitiesKHR)(C.PFN_vkGetDisplayPlaneCapabilitiesKHR_9fc9571d), nil
}

// PassValue returns a value.
func (x PFNGetDisplayPlaneCapabilitiesKHR) PassValue() (ref C.PFN_vkGetDisplayPlaneCapabilitiesKHR, allocs *cgoAllocMap) {
	if pFNGetDisplayPlaneCapabilitiesKHR9FC9571DFunc == nil {
		pFNGetDisplayPlaneCapabilitiesKHR9FC9571DFunc = x
	}
	return (C.PFN_vkGetDisplayPlaneCapabilitiesKHR)(C.PFN_vkGetDisplayPlaneCapabilitiesKHR_9fc9571d), nil
}

//export pFNGetDisplayPlaneCapabilitiesKHR9FC9571D
func pFNGetDisplayPlaneCapabilitiesKHR9FC9571D(cPhysicalDevice C.VkPhysicalDevice, cMode C.VkDisplayModeKHR, cPlaneIndex C.uint32_t, cPCapabilities *C.VkDisplayPlaneCapabilitiesKHR) C.VkResult {
	if pFNGetDisplayPlaneCapabilitiesKHR9FC9571DFunc != nil {
		PhysicalDevice9fc9571d := *(*PhysicalDevice)(unsafe.Pointer(&cPhysicalDevice))
		Mode9fc9571d := *(*DisplayModeKHR)(unsafe.Pointer(&cMode))
		PlaneIndex9fc9571d := (uint32)(cPlaneIndex)
		var PCapabilities9fc9571d []DisplayPlaneCapabilitiesKHR
		packSDisplayPlaneCapabilitiesKHR(PCapabilities9fc9571d, cPCapabilities)
		ret9fc9571d := pFNGetDisplayPlaneCapabilitiesKHR9FC9571DFunc(PhysicalDevice9fc9571d, Mode9fc9571d, PlaneIndex9fc9571d, PCapabilities9fc9571d)
		ret, _ := (C.VkResult)(ret9fc9571d), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNGetDisplayPlaneCapabilitiesKHR9FC9571DFunc PFNGetDisplayPlaneCapabilitiesKHR

// packSDisplaySurfaceCreateInfoKHR reads sliced Go data structure out from plain C format.
func packSDisplaySurfaceCreateInfoKHR(v []DisplaySurfaceCreateInfoKHR, ptr0 *C.VkDisplaySurfaceCreateInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplaySurfaceCreateInfoKHRValue]C.VkDisplaySurfaceCreateInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplaySurfaceCreateInfoKHRRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateDisplayPlaneSurfaceKHR) PassRef() (ref *C.PFN_vkCreateDisplayPlaneSurfaceKHR, allocs *cgoAllocMap) {
	if pFNCreateDisplayPlaneSurfaceKHRA82DD380Func == nil {
		pFNCreateDisplayPlaneSurfaceKHRA82DD380Func = x
	}
	return (*C.PFN_vkCreateDisplayPlaneSurfaceKHR)(C.PFN_vkCreateDisplayPlaneSurfaceKHR_a82dd380), nil
}

// PassValue returns a value.
func (x PFNCreateDisplayPlaneSurfaceKHR) PassValue() (ref C.PFN_vkCreateDisplayPlaneSurfaceKHR, allocs *cgoAllocMap) {
	if pFNCreateDisplayPlaneSurfaceKHRA82DD380Func == nil {
		pFNCreateDisplayPlaneSurfaceKHRA82DD380Func = x
	}
	return (C.PFN_vkCreateDisplayPlaneSurfaceKHR)(C.PFN_vkCreateDisplayPlaneSurfaceKHR_a82dd380), nil
}

//export pFNCreateDisplayPlaneSurfaceKHRA82DD380
func pFNCreateDisplayPlaneSurfaceKHRA82DD380(cInstance C.VkInstance, cPCreateInfo *C.VkDisplaySurfaceCreateInfoKHR, cPAllocator *C.VkAllocationCallbacks, cPSurface *C.VkSurfaceKHR) C.VkResult {
	if pFNCreateDisplayPlaneSurfaceKHRA82DD380Func != nil {
		Instancea82dd380 := *(*Instance)(unsafe.Pointer(&cInstance))
		var PCreateInfoa82dd380 []DisplaySurfaceCreateInfoKHR
		packSDisplaySurfaceCreateInfoKHR(PCreateInfoa82dd380, cPCreateInfo)
		var PAllocatora82dd380 []AllocationCallbacks
		packSAllocationCallbacks(PAllocatora82dd380, cPAllocator)
		var PSurfacea82dd380 []SurfaceKHR
		hxfe8267c := (*sliceHeader)(unsafe.Pointer(&PSurfacea82dd380))
		hxfe8267c.Data = uintptr(unsafe.Pointer(cPSurface))
		hxfe8267c.Cap = 0x7fffffff
		// hxfe8267c.Len = ?

		reta82dd380 := pFNCreateDisplayPlaneSurfaceKHRA82DD380Func(Instancea82dd380, PCreateInfoa82dd380, PAllocatora82dd380, PSurfacea82dd380)
		ret, _ := (C.VkResult)(reta82dd380), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateDisplayPlaneSurfaceKHRA82DD380Func PFNCreateDisplayPlaneSurfaceKHR

// allocDisplayPresentInfoKHRMemory allocates memory for type C.VkDisplayPresentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPresentInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPresentInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPresentInfoKHRValue = unsafe.Sizeof([1]C.VkDisplayPresentInfoKHR{})

// Ref returns a reference.
func (x *DisplayPresentInfoKHR) Ref() *C.VkDisplayPresentInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref8d2571e4
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplayPresentInfoKHR) Free() {
	if x != nil && x.allocs8d2571e4 != nil {
		x.allocs8d2571e4.(*cgoAllocMap).Free()
		x.ref8d2571e4 = nil
	}
}

// NewDisplayPresentInfoKHRRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplayPresentInfoKHRRef(ref *C.VkDisplayPresentInfoKHR) *DisplayPresentInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPresentInfoKHR)
	obj.ref8d2571e4 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplayPresentInfoKHR) PassRef() (*C.VkDisplayPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8d2571e4 != nil {
		return x.ref8d2571e4, nil
	}
	mem8d2571e4 := allocDisplayPresentInfoKHRMemory(1)
	ref8d2571e4 := (*C.VkDisplayPresentInfoKHR)(mem8d2571e4)
	allocs8d2571e4 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref8d2571e4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8d2571e4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8d2571e4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8d2571e4.Borrow(cpNext_allocs)

	var csrcRect_allocs *cgoAllocMap
	ref8d2571e4.srcRect, csrcRect_allocs = x.SrcRect.PassValue()
	allocs8d2571e4.Borrow(csrcRect_allocs)

	var cdstRect_allocs *cgoAllocMap
	ref8d2571e4.dstRect, cdstRect_allocs = x.DstRect.PassValue()
	allocs8d2571e4.Borrow(cdstRect_allocs)

	var cpersistent_allocs *cgoAllocMap
	ref8d2571e4.persistent, cpersistent_allocs = (C.VkBool32)(x.Persistent), cgoAllocsUnknown
	allocs8d2571e4.Borrow(cpersistent_allocs)

	x.ref8d2571e4 = ref8d2571e4
	x.allocs8d2571e4 = allocs8d2571e4
	return ref8d2571e4, allocs8d2571e4

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DisplayPresentInfoKHR) PassValue() (C.VkDisplayPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		x = NewDisplayPresentInfoKHRRef(nil)
	} else if x.ref8d2571e4 != nil {
		return *x.ref8d2571e4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplayPresentInfoKHR) Deref() {
	if x.ref8d2571e4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8d2571e4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8d2571e4.pNext))
	x.SrcRect = *NewRect2DRef(&x.ref8d2571e4.srcRect)
	x.DstRect = *NewRect2DRef(&x.ref8d2571e4.dstRect)
	x.Persistent = (Bool32)(x.ref8d2571e4.persistent)
}

// PassRef returns a reference.
func (x PFNCreateSharedSwapchainsKHR) PassRef() (ref *C.PFN_vkCreateSharedSwapchainsKHR, allocs *cgoAllocMap) {
	if pFNCreateSharedSwapchainsKHR4BB273FFunc == nil {
		pFNCreateSharedSwapchainsKHR4BB273FFunc = x
	}
	return (*C.PFN_vkCreateSharedSwapchainsKHR)(C.PFN_vkCreateSharedSwapchainsKHR_4bb273f), nil
}

// PassValue returns a value.
func (x PFNCreateSharedSwapchainsKHR) PassValue() (ref C.PFN_vkCreateSharedSwapchainsKHR, allocs *cgoAllocMap) {
	if pFNCreateSharedSwapchainsKHR4BB273FFunc == nil {
		pFNCreateSharedSwapchainsKHR4BB273FFunc = x
	}
	return (C.PFN_vkCreateSharedSwapchainsKHR)(C.PFN_vkCreateSharedSwapchainsKHR_4bb273f), nil
}

//export pFNCreateSharedSwapchainsKHR4BB273F
func pFNCreateSharedSwapchainsKHR4BB273F(cDevice C.VkDevice, cSwapchainCount C.uint32_t, cPCreateInfos *C.VkSwapchainCreateInfoKHR, cPAllocator *C.VkAllocationCallbacks, cPSwapchains *C.VkSwapchainKHR) C.VkResult {
	if pFNCreateSharedSwapchainsKHR4BB273FFunc != nil {
		Device4bb273f := *(*Device)(unsafe.Pointer(&cDevice))
		SwapchainCount4bb273f := (uint32)(cSwapchainCount)
		var PCreateInfos4bb273f []SwapchainCreateInfoKHR
		packSSwapchainCreateInfoKHR(PCreateInfos4bb273f, cPCreateInfos)
		var PAllocator4bb273f []AllocationCallbacks
		packSAllocationCallbacks(PAllocator4bb273f, cPAllocator)
		var PSwapchains4bb273f []SwapchainKHR
		hxf9143ee := (*sliceHeader)(unsafe.Pointer(&PSwapchains4bb273f))
		hxf9143ee.Data = uintptr(unsafe.Pointer(cPSwapchains))
		hxf9143ee.Cap = 0x7fffffff
		// hxf9143ee.Len = ?

		ret4bb273f := pFNCreateSharedSwapchainsKHR4BB273FFunc(Device4bb273f, SwapchainCount4bb273f, PCreateInfos4bb273f, PAllocator4bb273f, PSwapchains4bb273f)
		ret, _ := (C.VkResult)(ret4bb273f), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateSharedSwapchainsKHR4BB273FFunc PFNCreateSharedSwapchainsKHR

// allocAndroidSurfaceCreateInfoKHRMemory allocates memory for type C.VkAndroidSurfaceCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAndroidSurfaceCreateInfoKHRMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAndroidSurfaceCreateInfoKHRValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAndroidSurfaceCreateInfoKHRValue = unsafe.Sizeof([1]C.VkAndroidSurfaceCreateInfoKHR{})

// Ref returns a reference.
func (x *AndroidSurfaceCreateInfoKHR) Ref() *C.VkAndroidSurfaceCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.refeca5c35c
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *AndroidSurfaceCreateInfoKHR) Free() {
	if x != nil && x.allocseca5c35c != nil {
		x.allocseca5c35c.(*cgoAllocMap).Free()
		x.refeca5c35c = nil
	}
}

// NewAndroidSurfaceCreateInfoKHRRef initialises a new struct holding the reference to the originaitng C struct.
func NewAndroidSurfaceCreateInfoKHRRef(ref *C.VkAndroidSurfaceCreateInfoKHR) *AndroidSurfaceCreateInfoKHR {
	if ref == nil {
		return nil
	}
	obj := new(AndroidSurfaceCreateInfoKHR)
	obj.refeca5c35c = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *AndroidSurfaceCreateInfoKHR) PassRef() (*C.VkAndroidSurfaceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeca5c35c != nil {
		return x.refeca5c35c, nil
	}
	memeca5c35c := allocAndroidSurfaceCreateInfoKHRMemory(1)
	refeca5c35c := (*C.VkAndroidSurfaceCreateInfoKHR)(memeca5c35c)
	allocseca5c35c := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refeca5c35c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseca5c35c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeca5c35c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseca5c35c.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refeca5c35c.flags, cflags_allocs = (C.VkAndroidSurfaceCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocseca5c35c.Borrow(cflags_allocs)

	x.refeca5c35c = refeca5c35c
	x.allocseca5c35c = allocseca5c35c
	return refeca5c35c, allocseca5c35c

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *AndroidSurfaceCreateInfoKHR) PassValue() (C.VkAndroidSurfaceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		x = NewAndroidSurfaceCreateInfoKHRRef(nil)
	} else if x.refeca5c35c != nil {
		return *x.refeca5c35c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *AndroidSurfaceCreateInfoKHR) Deref() {
	if x.refeca5c35c == nil {
		return
	}
	x.SType = (StructureType)(x.refeca5c35c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeca5c35c.pNext))
	x.Flags = (AndroidSurfaceCreateFlagsKHR)(x.refeca5c35c.flags)
}

// packSAndroidSurfaceCreateInfoKHR reads sliced Go data structure out from plain C format.
func packSAndroidSurfaceCreateInfoKHR(v []AndroidSurfaceCreateInfoKHR, ptr0 *C.VkAndroidSurfaceCreateInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAndroidSurfaceCreateInfoKHRValue]C.VkAndroidSurfaceCreateInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAndroidSurfaceCreateInfoKHRRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateAndroidSurfaceKHR) PassRef() (ref *C.PFN_vkCreateAndroidSurfaceKHR, allocs *cgoAllocMap) {
	if pFNCreateAndroidSurfaceKHR45C62D4Func == nil {
		pFNCreateAndroidSurfaceKHR45C62D4Func = x
	}
	return (*C.PFN_vkCreateAndroidSurfaceKHR)(C.PFN_vkCreateAndroidSurfaceKHR_45c62d4), nil
}

// PassValue returns a value.
func (x PFNCreateAndroidSurfaceKHR) PassValue() (ref C.PFN_vkCreateAndroidSurfaceKHR, allocs *cgoAllocMap) {
	if pFNCreateAndroidSurfaceKHR45C62D4Func == nil {
		pFNCreateAndroidSurfaceKHR45C62D4Func = x
	}
	return (C.PFN_vkCreateAndroidSurfaceKHR)(C.PFN_vkCreateAndroidSurfaceKHR_45c62d4), nil
}

//export pFNCreateAndroidSurfaceKHR45C62D4
func pFNCreateAndroidSurfaceKHR45C62D4(cInstance C.VkInstance, cPCreateInfo *C.VkAndroidSurfaceCreateInfoKHR, cPAllocator *C.VkAllocationCallbacks, cPSurface *C.VkSurfaceKHR) C.VkResult {
	if pFNCreateAndroidSurfaceKHR45C62D4Func != nil {
		Instance45c62d4 := *(*Instance)(unsafe.Pointer(&cInstance))
		var PCreateInfo45c62d4 []AndroidSurfaceCreateInfoKHR
		packSAndroidSurfaceCreateInfoKHR(PCreateInfo45c62d4, cPCreateInfo)
		var PAllocator45c62d4 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator45c62d4, cPAllocator)
		var PSurface45c62d4 []SurfaceKHR
		hxf27a8c5 := (*sliceHeader)(unsafe.Pointer(&PSurface45c62d4))
		hxf27a8c5.Data = uintptr(unsafe.Pointer(cPSurface))
		hxf27a8c5.Cap = 0x7fffffff
		// hxf27a8c5.Len = ?

		ret45c62d4 := pFNCreateAndroidSurfaceKHR45C62D4Func(Instance45c62d4, PCreateInfo45c62d4, PAllocator45c62d4, PSurface45c62d4)
		ret, _ := (C.VkResult)(ret45c62d4), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateAndroidSurfaceKHR45C62D4Func PFNCreateAndroidSurfaceKHR

// PassRef returns a reference.
func (x PFNDebugReportCallbackEXT) PassRef() (ref *C.PFN_vkDebugReportCallbackEXT, allocs *cgoAllocMap) {
	if pFNDebugReportCallbackEXTC918AAC4Func == nil {
		pFNDebugReportCallbackEXTC918AAC4Func = x
	}
	return (*C.PFN_vkDebugReportCallbackEXT)(C.PFN_vkDebugReportCallbackEXT_c918aac4), nil
}

// PassValue returns a value.
func (x PFNDebugReportCallbackEXT) PassValue() (ref C.PFN_vkDebugReportCallbackEXT, allocs *cgoAllocMap) {
	if pFNDebugReportCallbackEXTC918AAC4Func == nil {
		pFNDebugReportCallbackEXTC918AAC4Func = x
	}
	return (C.PFN_vkDebugReportCallbackEXT)(C.PFN_vkDebugReportCallbackEXT_c918aac4), nil
}

//export pFNDebugReportCallbackEXTC918AAC4
func pFNDebugReportCallbackEXTC918AAC4(cFlags C.VkDebugReportFlagsEXT, cObjectType C.VkDebugReportObjectTypeEXT, cObject C.uint64_t, cLocation C.size_t, cMessageCode C.int32_t, cPLayerPrefix *C.char, cPMessage *C.char, cPUserData unsafe.Pointer) C.VkBool32 {
	if pFNDebugReportCallbackEXTC918AAC4Func != nil {
		Flagsc918aac4 := (DebugReportFlagsEXT)(cFlags)
		ObjectTypec918aac4 := (DebugReportObjectTypeEXT)(cObjectType)
		Objectc918aac4 := (uint64)(cObject)
		Locationc918aac4 := (uint)(cLocation)
		MessageCodec918aac4 := (int32)(cMessageCode)
		PLayerPrefixc918aac4 := packPCharString(cPLayerPrefix)
		PMessagec918aac4 := packPCharString(cPMessage)
		PUserDatac918aac4 := (unsafe.Pointer)(unsafe.Pointer(cPUserData))
		retc918aac4 := pFNDebugReportCallbackEXTC918AAC4Func(Flagsc918aac4, ObjectTypec918aac4, Objectc918aac4, Locationc918aac4, MessageCodec918aac4, PLayerPrefixc918aac4, PMessagec918aac4, PUserDatac918aac4)
		ret, _ := (C.VkBool32)(retc918aac4), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNDebugReportCallbackEXTC918AAC4Func PFNDebugReportCallbackEXT

// allocDebugReportCallbackCreateInfoEXTMemory allocates memory for type C.VkDebugReportCallbackCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugReportCallbackCreateInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugReportCallbackCreateInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugReportCallbackCreateInfoEXTValue = unsafe.Sizeof([1]C.VkDebugReportCallbackCreateInfoEXT{})

// Ref returns a reference.
func (x *DebugReportCallbackCreateInfoEXT) Ref() *C.VkDebugReportCallbackCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refc8238563
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DebugReportCallbackCreateInfoEXT) Free() {
	if x != nil && x.allocsc8238563 != nil {
		x.allocsc8238563.(*cgoAllocMap).Free()
		x.refc8238563 = nil
	}
}

// NewDebugReportCallbackCreateInfoEXTRef initialises a new struct holding the reference to the originaitng C struct.
func NewDebugReportCallbackCreateInfoEXTRef(ref *C.VkDebugReportCallbackCreateInfoEXT) *DebugReportCallbackCreateInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DebugReportCallbackCreateInfoEXT)
	obj.refc8238563 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DebugReportCallbackCreateInfoEXT) PassRef() (*C.VkDebugReportCallbackCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc8238563 != nil {
		return x.refc8238563, nil
	}
	memc8238563 := allocDebugReportCallbackCreateInfoEXTMemory(1)
	refc8238563 := (*C.VkDebugReportCallbackCreateInfoEXT)(memc8238563)
	allocsc8238563 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refc8238563.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc8238563.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc8238563.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc8238563.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc8238563.flags, cflags_allocs = (C.VkDebugReportFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocsc8238563.Borrow(cflags_allocs)

	var cpfnCallback_allocs *cgoAllocMap
	refc8238563.pfnCallback, cpfnCallback_allocs = x.PfnCallback.PassValue()
	allocsc8238563.Borrow(cpfnCallback_allocs)

	var cpUserData_allocs *cgoAllocMap
	refc8238563.pUserData, cpUserData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PUserData)), cgoAllocsUnknown
	allocsc8238563.Borrow(cpUserData_allocs)

	x.refc8238563 = refc8238563
	x.allocsc8238563 = allocsc8238563
	return refc8238563, allocsc8238563

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DebugReportCallbackCreateInfoEXT) PassValue() (C.VkDebugReportCallbackCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		x = NewDebugReportCallbackCreateInfoEXTRef(nil)
	} else if x.refc8238563 != nil {
		return *x.refc8238563, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DebugReportCallbackCreateInfoEXT) Deref() {
	if x.refc8238563 == nil {
		return
	}
	x.SType = (StructureType)(x.refc8238563.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc8238563.pNext))
	x.Flags = (DebugReportFlagsEXT)(x.refc8238563.flags)
	// x.PfnCallback is a callback func
	x.PUserData = (unsafe.Pointer)(unsafe.Pointer(x.refc8238563.pUserData))
}

// packSDebugReportCallbackCreateInfoEXT reads sliced Go data structure out from plain C format.
func packSDebugReportCallbackCreateInfoEXT(v []DebugReportCallbackCreateInfoEXT, ptr0 *C.VkDebugReportCallbackCreateInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDebugReportCallbackCreateInfoEXTValue]C.VkDebugReportCallbackCreateInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDebugReportCallbackCreateInfoEXTRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCreateDebugReportCallbackEXT) PassRef() (ref *C.PFN_vkCreateDebugReportCallbackEXT, allocs *cgoAllocMap) {
	if pFNCreateDebugReportCallbackEXT3F23708FFunc == nil {
		pFNCreateDebugReportCallbackEXT3F23708FFunc = x
	}
	return (*C.PFN_vkCreateDebugReportCallbackEXT)(C.PFN_vkCreateDebugReportCallbackEXT_3f23708f), nil
}

// PassValue returns a value.
func (x PFNCreateDebugReportCallbackEXT) PassValue() (ref C.PFN_vkCreateDebugReportCallbackEXT, allocs *cgoAllocMap) {
	if pFNCreateDebugReportCallbackEXT3F23708FFunc == nil {
		pFNCreateDebugReportCallbackEXT3F23708FFunc = x
	}
	return (C.PFN_vkCreateDebugReportCallbackEXT)(C.PFN_vkCreateDebugReportCallbackEXT_3f23708f), nil
}

//export pFNCreateDebugReportCallbackEXT3F23708F
func pFNCreateDebugReportCallbackEXT3F23708F(cInstance C.VkInstance, cPCreateInfo *C.VkDebugReportCallbackCreateInfoEXT, cPAllocator *C.VkAllocationCallbacks, cPCallback *C.VkDebugReportCallbackEXT) C.VkResult {
	if pFNCreateDebugReportCallbackEXT3F23708FFunc != nil {
		Instance3f23708f := *(*Instance)(unsafe.Pointer(&cInstance))
		var PCreateInfo3f23708f []DebugReportCallbackCreateInfoEXT
		packSDebugReportCallbackCreateInfoEXT(PCreateInfo3f23708f, cPCreateInfo)
		var PAllocator3f23708f []AllocationCallbacks
		packSAllocationCallbacks(PAllocator3f23708f, cPAllocator)
		var PCallback3f23708f []DebugReportCallbackEXT
		hxf349858 := (*sliceHeader)(unsafe.Pointer(&PCallback3f23708f))
		hxf349858.Data = uintptr(unsafe.Pointer(cPCallback))
		hxf349858.Cap = 0x7fffffff
		// hxf349858.Len = ?

		ret3f23708f := pFNCreateDebugReportCallbackEXT3F23708FFunc(Instance3f23708f, PCreateInfo3f23708f, PAllocator3f23708f, PCallback3f23708f)
		ret, _ := (C.VkResult)(ret3f23708f), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNCreateDebugReportCallbackEXT3F23708FFunc PFNCreateDebugReportCallbackEXT

// PassRef returns a reference.
func (x PFNDestroyDebugReportCallbackEXT) PassRef() (ref *C.PFN_vkDestroyDebugReportCallbackEXT, allocs *cgoAllocMap) {
	if pFNDestroyDebugReportCallbackEXT5AB77651Func == nil {
		pFNDestroyDebugReportCallbackEXT5AB77651Func = x
	}
	return (*C.PFN_vkDestroyDebugReportCallbackEXT)(C.PFN_vkDestroyDebugReportCallbackEXT_5ab77651), nil
}

// PassValue returns a value.
func (x PFNDestroyDebugReportCallbackEXT) PassValue() (ref C.PFN_vkDestroyDebugReportCallbackEXT, allocs *cgoAllocMap) {
	if pFNDestroyDebugReportCallbackEXT5AB77651Func == nil {
		pFNDestroyDebugReportCallbackEXT5AB77651Func = x
	}
	return (C.PFN_vkDestroyDebugReportCallbackEXT)(C.PFN_vkDestroyDebugReportCallbackEXT_5ab77651), nil
}

//export pFNDestroyDebugReportCallbackEXT5AB77651
func pFNDestroyDebugReportCallbackEXT5AB77651(cInstance C.VkInstance, cCallback C.VkDebugReportCallbackEXT, cPAllocator *C.VkAllocationCallbacks) {
	if pFNDestroyDebugReportCallbackEXT5AB77651Func != nil {
		Instance5ab77651 := *(*Instance)(unsafe.Pointer(&cInstance))
		Callback5ab77651 := *(*DebugReportCallbackEXT)(unsafe.Pointer(&cCallback))
		var PAllocator5ab77651 []AllocationCallbacks
		packSAllocationCallbacks(PAllocator5ab77651, cPAllocator)
		pFNDestroyDebugReportCallbackEXT5AB77651Func(Instance5ab77651, Callback5ab77651, PAllocator5ab77651)
	}
	panic("callback func has not been set (race?)")
}

var pFNDestroyDebugReportCallbackEXT5AB77651Func PFNDestroyDebugReportCallbackEXT

// PassRef returns a reference.
func (x PFNDebugReportMessageEXT) PassRef() (ref *C.PFN_vkDebugReportMessageEXT, allocs *cgoAllocMap) {
	if pFNDebugReportMessageEXT847E0F11Func == nil {
		pFNDebugReportMessageEXT847E0F11Func = x
	}
	return (*C.PFN_vkDebugReportMessageEXT)(C.PFN_vkDebugReportMessageEXT_847e0f11), nil
}

// PassValue returns a value.
func (x PFNDebugReportMessageEXT) PassValue() (ref C.PFN_vkDebugReportMessageEXT, allocs *cgoAllocMap) {
	if pFNDebugReportMessageEXT847E0F11Func == nil {
		pFNDebugReportMessageEXT847E0F11Func = x
	}
	return (C.PFN_vkDebugReportMessageEXT)(C.PFN_vkDebugReportMessageEXT_847e0f11), nil
}

//export pFNDebugReportMessageEXT847E0F11
func pFNDebugReportMessageEXT847E0F11(cInstance C.VkInstance, cFlags C.VkDebugReportFlagsEXT, cObjectType C.VkDebugReportObjectTypeEXT, cObject C.uint64_t, cLocation C.size_t, cMessageCode C.int32_t, cPLayerPrefix *C.char, cPMessage *C.char) {
	if pFNDebugReportMessageEXT847E0F11Func != nil {
		Instance847e0f11 := *(*Instance)(unsafe.Pointer(&cInstance))
		Flags847e0f11 := (DebugReportFlagsEXT)(cFlags)
		ObjectType847e0f11 := (DebugReportObjectTypeEXT)(cObjectType)
		Object847e0f11 := (uint64)(cObject)
		Location847e0f11 := (uint)(cLocation)
		MessageCode847e0f11 := (int32)(cMessageCode)
		PLayerPrefix847e0f11 := packPCharString(cPLayerPrefix)
		PMessage847e0f11 := packPCharString(cPMessage)
		pFNDebugReportMessageEXT847E0F11Func(Instance847e0f11, Flags847e0f11, ObjectType847e0f11, Object847e0f11, Location847e0f11, MessageCode847e0f11, PLayerPrefix847e0f11, PMessage847e0f11)
	}
	panic("callback func has not been set (race?)")
}

var pFNDebugReportMessageEXT847E0F11Func PFNDebugReportMessageEXT

// allocPipelineRasterizationStateRasterizationOrderAMDMemory allocates memory for type C.VkPipelineRasterizationStateRasterizationOrderAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationStateRasterizationOrderAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationStateRasterizationOrderAMDValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineRasterizationStateRasterizationOrderAMDValue = unsafe.Sizeof([1]C.VkPipelineRasterizationStateRasterizationOrderAMD{})

// Ref returns a reference.
func (x *PipelineRasterizationStateRasterizationOrderAMD) Ref() *C.VkPipelineRasterizationStateRasterizationOrderAMD {
	if x == nil {
		return nil
	}
	return x.ref5098cf82
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineRasterizationStateRasterizationOrderAMD) Free() {
	if x != nil && x.allocs5098cf82 != nil {
		x.allocs5098cf82.(*cgoAllocMap).Free()
		x.ref5098cf82 = nil
	}
}

// NewPipelineRasterizationStateRasterizationOrderAMDRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineRasterizationStateRasterizationOrderAMDRef(ref *C.VkPipelineRasterizationStateRasterizationOrderAMD) *PipelineRasterizationStateRasterizationOrderAMD {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationStateRasterizationOrderAMD)
	obj.ref5098cf82 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineRasterizationStateRasterizationOrderAMD) PassRef() (*C.VkPipelineRasterizationStateRasterizationOrderAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5098cf82 != nil {
		return x.ref5098cf82, nil
	}
	mem5098cf82 := allocPipelineRasterizationStateRasterizationOrderAMDMemory(1)
	ref5098cf82 := (*C.VkPipelineRasterizationStateRasterizationOrderAMD)(mem5098cf82)
	allocs5098cf82 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref5098cf82.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5098cf82.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5098cf82.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5098cf82.Borrow(cpNext_allocs)

	var crasterizationOrder_allocs *cgoAllocMap
	ref5098cf82.rasterizationOrder, crasterizationOrder_allocs = (C.VkRasterizationOrderAMD)(x.RasterizationOrder), cgoAllocsUnknown
	allocs5098cf82.Borrow(crasterizationOrder_allocs)

	x.ref5098cf82 = ref5098cf82
	x.allocs5098cf82 = allocs5098cf82
	return ref5098cf82, allocs5098cf82

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *PipelineRasterizationStateRasterizationOrderAMD) PassValue() (C.VkPipelineRasterizationStateRasterizationOrderAMD, *cgoAllocMap) {
	if x == nil {
		x = NewPipelineRasterizationStateRasterizationOrderAMDRef(nil)
	} else if x.ref5098cf82 != nil {
		return *x.ref5098cf82, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineRasterizationStateRasterizationOrderAMD) Deref() {
	if x.ref5098cf82 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5098cf82.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5098cf82.pNext))
	x.RasterizationOrder = (RasterizationOrderAMD)(x.ref5098cf82.rasterizationOrder)
}

// allocDebugMarkerObjectNameInfoEXTMemory allocates memory for type C.VkDebugMarkerObjectNameInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerObjectNameInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerObjectNameInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugMarkerObjectNameInfoEXTValue = unsafe.Sizeof([1]C.VkDebugMarkerObjectNameInfoEXT{})

// Ref returns a reference.
func (x *DebugMarkerObjectNameInfoEXT) Ref() *C.VkDebugMarkerObjectNameInfoEXT {
	if x == nil {
		return nil
	}
	return x.refe4983fab
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DebugMarkerObjectNameInfoEXT) Free() {
	if x != nil && x.allocse4983fab != nil {
		x.allocse4983fab.(*cgoAllocMap).Free()
		x.refe4983fab = nil
	}
}

// NewDebugMarkerObjectNameInfoEXTRef initialises a new struct holding the reference to the originaitng C struct.
func NewDebugMarkerObjectNameInfoEXTRef(ref *C.VkDebugMarkerObjectNameInfoEXT) *DebugMarkerObjectNameInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DebugMarkerObjectNameInfoEXT)
	obj.refe4983fab = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DebugMarkerObjectNameInfoEXT) PassRef() (*C.VkDebugMarkerObjectNameInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe4983fab != nil {
		return x.refe4983fab, nil
	}
	meme4983fab := allocDebugMarkerObjectNameInfoEXTMemory(1)
	refe4983fab := (*C.VkDebugMarkerObjectNameInfoEXT)(meme4983fab)
	allocse4983fab := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refe4983fab.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse4983fab.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe4983fab.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse4983fab.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	refe4983fab.objectType, cobjectType_allocs = (C.VkDebugReportObjectTypeEXT)(x.ObjectType), cgoAllocsUnknown
	allocse4983fab.Borrow(cobjectType_allocs)

	var cobject_allocs *cgoAllocMap
	refe4983fab.object, cobject_allocs = (C.uint64_t)(x.Object), cgoAllocsUnknown
	allocse4983fab.Borrow(cobject_allocs)

	var cpObjectName_allocs *cgoAllocMap
	refe4983fab.pObjectName, cpObjectName_allocs = unpackPCharString(x.PObjectName)
	allocse4983fab.Borrow(cpObjectName_allocs)

	x.refe4983fab = refe4983fab
	x.allocse4983fab = allocse4983fab
	return refe4983fab, allocse4983fab

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DebugMarkerObjectNameInfoEXT) PassValue() (C.VkDebugMarkerObjectNameInfoEXT, *cgoAllocMap) {
	if x == nil {
		x = NewDebugMarkerObjectNameInfoEXTRef(nil)
	} else if x.refe4983fab != nil {
		return *x.refe4983fab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DebugMarkerObjectNameInfoEXT) Deref() {
	if x.refe4983fab == nil {
		return
	}
	x.SType = (StructureType)(x.refe4983fab.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe4983fab.pNext))
	x.ObjectType = (DebugReportObjectTypeEXT)(x.refe4983fab.objectType)
	x.Object = (uint64)(x.refe4983fab.object)
	x.PObjectName = packPCharString(x.refe4983fab.pObjectName)
}

// allocDebugMarkerObjectTagInfoEXTMemory allocates memory for type C.VkDebugMarkerObjectTagInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerObjectTagInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerObjectTagInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugMarkerObjectTagInfoEXTValue = unsafe.Sizeof([1]C.VkDebugMarkerObjectTagInfoEXT{})

// Ref returns a reference.
func (x *DebugMarkerObjectTagInfoEXT) Ref() *C.VkDebugMarkerObjectTagInfoEXT {
	if x == nil {
		return nil
	}
	return x.refa41a5c3b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DebugMarkerObjectTagInfoEXT) Free() {
	if x != nil && x.allocsa41a5c3b != nil {
		x.allocsa41a5c3b.(*cgoAllocMap).Free()
		x.refa41a5c3b = nil
	}
}

// NewDebugMarkerObjectTagInfoEXTRef initialises a new struct holding the reference to the originaitng C struct.
func NewDebugMarkerObjectTagInfoEXTRef(ref *C.VkDebugMarkerObjectTagInfoEXT) *DebugMarkerObjectTagInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DebugMarkerObjectTagInfoEXT)
	obj.refa41a5c3b = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DebugMarkerObjectTagInfoEXT) PassRef() (*C.VkDebugMarkerObjectTagInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa41a5c3b != nil {
		return x.refa41a5c3b, nil
	}
	mema41a5c3b := allocDebugMarkerObjectTagInfoEXTMemory(1)
	refa41a5c3b := (*C.VkDebugMarkerObjectTagInfoEXT)(mema41a5c3b)
	allocsa41a5c3b := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refa41a5c3b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa41a5c3b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	refa41a5c3b.objectType, cobjectType_allocs = (C.VkDebugReportObjectTypeEXT)(x.ObjectType), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cobjectType_allocs)

	var cobject_allocs *cgoAllocMap
	refa41a5c3b.object, cobject_allocs = (C.uint64_t)(x.Object), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cobject_allocs)

	var ctagName_allocs *cgoAllocMap
	refa41a5c3b.tagName, ctagName_allocs = (C.uint64_t)(x.TagName), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(ctagName_allocs)

	var ctagSize_allocs *cgoAllocMap
	refa41a5c3b.tagSize, ctagSize_allocs = (C.size_t)(x.TagSize), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(ctagSize_allocs)

	var cpTag_allocs *cgoAllocMap
	refa41a5c3b.pTag, cpTag_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PTag)), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cpTag_allocs)

	x.refa41a5c3b = refa41a5c3b
	x.allocsa41a5c3b = allocsa41a5c3b
	return refa41a5c3b, allocsa41a5c3b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DebugMarkerObjectTagInfoEXT) PassValue() (C.VkDebugMarkerObjectTagInfoEXT, *cgoAllocMap) {
	if x == nil {
		x = NewDebugMarkerObjectTagInfoEXTRef(nil)
	} else if x.refa41a5c3b != nil {
		return *x.refa41a5c3b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DebugMarkerObjectTagInfoEXT) Deref() {
	if x.refa41a5c3b == nil {
		return
	}
	x.SType = (StructureType)(x.refa41a5c3b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa41a5c3b.pNext))
	x.ObjectType = (DebugReportObjectTypeEXT)(x.refa41a5c3b.objectType)
	x.Object = (uint64)(x.refa41a5c3b.object)
	x.TagName = (uint64)(x.refa41a5c3b.tagName)
	x.TagSize = (uint)(x.refa41a5c3b.tagSize)
	x.PTag = (unsafe.Pointer)(unsafe.Pointer(x.refa41a5c3b.pTag))
}

// allocDebugMarkerMarkerInfoEXTMemory allocates memory for type C.VkDebugMarkerMarkerInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerMarkerInfoEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerMarkerInfoEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugMarkerMarkerInfoEXTValue = unsafe.Sizeof([1]C.VkDebugMarkerMarkerInfoEXT{})

// Ref returns a reference.
func (x *DebugMarkerMarkerInfoEXT) Ref() *C.VkDebugMarkerMarkerInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref234b91fd
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DebugMarkerMarkerInfoEXT) Free() {
	if x != nil && x.allocs234b91fd != nil {
		x.allocs234b91fd.(*cgoAllocMap).Free()
		x.ref234b91fd = nil
	}
}

// NewDebugMarkerMarkerInfoEXTRef initialises a new struct holding the reference to the originaitng C struct.
func NewDebugMarkerMarkerInfoEXTRef(ref *C.VkDebugMarkerMarkerInfoEXT) *DebugMarkerMarkerInfoEXT {
	if ref == nil {
		return nil
	}
	obj := new(DebugMarkerMarkerInfoEXT)
	obj.ref234b91fd = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DebugMarkerMarkerInfoEXT) PassRef() (*C.VkDebugMarkerMarkerInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref234b91fd != nil {
		return x.ref234b91fd, nil
	}
	mem234b91fd := allocDebugMarkerMarkerInfoEXTMemory(1)
	ref234b91fd := (*C.VkDebugMarkerMarkerInfoEXT)(mem234b91fd)
	allocs234b91fd := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref234b91fd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs234b91fd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref234b91fd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs234b91fd.Borrow(cpNext_allocs)

	var cpMarkerName_allocs *cgoAllocMap
	ref234b91fd.pMarkerName, cpMarkerName_allocs = unpackPCharString(x.PMarkerName)
	allocs234b91fd.Borrow(cpMarkerName_allocs)

	var ccolor_allocs *cgoAllocMap
	ref234b91fd.color, ccolor_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Color)), cgoAllocsUnknown
	allocs234b91fd.Borrow(ccolor_allocs)

	x.ref234b91fd = ref234b91fd
	x.allocs234b91fd = allocs234b91fd
	return ref234b91fd, allocs234b91fd

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DebugMarkerMarkerInfoEXT) PassValue() (C.VkDebugMarkerMarkerInfoEXT, *cgoAllocMap) {
	if x == nil {
		x = NewDebugMarkerMarkerInfoEXTRef(nil)
	} else if x.ref234b91fd != nil {
		return *x.ref234b91fd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DebugMarkerMarkerInfoEXT) Deref() {
	if x.ref234b91fd == nil {
		return
	}
	x.SType = (StructureType)(x.ref234b91fd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref234b91fd.pNext))
	x.PMarkerName = packPCharString(x.ref234b91fd.pMarkerName)
	x.Color = *(*[4]float32)(unsafe.Pointer(&x.ref234b91fd.color))
}

// packSDebugMarkerObjectTagInfoEXT reads sliced Go data structure out from plain C format.
func packSDebugMarkerObjectTagInfoEXT(v []DebugMarkerObjectTagInfoEXT, ptr0 *C.VkDebugMarkerObjectTagInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDebugMarkerObjectTagInfoEXTValue]C.VkDebugMarkerObjectTagInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDebugMarkerObjectTagInfoEXTRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNDebugMarkerSetObjectTagEXT) PassRef() (ref *C.PFN_vkDebugMarkerSetObjectTagEXT, allocs *cgoAllocMap) {
	if pFNDebugMarkerSetObjectTagEXT64DCD960Func == nil {
		pFNDebugMarkerSetObjectTagEXT64DCD960Func = x
	}
	return (*C.PFN_vkDebugMarkerSetObjectTagEXT)(C.PFN_vkDebugMarkerSetObjectTagEXT_64dcd960), nil
}

// PassValue returns a value.
func (x PFNDebugMarkerSetObjectTagEXT) PassValue() (ref C.PFN_vkDebugMarkerSetObjectTagEXT, allocs *cgoAllocMap) {
	if pFNDebugMarkerSetObjectTagEXT64DCD960Func == nil {
		pFNDebugMarkerSetObjectTagEXT64DCD960Func = x
	}
	return (C.PFN_vkDebugMarkerSetObjectTagEXT)(C.PFN_vkDebugMarkerSetObjectTagEXT_64dcd960), nil
}

//export pFNDebugMarkerSetObjectTagEXT64DCD960
func pFNDebugMarkerSetObjectTagEXT64DCD960(cDevice C.VkDevice, cPTagInfo *C.VkDebugMarkerObjectTagInfoEXT) C.VkResult {
	if pFNDebugMarkerSetObjectTagEXT64DCD960Func != nil {
		Device64dcd960 := *(*Device)(unsafe.Pointer(&cDevice))
		var PTagInfo64dcd960 []DebugMarkerObjectTagInfoEXT
		packSDebugMarkerObjectTagInfoEXT(PTagInfo64dcd960, cPTagInfo)
		ret64dcd960 := pFNDebugMarkerSetObjectTagEXT64DCD960Func(Device64dcd960, PTagInfo64dcd960)
		ret, _ := (C.VkResult)(ret64dcd960), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNDebugMarkerSetObjectTagEXT64DCD960Func PFNDebugMarkerSetObjectTagEXT

// packSDebugMarkerObjectNameInfoEXT reads sliced Go data structure out from plain C format.
func packSDebugMarkerObjectNameInfoEXT(v []DebugMarkerObjectNameInfoEXT, ptr0 *C.VkDebugMarkerObjectNameInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDebugMarkerObjectNameInfoEXTValue]C.VkDebugMarkerObjectNameInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDebugMarkerObjectNameInfoEXTRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNDebugMarkerSetObjectNameEXT) PassRef() (ref *C.PFN_vkDebugMarkerSetObjectNameEXT, allocs *cgoAllocMap) {
	if pFNDebugMarkerSetObjectNameEXT62B5CCD1Func == nil {
		pFNDebugMarkerSetObjectNameEXT62B5CCD1Func = x
	}
	return (*C.PFN_vkDebugMarkerSetObjectNameEXT)(C.PFN_vkDebugMarkerSetObjectNameEXT_62b5ccd1), nil
}

// PassValue returns a value.
func (x PFNDebugMarkerSetObjectNameEXT) PassValue() (ref C.PFN_vkDebugMarkerSetObjectNameEXT, allocs *cgoAllocMap) {
	if pFNDebugMarkerSetObjectNameEXT62B5CCD1Func == nil {
		pFNDebugMarkerSetObjectNameEXT62B5CCD1Func = x
	}
	return (C.PFN_vkDebugMarkerSetObjectNameEXT)(C.PFN_vkDebugMarkerSetObjectNameEXT_62b5ccd1), nil
}

//export pFNDebugMarkerSetObjectNameEXT62B5CCD1
func pFNDebugMarkerSetObjectNameEXT62B5CCD1(cDevice C.VkDevice, cPNameInfo *C.VkDebugMarkerObjectNameInfoEXT) C.VkResult {
	if pFNDebugMarkerSetObjectNameEXT62B5CCD1Func != nil {
		Device62b5ccd1 := *(*Device)(unsafe.Pointer(&cDevice))
		var PNameInfo62b5ccd1 []DebugMarkerObjectNameInfoEXT
		packSDebugMarkerObjectNameInfoEXT(PNameInfo62b5ccd1, cPNameInfo)
		ret62b5ccd1 := pFNDebugMarkerSetObjectNameEXT62B5CCD1Func(Device62b5ccd1, PNameInfo62b5ccd1)
		ret, _ := (C.VkResult)(ret62b5ccd1), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pFNDebugMarkerSetObjectNameEXT62B5CCD1Func PFNDebugMarkerSetObjectNameEXT

// packSDebugMarkerMarkerInfoEXT reads sliced Go data structure out from plain C format.
func packSDebugMarkerMarkerInfoEXT(v []DebugMarkerMarkerInfoEXT, ptr0 *C.VkDebugMarkerMarkerInfoEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDebugMarkerMarkerInfoEXTValue]C.VkDebugMarkerMarkerInfoEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDebugMarkerMarkerInfoEXTRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x PFNCmdDebugMarkerBeginEXT) PassRef() (ref *C.PFN_vkCmdDebugMarkerBeginEXT, allocs *cgoAllocMap) {
	if pFNCmdDebugMarkerBeginEXTF3766240Func == nil {
		pFNCmdDebugMarkerBeginEXTF3766240Func = x
	}
	return (*C.PFN_vkCmdDebugMarkerBeginEXT)(C.PFN_vkCmdDebugMarkerBeginEXT_f3766240), nil
}

// PassValue returns a value.
func (x PFNCmdDebugMarkerBeginEXT) PassValue() (ref C.PFN_vkCmdDebugMarkerBeginEXT, allocs *cgoAllocMap) {
	if pFNCmdDebugMarkerBeginEXTF3766240Func == nil {
		pFNCmdDebugMarkerBeginEXTF3766240Func = x
	}
	return (C.PFN_vkCmdDebugMarkerBeginEXT)(C.PFN_vkCmdDebugMarkerBeginEXT_f3766240), nil
}

//export pFNCmdDebugMarkerBeginEXTF3766240
func pFNCmdDebugMarkerBeginEXTF3766240(cCommandBuffer C.VkCommandBuffer, cPMarkerInfo *C.VkDebugMarkerMarkerInfoEXT) {
	if pFNCmdDebugMarkerBeginEXTF3766240Func != nil {
		CommandBufferf3766240 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		var PMarkerInfof3766240 []DebugMarkerMarkerInfoEXT
		packSDebugMarkerMarkerInfoEXT(PMarkerInfof3766240, cPMarkerInfo)
		pFNCmdDebugMarkerBeginEXTF3766240Func(CommandBufferf3766240, PMarkerInfof3766240)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdDebugMarkerBeginEXTF3766240Func PFNCmdDebugMarkerBeginEXT

// PassRef returns a reference.
func (x PFNCmdDebugMarkerEndEXT) PassRef() (ref *C.PFN_vkCmdDebugMarkerEndEXT, allocs *cgoAllocMap) {
	if pFNCmdDebugMarkerEndEXT66E51D45Func == nil {
		pFNCmdDebugMarkerEndEXT66E51D45Func = x
	}
	return (*C.PFN_vkCmdDebugMarkerEndEXT)(C.PFN_vkCmdDebugMarkerEndEXT_66e51d45), nil
}

// PassValue returns a value.
func (x PFNCmdDebugMarkerEndEXT) PassValue() (ref C.PFN_vkCmdDebugMarkerEndEXT, allocs *cgoAllocMap) {
	if pFNCmdDebugMarkerEndEXT66E51D45Func == nil {
		pFNCmdDebugMarkerEndEXT66E51D45Func = x
	}
	return (C.PFN_vkCmdDebugMarkerEndEXT)(C.PFN_vkCmdDebugMarkerEndEXT_66e51d45), nil
}

//export pFNCmdDebugMarkerEndEXT66E51D45
func pFNCmdDebugMarkerEndEXT66E51D45(cCommandBuffer C.VkCommandBuffer) {
	if pFNCmdDebugMarkerEndEXT66E51D45Func != nil {
		CommandBuffer66e51d45 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		pFNCmdDebugMarkerEndEXT66E51D45Func(CommandBuffer66e51d45)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdDebugMarkerEndEXT66E51D45Func PFNCmdDebugMarkerEndEXT

// PassRef returns a reference.
func (x PFNCmdDebugMarkerInsertEXT) PassRef() (ref *C.PFN_vkCmdDebugMarkerInsertEXT, allocs *cgoAllocMap) {
	if pFNCmdDebugMarkerInsertEXTA68B2DD7Func == nil {
		pFNCmdDebugMarkerInsertEXTA68B2DD7Func = x
	}
	return (*C.PFN_vkCmdDebugMarkerInsertEXT)(C.PFN_vkCmdDebugMarkerInsertEXT_a68b2dd7), nil
}

// PassValue returns a value.
func (x PFNCmdDebugMarkerInsertEXT) PassValue() (ref C.PFN_vkCmdDebugMarkerInsertEXT, allocs *cgoAllocMap) {
	if pFNCmdDebugMarkerInsertEXTA68B2DD7Func == nil {
		pFNCmdDebugMarkerInsertEXTA68B2DD7Func = x
	}
	return (C.PFN_vkCmdDebugMarkerInsertEXT)(C.PFN_vkCmdDebugMarkerInsertEXT_a68b2dd7), nil
}

//export pFNCmdDebugMarkerInsertEXTA68B2DD7
func pFNCmdDebugMarkerInsertEXTA68B2DD7(cCommandBuffer C.VkCommandBuffer, cPMarkerInfo *C.VkDebugMarkerMarkerInfoEXT) {
	if pFNCmdDebugMarkerInsertEXTA68B2DD7Func != nil {
		CommandBuffera68b2dd7 := *(*CommandBuffer)(unsafe.Pointer(&cCommandBuffer))
		var PMarkerInfoa68b2dd7 []DebugMarkerMarkerInfoEXT
		packSDebugMarkerMarkerInfoEXT(PMarkerInfoa68b2dd7, cPMarkerInfo)
		pFNCmdDebugMarkerInsertEXTA68B2DD7Func(CommandBuffera68b2dd7, PMarkerInfoa68b2dd7)
	}
	panic("callback func has not been set (race?)")
}

var pFNCmdDebugMarkerInsertEXTA68B2DD7Func PFNCmdDebugMarkerInsertEXT
