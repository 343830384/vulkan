// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Sat, 13 Aug 2016 12:04:11 MSK.
// By http://git.io/cgogen. DO NOT EDIT.

package vulkan

/*
#cgo CFLAGS: -I. -DVK_NO_PROTOTYPES -DVK_USE_PLATFORM_ANDROID_KHR
#cgo android LDFLAGS: -Wl,--no-warn-mismatch -lm_hard
#cgo android CFLAGS: -D__ARM_ARCH_7A__ -D_NDK_MATH_NO_SOFTFP=1 -mfpu=vfp -mfloat-abi=hard -march=armv7-a
#include "vulkan/vulkan.h"
#include "vulkan_wrapper.h"
#include "vulkan_bridge.h"
#include "android/native_window.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocApplicationInfoMemory allocates memory for type C.VkApplicationInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocApplicationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfApplicationInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfApplicationInfoValue = unsafe.Sizeof([1]C.VkApplicationInfo{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

// Ref returns a reference.
func (x *ApplicationInfo) Ref() *C.VkApplicationInfo {
	if x == nil {
		return nil
	}
	return x.refb0af7378
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ApplicationInfo) Free() {
	if x != nil && x.allocsb0af7378 != nil {
		x.allocsb0af7378.(*cgoAllocMap).Free()
		x.refb0af7378 = nil
	}
}

// NewApplicationInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewApplicationInfoRef(ref interface{}) *ApplicationInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ApplicationInfo)
	obj.refb0af7378 = (*C.VkApplicationInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ApplicationInfo) PassRef() (*C.VkApplicationInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0af7378 != nil {
		return x.refb0af7378, nil
	}
	memb0af7378 := allocApplicationInfoMemory(1)
	refb0af7378 := (*C.VkApplicationInfo)(memb0af7378)
	allocsb0af7378 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refb0af7378.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb0af7378.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb0af7378.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb0af7378.Borrow(cpNext_allocs)

	var cpApplicationName_allocs *cgoAllocMap
	refb0af7378.pApplicationName, cpApplicationName_allocs = unpackPCharString(x.PApplicationName)
	allocsb0af7378.Borrow(cpApplicationName_allocs)

	var capplicationVersion_allocs *cgoAllocMap
	refb0af7378.applicationVersion, capplicationVersion_allocs = (C.uint32_t)(x.ApplicationVersion), cgoAllocsUnknown
	allocsb0af7378.Borrow(capplicationVersion_allocs)

	var cpEngineName_allocs *cgoAllocMap
	refb0af7378.pEngineName, cpEngineName_allocs = unpackPCharString(x.PEngineName)
	allocsb0af7378.Borrow(cpEngineName_allocs)

	var cengineVersion_allocs *cgoAllocMap
	refb0af7378.engineVersion, cengineVersion_allocs = (C.uint32_t)(x.EngineVersion), cgoAllocsUnknown
	allocsb0af7378.Borrow(cengineVersion_allocs)

	var capiVersion_allocs *cgoAllocMap
	refb0af7378.apiVersion, capiVersion_allocs = (C.uint32_t)(x.ApiVersion), cgoAllocsUnknown
	allocsb0af7378.Borrow(capiVersion_allocs)

	x.refb0af7378 = refb0af7378
	x.allocsb0af7378 = allocsb0af7378
	return refb0af7378, allocsb0af7378

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ApplicationInfo) PassValue() (C.VkApplicationInfo, *cgoAllocMap) {
	if x.refb0af7378 != nil {
		return *x.refb0af7378, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ApplicationInfo) Deref() {
	if x.refb0af7378 == nil {
		return
	}
	x.SType = (StructureType)(x.refb0af7378.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb0af7378.pNext))
	x.PApplicationName = packPCharString(x.refb0af7378.pApplicationName)
	x.ApplicationVersion = (uint32)(x.refb0af7378.applicationVersion)
	x.PEngineName = packPCharString(x.refb0af7378.pEngineName)
	x.EngineVersion = (uint32)(x.refb0af7378.engineVersion)
	x.ApiVersion = (uint32)(x.refb0af7378.apiVersion)
}

// allocInstanceCreateInfoMemory allocates memory for type C.VkInstanceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInstanceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInstanceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfInstanceCreateInfoValue = unsafe.Sizeof([1]C.VkInstanceCreateInfo{})

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(unsafe.Pointer(h.Data))
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// Ref returns a reference.
func (x *InstanceCreateInfo) Ref() *C.VkInstanceCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref9b760798
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *InstanceCreateInfo) Free() {
	if x != nil && x.allocs9b760798 != nil {
		x.allocs9b760798.(*cgoAllocMap).Free()
		x.ref9b760798 = nil
	}
}

// NewInstanceCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewInstanceCreateInfoRef(ref interface{}) *InstanceCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(InstanceCreateInfo)
	obj.ref9b760798 = (*C.VkInstanceCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *InstanceCreateInfo) PassRef() (*C.VkInstanceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9b760798 != nil {
		return x.ref9b760798, nil
	}
	mem9b760798 := allocInstanceCreateInfoMemory(1)
	ref9b760798 := (*C.VkInstanceCreateInfo)(mem9b760798)
	allocs9b760798 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref9b760798.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9b760798.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9b760798.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9b760798.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref9b760798.flags, cflags_allocs = (C.VkInstanceCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs9b760798.Borrow(cflags_allocs)

	var cpApplicationInfo_allocs *cgoAllocMap
	ref9b760798.pApplicationInfo, cpApplicationInfo_allocs = x.PApplicationInfo.PassRef()
	allocs9b760798.Borrow(cpApplicationInfo_allocs)

	var cenabledLayerCount_allocs *cgoAllocMap
	ref9b760798.enabledLayerCount, cenabledLayerCount_allocs = (C.uint32_t)(x.EnabledLayerCount), cgoAllocsUnknown
	allocs9b760798.Borrow(cenabledLayerCount_allocs)

	var cppEnabledLayerNames_allocs *cgoAllocMap
	ref9b760798.ppEnabledLayerNames, cppEnabledLayerNames_allocs = unpackSString(x.PpEnabledLayerNames)
	allocs9b760798.Borrow(cppEnabledLayerNames_allocs)

	var cenabledExtensionCount_allocs *cgoAllocMap
	ref9b760798.enabledExtensionCount, cenabledExtensionCount_allocs = (C.uint32_t)(x.EnabledExtensionCount), cgoAllocsUnknown
	allocs9b760798.Borrow(cenabledExtensionCount_allocs)

	var cppEnabledExtensionNames_allocs *cgoAllocMap
	ref9b760798.ppEnabledExtensionNames, cppEnabledExtensionNames_allocs = unpackSString(x.PpEnabledExtensionNames)
	allocs9b760798.Borrow(cppEnabledExtensionNames_allocs)

	x.ref9b760798 = ref9b760798
	x.allocs9b760798 = allocs9b760798
	return ref9b760798, allocs9b760798

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x InstanceCreateInfo) PassValue() (C.VkInstanceCreateInfo, *cgoAllocMap) {
	if x.ref9b760798 != nil {
		return *x.ref9b760798, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *InstanceCreateInfo) Deref() {
	if x.ref9b760798 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9b760798.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9b760798.pNext))
	x.Flags = (InstanceCreateFlags)(x.ref9b760798.flags)
	x.PApplicationInfo = NewApplicationInfoRef(x.ref9b760798.pApplicationInfo)
	x.EnabledLayerCount = (uint32)(x.ref9b760798.enabledLayerCount)
	packSString(x.PpEnabledLayerNames, x.ref9b760798.ppEnabledLayerNames)
	x.EnabledExtensionCount = (uint32)(x.ref9b760798.enabledExtensionCount)
	packSString(x.PpEnabledExtensionNames, x.ref9b760798.ppEnabledExtensionNames)
}

// Ref returns a reference.
func (x *AllocationCallbacks) Ref() *C.VkAllocationCallbacks {
	if x == nil {
		return nil
	}
	return (*C.VkAllocationCallbacks)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *AllocationCallbacks) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewAllocationCallbacksRef initialises a new struct.
func NewAllocationCallbacksRef(ref *C.VkAllocationCallbacks) *AllocationCallbacks {
	return (*AllocationCallbacks)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *AllocationCallbacks) PassRef() *C.VkAllocationCallbacks {
	if x == nil {
		x = new(AllocationCallbacks)
	}
	return (*C.VkAllocationCallbacks)(unsafe.Pointer(x))
}

// allocPhysicalDeviceFeaturesMemory allocates memory for type C.VkPhysicalDeviceFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFeatures{})

// Ref returns a reference.
func (x *PhysicalDeviceFeatures) Ref() *C.VkPhysicalDeviceFeatures {
	if x == nil {
		return nil
	}
	return x.reff97e405d
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PhysicalDeviceFeatures) Free() {
	if x != nil && x.allocsf97e405d != nil {
		x.allocsf97e405d.(*cgoAllocMap).Free()
		x.reff97e405d = nil
	}
}

// NewPhysicalDeviceFeaturesRef initialises a new struct holding the reference to the originaitng C struct.
func NewPhysicalDeviceFeaturesRef(ref interface{}) *PhysicalDeviceFeatures {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PhysicalDeviceFeatures)
	obj.reff97e405d = (*C.VkPhysicalDeviceFeatures)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PhysicalDeviceFeatures) PassRef() (*C.VkPhysicalDeviceFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff97e405d != nil {
		return x.reff97e405d, nil
	}
	memf97e405d := allocPhysicalDeviceFeaturesMemory(1)
	reff97e405d := (*C.VkPhysicalDeviceFeatures)(memf97e405d)
	allocsf97e405d := new(cgoAllocMap)
	var crobustBufferAccess_allocs *cgoAllocMap
	reff97e405d.robustBufferAccess, crobustBufferAccess_allocs = (C.VkBool32)(x.RobustBufferAccess), cgoAllocsUnknown
	allocsf97e405d.Borrow(crobustBufferAccess_allocs)

	var cfullDrawIndexUint32_allocs *cgoAllocMap
	reff97e405d.fullDrawIndexUint32, cfullDrawIndexUint32_allocs = (C.VkBool32)(x.FullDrawIndexUint32), cgoAllocsUnknown
	allocsf97e405d.Borrow(cfullDrawIndexUint32_allocs)

	var cimageCubeArray_allocs *cgoAllocMap
	reff97e405d.imageCubeArray, cimageCubeArray_allocs = (C.VkBool32)(x.ImageCubeArray), cgoAllocsUnknown
	allocsf97e405d.Borrow(cimageCubeArray_allocs)

	var cindependentBlend_allocs *cgoAllocMap
	reff97e405d.independentBlend, cindependentBlend_allocs = (C.VkBool32)(x.IndependentBlend), cgoAllocsUnknown
	allocsf97e405d.Borrow(cindependentBlend_allocs)

	var cgeometryShader_allocs *cgoAllocMap
	reff97e405d.geometryShader, cgeometryShader_allocs = (C.VkBool32)(x.GeometryShader), cgoAllocsUnknown
	allocsf97e405d.Borrow(cgeometryShader_allocs)

	var ctessellationShader_allocs *cgoAllocMap
	reff97e405d.tessellationShader, ctessellationShader_allocs = (C.VkBool32)(x.TessellationShader), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctessellationShader_allocs)

	var csampleRateShading_allocs *cgoAllocMap
	reff97e405d.sampleRateShading, csampleRateShading_allocs = (C.VkBool32)(x.SampleRateShading), cgoAllocsUnknown
	allocsf97e405d.Borrow(csampleRateShading_allocs)

	var cdualSrcBlend_allocs *cgoAllocMap
	reff97e405d.dualSrcBlend, cdualSrcBlend_allocs = (C.VkBool32)(x.DualSrcBlend), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdualSrcBlend_allocs)

	var clogicOp_allocs *cgoAllocMap
	reff97e405d.logicOp, clogicOp_allocs = (C.VkBool32)(x.LogicOp), cgoAllocsUnknown
	allocsf97e405d.Borrow(clogicOp_allocs)

	var cmultiDrawIndirect_allocs *cgoAllocMap
	reff97e405d.multiDrawIndirect, cmultiDrawIndirect_allocs = (C.VkBool32)(x.MultiDrawIndirect), cgoAllocsUnknown
	allocsf97e405d.Borrow(cmultiDrawIndirect_allocs)

	var cdrawIndirectFirstInstance_allocs *cgoAllocMap
	reff97e405d.drawIndirectFirstInstance, cdrawIndirectFirstInstance_allocs = (C.VkBool32)(x.DrawIndirectFirstInstance), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdrawIndirectFirstInstance_allocs)

	var cdepthClamp_allocs *cgoAllocMap
	reff97e405d.depthClamp, cdepthClamp_allocs = (C.VkBool32)(x.DepthClamp), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdepthClamp_allocs)

	var cdepthBiasClamp_allocs *cgoAllocMap
	reff97e405d.depthBiasClamp, cdepthBiasClamp_allocs = (C.VkBool32)(x.DepthBiasClamp), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdepthBiasClamp_allocs)

	var cfillModeNonSolid_allocs *cgoAllocMap
	reff97e405d.fillModeNonSolid, cfillModeNonSolid_allocs = (C.VkBool32)(x.FillModeNonSolid), cgoAllocsUnknown
	allocsf97e405d.Borrow(cfillModeNonSolid_allocs)

	var cdepthBounds_allocs *cgoAllocMap
	reff97e405d.depthBounds, cdepthBounds_allocs = (C.VkBool32)(x.DepthBounds), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdepthBounds_allocs)

	var cwideLines_allocs *cgoAllocMap
	reff97e405d.wideLines, cwideLines_allocs = (C.VkBool32)(x.WideLines), cgoAllocsUnknown
	allocsf97e405d.Borrow(cwideLines_allocs)

	var clargePoints_allocs *cgoAllocMap
	reff97e405d.largePoints, clargePoints_allocs = (C.VkBool32)(x.LargePoints), cgoAllocsUnknown
	allocsf97e405d.Borrow(clargePoints_allocs)

	var calphaToOne_allocs *cgoAllocMap
	reff97e405d.alphaToOne, calphaToOne_allocs = (C.VkBool32)(x.AlphaToOne), cgoAllocsUnknown
	allocsf97e405d.Borrow(calphaToOne_allocs)

	var cmultiViewport_allocs *cgoAllocMap
	reff97e405d.multiViewport, cmultiViewport_allocs = (C.VkBool32)(x.MultiViewport), cgoAllocsUnknown
	allocsf97e405d.Borrow(cmultiViewport_allocs)

	var csamplerAnisotropy_allocs *cgoAllocMap
	reff97e405d.samplerAnisotropy, csamplerAnisotropy_allocs = (C.VkBool32)(x.SamplerAnisotropy), cgoAllocsUnknown
	allocsf97e405d.Borrow(csamplerAnisotropy_allocs)

	var ctextureCompressionETC2_allocs *cgoAllocMap
	reff97e405d.textureCompressionETC2, ctextureCompressionETC2_allocs = (C.VkBool32)(x.TextureCompressionETC2), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctextureCompressionETC2_allocs)

	var ctextureCompressionASTC_LDR_allocs *cgoAllocMap
	reff97e405d.textureCompressionASTC_LDR, ctextureCompressionASTC_LDR_allocs = (C.VkBool32)(x.TextureCompressionASTC_LDR), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctextureCompressionASTC_LDR_allocs)

	var ctextureCompressionBC_allocs *cgoAllocMap
	reff97e405d.textureCompressionBC, ctextureCompressionBC_allocs = (C.VkBool32)(x.TextureCompressionBC), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctextureCompressionBC_allocs)

	var cocclusionQueryPrecise_allocs *cgoAllocMap
	reff97e405d.occlusionQueryPrecise, cocclusionQueryPrecise_allocs = (C.VkBool32)(x.OcclusionQueryPrecise), cgoAllocsUnknown
	allocsf97e405d.Borrow(cocclusionQueryPrecise_allocs)

	var cpipelineStatisticsQuery_allocs *cgoAllocMap
	reff97e405d.pipelineStatisticsQuery, cpipelineStatisticsQuery_allocs = (C.VkBool32)(x.PipelineStatisticsQuery), cgoAllocsUnknown
	allocsf97e405d.Borrow(cpipelineStatisticsQuery_allocs)

	var cvertexPipelineStoresAndAtomics_allocs *cgoAllocMap
	reff97e405d.vertexPipelineStoresAndAtomics, cvertexPipelineStoresAndAtomics_allocs = (C.VkBool32)(x.VertexPipelineStoresAndAtomics), cgoAllocsUnknown
	allocsf97e405d.Borrow(cvertexPipelineStoresAndAtomics_allocs)

	var cfragmentStoresAndAtomics_allocs *cgoAllocMap
	reff97e405d.fragmentStoresAndAtomics, cfragmentStoresAndAtomics_allocs = (C.VkBool32)(x.FragmentStoresAndAtomics), cgoAllocsUnknown
	allocsf97e405d.Borrow(cfragmentStoresAndAtomics_allocs)

	var cshaderTessellationAndGeometryPointSize_allocs *cgoAllocMap
	reff97e405d.shaderTessellationAndGeometryPointSize, cshaderTessellationAndGeometryPointSize_allocs = (C.VkBool32)(x.ShaderTessellationAndGeometryPointSize), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderTessellationAndGeometryPointSize_allocs)

	var cshaderImageGatherExtended_allocs *cgoAllocMap
	reff97e405d.shaderImageGatherExtended, cshaderImageGatherExtended_allocs = (C.VkBool32)(x.ShaderImageGatherExtended), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderImageGatherExtended_allocs)

	var cshaderStorageImageExtendedFormats_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageExtendedFormats, cshaderStorageImageExtendedFormats_allocs = (C.VkBool32)(x.ShaderStorageImageExtendedFormats), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageExtendedFormats_allocs)

	var cshaderStorageImageMultisample_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageMultisample, cshaderStorageImageMultisample_allocs = (C.VkBool32)(x.ShaderStorageImageMultisample), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageMultisample_allocs)

	var cshaderStorageImageReadWithoutFormat_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageReadWithoutFormat, cshaderStorageImageReadWithoutFormat_allocs = (C.VkBool32)(x.ShaderStorageImageReadWithoutFormat), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageReadWithoutFormat_allocs)

	var cshaderStorageImageWriteWithoutFormat_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageWriteWithoutFormat, cshaderStorageImageWriteWithoutFormat_allocs = (C.VkBool32)(x.ShaderStorageImageWriteWithoutFormat), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageWriteWithoutFormat_allocs)

	var cshaderUniformBufferArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderUniformBufferArrayDynamicIndexing, cshaderUniformBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderUniformBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderUniformBufferArrayDynamicIndexing_allocs)

	var cshaderSampledImageArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderSampledImageArrayDynamicIndexing, cshaderSampledImageArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderSampledImageArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderSampledImageArrayDynamicIndexing_allocs)

	var cshaderStorageBufferArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderStorageBufferArrayDynamicIndexing, cshaderStorageBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderStorageBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageBufferArrayDynamicIndexing_allocs)

	var cshaderStorageImageArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageArrayDynamicIndexing, cshaderStorageImageArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderStorageImageArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageArrayDynamicIndexing_allocs)

	var cshaderClipDistance_allocs *cgoAllocMap
	reff97e405d.shaderClipDistance, cshaderClipDistance_allocs = (C.VkBool32)(x.ShaderClipDistance), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderClipDistance_allocs)

	var cshaderCullDistance_allocs *cgoAllocMap
	reff97e405d.shaderCullDistance, cshaderCullDistance_allocs = (C.VkBool32)(x.ShaderCullDistance), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderCullDistance_allocs)

	var cshaderFloat64_allocs *cgoAllocMap
	reff97e405d.shaderFloat64, cshaderFloat64_allocs = (C.VkBool32)(x.ShaderFloat64), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderFloat64_allocs)

	var cshaderInt64_allocs *cgoAllocMap
	reff97e405d.shaderInt64, cshaderInt64_allocs = (C.VkBool32)(x.ShaderInt64), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderInt64_allocs)

	var cshaderInt16_allocs *cgoAllocMap
	reff97e405d.shaderInt16, cshaderInt16_allocs = (C.VkBool32)(x.ShaderInt16), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderInt16_allocs)

	var cshaderResourceResidency_allocs *cgoAllocMap
	reff97e405d.shaderResourceResidency, cshaderResourceResidency_allocs = (C.VkBool32)(x.ShaderResourceResidency), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderResourceResidency_allocs)

	var cshaderResourceMinLod_allocs *cgoAllocMap
	reff97e405d.shaderResourceMinLod, cshaderResourceMinLod_allocs = (C.VkBool32)(x.ShaderResourceMinLod), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderResourceMinLod_allocs)

	var csparseBinding_allocs *cgoAllocMap
	reff97e405d.sparseBinding, csparseBinding_allocs = (C.VkBool32)(x.SparseBinding), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseBinding_allocs)

	var csparseResidencyBuffer_allocs *cgoAllocMap
	reff97e405d.sparseResidencyBuffer, csparseResidencyBuffer_allocs = (C.VkBool32)(x.SparseResidencyBuffer), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyBuffer_allocs)

	var csparseResidencyImage2D_allocs *cgoAllocMap
	reff97e405d.sparseResidencyImage2D, csparseResidencyImage2D_allocs = (C.VkBool32)(x.SparseResidencyImage2D), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyImage2D_allocs)

	var csparseResidencyImage3D_allocs *cgoAllocMap
	reff97e405d.sparseResidencyImage3D, csparseResidencyImage3D_allocs = (C.VkBool32)(x.SparseResidencyImage3D), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyImage3D_allocs)

	var csparseResidency2Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency2Samples, csparseResidency2Samples_allocs = (C.VkBool32)(x.SparseResidency2Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency2Samples_allocs)

	var csparseResidency4Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency4Samples, csparseResidency4Samples_allocs = (C.VkBool32)(x.SparseResidency4Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency4Samples_allocs)

	var csparseResidency8Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency8Samples, csparseResidency8Samples_allocs = (C.VkBool32)(x.SparseResidency8Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency8Samples_allocs)

	var csparseResidency16Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency16Samples, csparseResidency16Samples_allocs = (C.VkBool32)(x.SparseResidency16Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency16Samples_allocs)

	var csparseResidencyAliased_allocs *cgoAllocMap
	reff97e405d.sparseResidencyAliased, csparseResidencyAliased_allocs = (C.VkBool32)(x.SparseResidencyAliased), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyAliased_allocs)

	var cvariableMultisampleRate_allocs *cgoAllocMap
	reff97e405d.variableMultisampleRate, cvariableMultisampleRate_allocs = (C.VkBool32)(x.VariableMultisampleRate), cgoAllocsUnknown
	allocsf97e405d.Borrow(cvariableMultisampleRate_allocs)

	var cinheritedQueries_allocs *cgoAllocMap
	reff97e405d.inheritedQueries, cinheritedQueries_allocs = (C.VkBool32)(x.InheritedQueries), cgoAllocsUnknown
	allocsf97e405d.Borrow(cinheritedQueries_allocs)

	x.reff97e405d = reff97e405d
	x.allocsf97e405d = allocsf97e405d
	return reff97e405d, allocsf97e405d

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PhysicalDeviceFeatures) PassValue() (C.VkPhysicalDeviceFeatures, *cgoAllocMap) {
	if x.reff97e405d != nil {
		return *x.reff97e405d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PhysicalDeviceFeatures) Deref() {
	if x.reff97e405d == nil {
		return
	}
	x.RobustBufferAccess = (Bool32)(x.reff97e405d.robustBufferAccess)
	x.FullDrawIndexUint32 = (Bool32)(x.reff97e405d.fullDrawIndexUint32)
	x.ImageCubeArray = (Bool32)(x.reff97e405d.imageCubeArray)
	x.IndependentBlend = (Bool32)(x.reff97e405d.independentBlend)
	x.GeometryShader = (Bool32)(x.reff97e405d.geometryShader)
	x.TessellationShader = (Bool32)(x.reff97e405d.tessellationShader)
	x.SampleRateShading = (Bool32)(x.reff97e405d.sampleRateShading)
	x.DualSrcBlend = (Bool32)(x.reff97e405d.dualSrcBlend)
	x.LogicOp = (Bool32)(x.reff97e405d.logicOp)
	x.MultiDrawIndirect = (Bool32)(x.reff97e405d.multiDrawIndirect)
	x.DrawIndirectFirstInstance = (Bool32)(x.reff97e405d.drawIndirectFirstInstance)
	x.DepthClamp = (Bool32)(x.reff97e405d.depthClamp)
	x.DepthBiasClamp = (Bool32)(x.reff97e405d.depthBiasClamp)
	x.FillModeNonSolid = (Bool32)(x.reff97e405d.fillModeNonSolid)
	x.DepthBounds = (Bool32)(x.reff97e405d.depthBounds)
	x.WideLines = (Bool32)(x.reff97e405d.wideLines)
	x.LargePoints = (Bool32)(x.reff97e405d.largePoints)
	x.AlphaToOne = (Bool32)(x.reff97e405d.alphaToOne)
	x.MultiViewport = (Bool32)(x.reff97e405d.multiViewport)
	x.SamplerAnisotropy = (Bool32)(x.reff97e405d.samplerAnisotropy)
	x.TextureCompressionETC2 = (Bool32)(x.reff97e405d.textureCompressionETC2)
	x.TextureCompressionASTC_LDR = (Bool32)(x.reff97e405d.textureCompressionASTC_LDR)
	x.TextureCompressionBC = (Bool32)(x.reff97e405d.textureCompressionBC)
	x.OcclusionQueryPrecise = (Bool32)(x.reff97e405d.occlusionQueryPrecise)
	x.PipelineStatisticsQuery = (Bool32)(x.reff97e405d.pipelineStatisticsQuery)
	x.VertexPipelineStoresAndAtomics = (Bool32)(x.reff97e405d.vertexPipelineStoresAndAtomics)
	x.FragmentStoresAndAtomics = (Bool32)(x.reff97e405d.fragmentStoresAndAtomics)
	x.ShaderTessellationAndGeometryPointSize = (Bool32)(x.reff97e405d.shaderTessellationAndGeometryPointSize)
	x.ShaderImageGatherExtended = (Bool32)(x.reff97e405d.shaderImageGatherExtended)
	x.ShaderStorageImageExtendedFormats = (Bool32)(x.reff97e405d.shaderStorageImageExtendedFormats)
	x.ShaderStorageImageMultisample = (Bool32)(x.reff97e405d.shaderStorageImageMultisample)
	x.ShaderStorageImageReadWithoutFormat = (Bool32)(x.reff97e405d.shaderStorageImageReadWithoutFormat)
	x.ShaderStorageImageWriteWithoutFormat = (Bool32)(x.reff97e405d.shaderStorageImageWriteWithoutFormat)
	x.ShaderUniformBufferArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderUniformBufferArrayDynamicIndexing)
	x.ShaderSampledImageArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderSampledImageArrayDynamicIndexing)
	x.ShaderStorageBufferArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderStorageBufferArrayDynamicIndexing)
	x.ShaderStorageImageArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderStorageImageArrayDynamicIndexing)
	x.ShaderClipDistance = (Bool32)(x.reff97e405d.shaderClipDistance)
	x.ShaderCullDistance = (Bool32)(x.reff97e405d.shaderCullDistance)
	x.ShaderFloat64 = (Bool32)(x.reff97e405d.shaderFloat64)
	x.ShaderInt64 = (Bool32)(x.reff97e405d.shaderInt64)
	x.ShaderInt16 = (Bool32)(x.reff97e405d.shaderInt16)
	x.ShaderResourceResidency = (Bool32)(x.reff97e405d.shaderResourceResidency)
	x.ShaderResourceMinLod = (Bool32)(x.reff97e405d.shaderResourceMinLod)
	x.SparseBinding = (Bool32)(x.reff97e405d.sparseBinding)
	x.SparseResidencyBuffer = (Bool32)(x.reff97e405d.sparseResidencyBuffer)
	x.SparseResidencyImage2D = (Bool32)(x.reff97e405d.sparseResidencyImage2D)
	x.SparseResidencyImage3D = (Bool32)(x.reff97e405d.sparseResidencyImage3D)
	x.SparseResidency2Samples = (Bool32)(x.reff97e405d.sparseResidency2Samples)
	x.SparseResidency4Samples = (Bool32)(x.reff97e405d.sparseResidency4Samples)
	x.SparseResidency8Samples = (Bool32)(x.reff97e405d.sparseResidency8Samples)
	x.SparseResidency16Samples = (Bool32)(x.reff97e405d.sparseResidency16Samples)
	x.SparseResidencyAliased = (Bool32)(x.reff97e405d.sparseResidencyAliased)
	x.VariableMultisampleRate = (Bool32)(x.reff97e405d.variableMultisampleRate)
	x.InheritedQueries = (Bool32)(x.reff97e405d.inheritedQueries)
}

// allocFormatPropertiesMemory allocates memory for type C.VkFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFormatPropertiesValue = unsafe.Sizeof([1]C.VkFormatProperties{})

// Ref returns a reference.
func (x *FormatProperties) Ref() *C.VkFormatProperties {
	if x == nil {
		return nil
	}
	return x.refc4b9937b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *FormatProperties) Free() {
	if x != nil && x.allocsc4b9937b != nil {
		x.allocsc4b9937b.(*cgoAllocMap).Free()
		x.refc4b9937b = nil
	}
}

// NewFormatPropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewFormatPropertiesRef(ref interface{}) *FormatProperties {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(FormatProperties)
	obj.refc4b9937b = (*C.VkFormatProperties)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *FormatProperties) PassRef() (*C.VkFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc4b9937b != nil {
		return x.refc4b9937b, nil
	}
	memc4b9937b := allocFormatPropertiesMemory(1)
	refc4b9937b := (*C.VkFormatProperties)(memc4b9937b)
	allocsc4b9937b := new(cgoAllocMap)
	var clinearTilingFeatures_allocs *cgoAllocMap
	refc4b9937b.linearTilingFeatures, clinearTilingFeatures_allocs = (C.VkFormatFeatureFlags)(x.LinearTilingFeatures), cgoAllocsUnknown
	allocsc4b9937b.Borrow(clinearTilingFeatures_allocs)

	var coptimalTilingFeatures_allocs *cgoAllocMap
	refc4b9937b.optimalTilingFeatures, coptimalTilingFeatures_allocs = (C.VkFormatFeatureFlags)(x.OptimalTilingFeatures), cgoAllocsUnknown
	allocsc4b9937b.Borrow(coptimalTilingFeatures_allocs)

	var cbufferFeatures_allocs *cgoAllocMap
	refc4b9937b.bufferFeatures, cbufferFeatures_allocs = (C.VkFormatFeatureFlags)(x.BufferFeatures), cgoAllocsUnknown
	allocsc4b9937b.Borrow(cbufferFeatures_allocs)

	x.refc4b9937b = refc4b9937b
	x.allocsc4b9937b = allocsc4b9937b
	return refc4b9937b, allocsc4b9937b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x FormatProperties) PassValue() (C.VkFormatProperties, *cgoAllocMap) {
	if x.refc4b9937b != nil {
		return *x.refc4b9937b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *FormatProperties) Deref() {
	if x.refc4b9937b == nil {
		return
	}
	x.LinearTilingFeatures = (FormatFeatureFlags)(x.refc4b9937b.linearTilingFeatures)
	x.OptimalTilingFeatures = (FormatFeatureFlags)(x.refc4b9937b.optimalTilingFeatures)
	x.BufferFeatures = (FormatFeatureFlags)(x.refc4b9937b.bufferFeatures)
}

// allocExtent3DMemory allocates memory for type C.VkExtent3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtent3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtent3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExtent3DValue = unsafe.Sizeof([1]C.VkExtent3D{})

// Ref returns a reference.
func (x *Extent3D) Ref() *C.VkExtent3D {
	if x == nil {
		return nil
	}
	return x.reffbf6c42a
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Extent3D) Free() {
	if x != nil && x.allocsfbf6c42a != nil {
		x.allocsfbf6c42a.(*cgoAllocMap).Free()
		x.reffbf6c42a = nil
	}
}

// NewExtent3DRef initialises a new struct holding the reference to the originaitng C struct.
func NewExtent3DRef(ref interface{}) *Extent3D {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(Extent3D)
	obj.reffbf6c42a = (*C.VkExtent3D)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Extent3D) PassRef() (*C.VkExtent3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffbf6c42a != nil {
		return x.reffbf6c42a, nil
	}
	memfbf6c42a := allocExtent3DMemory(1)
	reffbf6c42a := (*C.VkExtent3D)(memfbf6c42a)
	allocsfbf6c42a := new(cgoAllocMap)
	var cwidth_allocs *cgoAllocMap
	reffbf6c42a.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocsfbf6c42a.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	reffbf6c42a.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocsfbf6c42a.Borrow(cheight_allocs)

	var cdepth_allocs *cgoAllocMap
	reffbf6c42a.depth, cdepth_allocs = (C.uint32_t)(x.Depth), cgoAllocsUnknown
	allocsfbf6c42a.Borrow(cdepth_allocs)

	x.reffbf6c42a = reffbf6c42a
	x.allocsfbf6c42a = allocsfbf6c42a
	return reffbf6c42a, allocsfbf6c42a

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x Extent3D) PassValue() (C.VkExtent3D, *cgoAllocMap) {
	if x.reffbf6c42a != nil {
		return *x.reffbf6c42a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Extent3D) Deref() {
	if x.reffbf6c42a == nil {
		return
	}
	x.Width = (uint32)(x.reffbf6c42a.width)
	x.Height = (uint32)(x.reffbf6c42a.height)
	x.Depth = (uint32)(x.reffbf6c42a.depth)
}

// allocImageFormatPropertiesMemory allocates memory for type C.VkImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkImageFormatProperties{})

// Ref returns a reference.
func (x *ImageFormatProperties) Ref() *C.VkImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.ref4cfb2ea2
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageFormatProperties) Free() {
	if x != nil && x.allocs4cfb2ea2 != nil {
		x.allocs4cfb2ea2.(*cgoAllocMap).Free()
		x.ref4cfb2ea2 = nil
	}
}

// NewImageFormatPropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageFormatPropertiesRef(ref interface{}) *ImageFormatProperties {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ImageFormatProperties)
	obj.ref4cfb2ea2 = (*C.VkImageFormatProperties)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageFormatProperties) PassRef() (*C.VkImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4cfb2ea2 != nil {
		return x.ref4cfb2ea2, nil
	}
	mem4cfb2ea2 := allocImageFormatPropertiesMemory(1)
	ref4cfb2ea2 := (*C.VkImageFormatProperties)(mem4cfb2ea2)
	allocs4cfb2ea2 := new(cgoAllocMap)
	var cmaxExtent_allocs *cgoAllocMap
	ref4cfb2ea2.maxExtent, cmaxExtent_allocs = x.MaxExtent.PassValue()
	allocs4cfb2ea2.Borrow(cmaxExtent_allocs)

	var cmaxMipLevels_allocs *cgoAllocMap
	ref4cfb2ea2.maxMipLevels, cmaxMipLevels_allocs = (C.uint32_t)(x.MaxMipLevels), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(cmaxMipLevels_allocs)

	var cmaxArrayLayers_allocs *cgoAllocMap
	ref4cfb2ea2.maxArrayLayers, cmaxArrayLayers_allocs = (C.uint32_t)(x.MaxArrayLayers), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(cmaxArrayLayers_allocs)

	var csampleCounts_allocs *cgoAllocMap
	ref4cfb2ea2.sampleCounts, csampleCounts_allocs = (C.VkSampleCountFlags)(x.SampleCounts), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(csampleCounts_allocs)

	var cmaxResourceSize_allocs *cgoAllocMap
	ref4cfb2ea2.maxResourceSize, cmaxResourceSize_allocs = (C.VkDeviceSize)(x.MaxResourceSize), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(cmaxResourceSize_allocs)

	x.ref4cfb2ea2 = ref4cfb2ea2
	x.allocs4cfb2ea2 = allocs4cfb2ea2
	return ref4cfb2ea2, allocs4cfb2ea2

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ImageFormatProperties) PassValue() (C.VkImageFormatProperties, *cgoAllocMap) {
	if x.ref4cfb2ea2 != nil {
		return *x.ref4cfb2ea2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageFormatProperties) Deref() {
	if x.ref4cfb2ea2 == nil {
		return
	}
	x.MaxExtent = *NewExtent3DRef(&x.ref4cfb2ea2.maxExtent)
	x.MaxMipLevels = (uint32)(x.ref4cfb2ea2.maxMipLevels)
	x.MaxArrayLayers = (uint32)(x.ref4cfb2ea2.maxArrayLayers)
	x.SampleCounts = (SampleCountFlags)(x.ref4cfb2ea2.sampleCounts)
	x.MaxResourceSize = (DeviceSize)(x.ref4cfb2ea2.maxResourceSize)
}

// allocPhysicalDeviceLimitsMemory allocates memory for type C.VkPhysicalDeviceLimits in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceLimitsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceLimitsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceLimitsValue = unsafe.Sizeof([1]C.VkPhysicalDeviceLimits{})

// Ref returns a reference.
func (x *PhysicalDeviceLimits) Ref() *C.VkPhysicalDeviceLimits {
	if x == nil {
		return nil
	}
	return x.ref7926795a
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PhysicalDeviceLimits) Free() {
	if x != nil && x.allocs7926795a != nil {
		x.allocs7926795a.(*cgoAllocMap).Free()
		x.ref7926795a = nil
	}
}

// NewPhysicalDeviceLimitsRef initialises a new struct holding the reference to the originaitng C struct.
func NewPhysicalDeviceLimitsRef(ref interface{}) *PhysicalDeviceLimits {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PhysicalDeviceLimits)
	obj.ref7926795a = (*C.VkPhysicalDeviceLimits)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PhysicalDeviceLimits) PassRef() (*C.VkPhysicalDeviceLimits, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7926795a != nil {
		return x.ref7926795a, nil
	}
	mem7926795a := allocPhysicalDeviceLimitsMemory(1)
	ref7926795a := (*C.VkPhysicalDeviceLimits)(mem7926795a)
	allocs7926795a := new(cgoAllocMap)
	var cmaxImageDimension1D_allocs *cgoAllocMap
	ref7926795a.maxImageDimension1D, cmaxImageDimension1D_allocs = (C.uint32_t)(x.MaxImageDimension1D), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimension1D_allocs)

	var cmaxImageDimension2D_allocs *cgoAllocMap
	ref7926795a.maxImageDimension2D, cmaxImageDimension2D_allocs = (C.uint32_t)(x.MaxImageDimension2D), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimension2D_allocs)

	var cmaxImageDimension3D_allocs *cgoAllocMap
	ref7926795a.maxImageDimension3D, cmaxImageDimension3D_allocs = (C.uint32_t)(x.MaxImageDimension3D), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimension3D_allocs)

	var cmaxImageDimensionCube_allocs *cgoAllocMap
	ref7926795a.maxImageDimensionCube, cmaxImageDimensionCube_allocs = (C.uint32_t)(x.MaxImageDimensionCube), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimensionCube_allocs)

	var cmaxImageArrayLayers_allocs *cgoAllocMap
	ref7926795a.maxImageArrayLayers, cmaxImageArrayLayers_allocs = (C.uint32_t)(x.MaxImageArrayLayers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageArrayLayers_allocs)

	var cmaxTexelBufferElements_allocs *cgoAllocMap
	ref7926795a.maxTexelBufferElements, cmaxTexelBufferElements_allocs = (C.uint32_t)(x.MaxTexelBufferElements), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTexelBufferElements_allocs)

	var cmaxUniformBufferRange_allocs *cgoAllocMap
	ref7926795a.maxUniformBufferRange, cmaxUniformBufferRange_allocs = (C.uint32_t)(x.MaxUniformBufferRange), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxUniformBufferRange_allocs)

	var cmaxStorageBufferRange_allocs *cgoAllocMap
	ref7926795a.maxStorageBufferRange, cmaxStorageBufferRange_allocs = (C.uint32_t)(x.MaxStorageBufferRange), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxStorageBufferRange_allocs)

	var cmaxPushConstantsSize_allocs *cgoAllocMap
	ref7926795a.maxPushConstantsSize, cmaxPushConstantsSize_allocs = (C.uint32_t)(x.MaxPushConstantsSize), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPushConstantsSize_allocs)

	var cmaxMemoryAllocationCount_allocs *cgoAllocMap
	ref7926795a.maxMemoryAllocationCount, cmaxMemoryAllocationCount_allocs = (C.uint32_t)(x.MaxMemoryAllocationCount), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxMemoryAllocationCount_allocs)

	var cmaxSamplerAllocationCount_allocs *cgoAllocMap
	ref7926795a.maxSamplerAllocationCount, cmaxSamplerAllocationCount_allocs = (C.uint32_t)(x.MaxSamplerAllocationCount), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSamplerAllocationCount_allocs)

	var cbufferImageGranularity_allocs *cgoAllocMap
	ref7926795a.bufferImageGranularity, cbufferImageGranularity_allocs = (C.VkDeviceSize)(x.BufferImageGranularity), cgoAllocsUnknown
	allocs7926795a.Borrow(cbufferImageGranularity_allocs)

	var csparseAddressSpaceSize_allocs *cgoAllocMap
	ref7926795a.sparseAddressSpaceSize, csparseAddressSpaceSize_allocs = (C.VkDeviceSize)(x.SparseAddressSpaceSize), cgoAllocsUnknown
	allocs7926795a.Borrow(csparseAddressSpaceSize_allocs)

	var cmaxBoundDescriptorSets_allocs *cgoAllocMap
	ref7926795a.maxBoundDescriptorSets, cmaxBoundDescriptorSets_allocs = (C.uint32_t)(x.MaxBoundDescriptorSets), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxBoundDescriptorSets_allocs)

	var cmaxPerStageDescriptorSamplers_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorSamplers, cmaxPerStageDescriptorSamplers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorSamplers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorSamplers_allocs)

	var cmaxPerStageDescriptorUniformBuffers_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorUniformBuffers, cmaxPerStageDescriptorUniformBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUniformBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorUniformBuffers_allocs)

	var cmaxPerStageDescriptorStorageBuffers_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorStorageBuffers, cmaxPerStageDescriptorStorageBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorStorageBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorStorageBuffers_allocs)

	var cmaxPerStageDescriptorSampledImages_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorSampledImages, cmaxPerStageDescriptorSampledImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorSampledImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorSampledImages_allocs)

	var cmaxPerStageDescriptorStorageImages_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorStorageImages, cmaxPerStageDescriptorStorageImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorStorageImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorStorageImages_allocs)

	var cmaxPerStageDescriptorInputAttachments_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorInputAttachments, cmaxPerStageDescriptorInputAttachments_allocs = (C.uint32_t)(x.MaxPerStageDescriptorInputAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorInputAttachments_allocs)

	var cmaxPerStageResources_allocs *cgoAllocMap
	ref7926795a.maxPerStageResources, cmaxPerStageResources_allocs = (C.uint32_t)(x.MaxPerStageResources), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageResources_allocs)

	var cmaxDescriptorSetSamplers_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetSamplers, cmaxDescriptorSetSamplers_allocs = (C.uint32_t)(x.MaxDescriptorSetSamplers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetSamplers_allocs)

	var cmaxDescriptorSetUniformBuffers_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetUniformBuffers, cmaxDescriptorSetUniformBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetUniformBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetUniformBuffers_allocs)

	var cmaxDescriptorSetUniformBuffersDynamic_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetUniformBuffersDynamic, cmaxDescriptorSetUniformBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetUniformBuffersDynamic), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetUniformBuffersDynamic_allocs)

	var cmaxDescriptorSetStorageBuffers_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetStorageBuffers, cmaxDescriptorSetStorageBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetStorageBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetStorageBuffers_allocs)

	var cmaxDescriptorSetStorageBuffersDynamic_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetStorageBuffersDynamic, cmaxDescriptorSetStorageBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetStorageBuffersDynamic), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetStorageBuffersDynamic_allocs)

	var cmaxDescriptorSetSampledImages_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetSampledImages, cmaxDescriptorSetSampledImages_allocs = (C.uint32_t)(x.MaxDescriptorSetSampledImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetSampledImages_allocs)

	var cmaxDescriptorSetStorageImages_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetStorageImages, cmaxDescriptorSetStorageImages_allocs = (C.uint32_t)(x.MaxDescriptorSetStorageImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetStorageImages_allocs)

	var cmaxDescriptorSetInputAttachments_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetInputAttachments, cmaxDescriptorSetInputAttachments_allocs = (C.uint32_t)(x.MaxDescriptorSetInputAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetInputAttachments_allocs)

	var cmaxVertexInputAttributes_allocs *cgoAllocMap
	ref7926795a.maxVertexInputAttributes, cmaxVertexInputAttributes_allocs = (C.uint32_t)(x.MaxVertexInputAttributes), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputAttributes_allocs)

	var cmaxVertexInputBindings_allocs *cgoAllocMap
	ref7926795a.maxVertexInputBindings, cmaxVertexInputBindings_allocs = (C.uint32_t)(x.MaxVertexInputBindings), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputBindings_allocs)

	var cmaxVertexInputAttributeOffset_allocs *cgoAllocMap
	ref7926795a.maxVertexInputAttributeOffset, cmaxVertexInputAttributeOffset_allocs = (C.uint32_t)(x.MaxVertexInputAttributeOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputAttributeOffset_allocs)

	var cmaxVertexInputBindingStride_allocs *cgoAllocMap
	ref7926795a.maxVertexInputBindingStride, cmaxVertexInputBindingStride_allocs = (C.uint32_t)(x.MaxVertexInputBindingStride), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputBindingStride_allocs)

	var cmaxVertexOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxVertexOutputComponents, cmaxVertexOutputComponents_allocs = (C.uint32_t)(x.MaxVertexOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexOutputComponents_allocs)

	var cmaxTessellationGenerationLevel_allocs *cgoAllocMap
	ref7926795a.maxTessellationGenerationLevel, cmaxTessellationGenerationLevel_allocs = (C.uint32_t)(x.MaxTessellationGenerationLevel), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationGenerationLevel_allocs)

	var cmaxTessellationPatchSize_allocs *cgoAllocMap
	ref7926795a.maxTessellationPatchSize, cmaxTessellationPatchSize_allocs = (C.uint32_t)(x.MaxTessellationPatchSize), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationPatchSize_allocs)

	var cmaxTessellationControlPerVertexInputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlPerVertexInputComponents, cmaxTessellationControlPerVertexInputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlPerVertexInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlPerVertexInputComponents_allocs)

	var cmaxTessellationControlPerVertexOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlPerVertexOutputComponents, cmaxTessellationControlPerVertexOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlPerVertexOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlPerVertexOutputComponents_allocs)

	var cmaxTessellationControlPerPatchOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlPerPatchOutputComponents, cmaxTessellationControlPerPatchOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlPerPatchOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlPerPatchOutputComponents_allocs)

	var cmaxTessellationControlTotalOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlTotalOutputComponents, cmaxTessellationControlTotalOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlTotalOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlTotalOutputComponents_allocs)

	var cmaxTessellationEvaluationInputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationEvaluationInputComponents, cmaxTessellationEvaluationInputComponents_allocs = (C.uint32_t)(x.MaxTessellationEvaluationInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationEvaluationInputComponents_allocs)

	var cmaxTessellationEvaluationOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationEvaluationOutputComponents, cmaxTessellationEvaluationOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationEvaluationOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationEvaluationOutputComponents_allocs)

	var cmaxGeometryShaderInvocations_allocs *cgoAllocMap
	ref7926795a.maxGeometryShaderInvocations, cmaxGeometryShaderInvocations_allocs = (C.uint32_t)(x.MaxGeometryShaderInvocations), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryShaderInvocations_allocs)

	var cmaxGeometryInputComponents_allocs *cgoAllocMap
	ref7926795a.maxGeometryInputComponents, cmaxGeometryInputComponents_allocs = (C.uint32_t)(x.MaxGeometryInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryInputComponents_allocs)

	var cmaxGeometryOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxGeometryOutputComponents, cmaxGeometryOutputComponents_allocs = (C.uint32_t)(x.MaxGeometryOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryOutputComponents_allocs)

	var cmaxGeometryOutputVertices_allocs *cgoAllocMap
	ref7926795a.maxGeometryOutputVertices, cmaxGeometryOutputVertices_allocs = (C.uint32_t)(x.MaxGeometryOutputVertices), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryOutputVertices_allocs)

	var cmaxGeometryTotalOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxGeometryTotalOutputComponents, cmaxGeometryTotalOutputComponents_allocs = (C.uint32_t)(x.MaxGeometryTotalOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryTotalOutputComponents_allocs)

	var cmaxFragmentInputComponents_allocs *cgoAllocMap
	ref7926795a.maxFragmentInputComponents, cmaxFragmentInputComponents_allocs = (C.uint32_t)(x.MaxFragmentInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentInputComponents_allocs)

	var cmaxFragmentOutputAttachments_allocs *cgoAllocMap
	ref7926795a.maxFragmentOutputAttachments, cmaxFragmentOutputAttachments_allocs = (C.uint32_t)(x.MaxFragmentOutputAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentOutputAttachments_allocs)

	var cmaxFragmentDualSrcAttachments_allocs *cgoAllocMap
	ref7926795a.maxFragmentDualSrcAttachments, cmaxFragmentDualSrcAttachments_allocs = (C.uint32_t)(x.MaxFragmentDualSrcAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentDualSrcAttachments_allocs)

	var cmaxFragmentCombinedOutputResources_allocs *cgoAllocMap
	ref7926795a.maxFragmentCombinedOutputResources, cmaxFragmentCombinedOutputResources_allocs = (C.uint32_t)(x.MaxFragmentCombinedOutputResources), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentCombinedOutputResources_allocs)

	var cmaxComputeSharedMemorySize_allocs *cgoAllocMap
	ref7926795a.maxComputeSharedMemorySize, cmaxComputeSharedMemorySize_allocs = (C.uint32_t)(x.MaxComputeSharedMemorySize), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeSharedMemorySize_allocs)

	var cmaxComputeWorkGroupCount_allocs *cgoAllocMap
	ref7926795a.maxComputeWorkGroupCount, cmaxComputeWorkGroupCount_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.MaxComputeWorkGroupCount)), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeWorkGroupCount_allocs)

	var cmaxComputeWorkGroupInvocations_allocs *cgoAllocMap
	ref7926795a.maxComputeWorkGroupInvocations, cmaxComputeWorkGroupInvocations_allocs = (C.uint32_t)(x.MaxComputeWorkGroupInvocations), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeWorkGroupInvocations_allocs)

	var cmaxComputeWorkGroupSize_allocs *cgoAllocMap
	ref7926795a.maxComputeWorkGroupSize, cmaxComputeWorkGroupSize_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.MaxComputeWorkGroupSize)), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeWorkGroupSize_allocs)

	var csubPixelPrecisionBits_allocs *cgoAllocMap
	ref7926795a.subPixelPrecisionBits, csubPixelPrecisionBits_allocs = (C.uint32_t)(x.SubPixelPrecisionBits), cgoAllocsUnknown
	allocs7926795a.Borrow(csubPixelPrecisionBits_allocs)

	var csubTexelPrecisionBits_allocs *cgoAllocMap
	ref7926795a.subTexelPrecisionBits, csubTexelPrecisionBits_allocs = (C.uint32_t)(x.SubTexelPrecisionBits), cgoAllocsUnknown
	allocs7926795a.Borrow(csubTexelPrecisionBits_allocs)

	var cmipmapPrecisionBits_allocs *cgoAllocMap
	ref7926795a.mipmapPrecisionBits, cmipmapPrecisionBits_allocs = (C.uint32_t)(x.MipmapPrecisionBits), cgoAllocsUnknown
	allocs7926795a.Borrow(cmipmapPrecisionBits_allocs)

	var cmaxDrawIndexedIndexValue_allocs *cgoAllocMap
	ref7926795a.maxDrawIndexedIndexValue, cmaxDrawIndexedIndexValue_allocs = (C.uint32_t)(x.MaxDrawIndexedIndexValue), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDrawIndexedIndexValue_allocs)

	var cmaxDrawIndirectCount_allocs *cgoAllocMap
	ref7926795a.maxDrawIndirectCount, cmaxDrawIndirectCount_allocs = (C.uint32_t)(x.MaxDrawIndirectCount), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDrawIndirectCount_allocs)

	var cmaxSamplerLodBias_allocs *cgoAllocMap
	ref7926795a.maxSamplerLodBias, cmaxSamplerLodBias_allocs = (C.float)(x.MaxSamplerLodBias), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSamplerLodBias_allocs)

	var cmaxSamplerAnisotropy_allocs *cgoAllocMap
	ref7926795a.maxSamplerAnisotropy, cmaxSamplerAnisotropy_allocs = (C.float)(x.MaxSamplerAnisotropy), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSamplerAnisotropy_allocs)

	var cmaxViewports_allocs *cgoAllocMap
	ref7926795a.maxViewports, cmaxViewports_allocs = (C.uint32_t)(x.MaxViewports), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxViewports_allocs)

	var cmaxViewportDimensions_allocs *cgoAllocMap
	ref7926795a.maxViewportDimensions, cmaxViewportDimensions_allocs = *(*[2]C.uint32_t)(unsafe.Pointer(&x.MaxViewportDimensions)), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxViewportDimensions_allocs)

	var cviewportBoundsRange_allocs *cgoAllocMap
	ref7926795a.viewportBoundsRange, cviewportBoundsRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.ViewportBoundsRange)), cgoAllocsUnknown
	allocs7926795a.Borrow(cviewportBoundsRange_allocs)

	var cviewportSubPixelBits_allocs *cgoAllocMap
	ref7926795a.viewportSubPixelBits, cviewportSubPixelBits_allocs = (C.uint32_t)(x.ViewportSubPixelBits), cgoAllocsUnknown
	allocs7926795a.Borrow(cviewportSubPixelBits_allocs)

	var cminMemoryMapAlignment_allocs *cgoAllocMap
	ref7926795a.minMemoryMapAlignment, cminMemoryMapAlignment_allocs = (C.size_t)(x.MinMemoryMapAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminMemoryMapAlignment_allocs)

	var cminTexelBufferOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.minTexelBufferOffsetAlignment, cminTexelBufferOffsetAlignment_allocs = (C.VkDeviceSize)(x.MinTexelBufferOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminTexelBufferOffsetAlignment_allocs)

	var cminUniformBufferOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.minUniformBufferOffsetAlignment, cminUniformBufferOffsetAlignment_allocs = (C.VkDeviceSize)(x.MinUniformBufferOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminUniformBufferOffsetAlignment_allocs)

	var cminStorageBufferOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.minStorageBufferOffsetAlignment, cminStorageBufferOffsetAlignment_allocs = (C.VkDeviceSize)(x.MinStorageBufferOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminStorageBufferOffsetAlignment_allocs)

	var cminTexelOffset_allocs *cgoAllocMap
	ref7926795a.minTexelOffset, cminTexelOffset_allocs = (C.int32_t)(x.MinTexelOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cminTexelOffset_allocs)

	var cmaxTexelOffset_allocs *cgoAllocMap
	ref7926795a.maxTexelOffset, cmaxTexelOffset_allocs = (C.uint32_t)(x.MaxTexelOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTexelOffset_allocs)

	var cminTexelGatherOffset_allocs *cgoAllocMap
	ref7926795a.minTexelGatherOffset, cminTexelGatherOffset_allocs = (C.int32_t)(x.MinTexelGatherOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cminTexelGatherOffset_allocs)

	var cmaxTexelGatherOffset_allocs *cgoAllocMap
	ref7926795a.maxTexelGatherOffset, cmaxTexelGatherOffset_allocs = (C.uint32_t)(x.MaxTexelGatherOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTexelGatherOffset_allocs)

	var cminInterpolationOffset_allocs *cgoAllocMap
	ref7926795a.minInterpolationOffset, cminInterpolationOffset_allocs = (C.float)(x.MinInterpolationOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cminInterpolationOffset_allocs)

	var cmaxInterpolationOffset_allocs *cgoAllocMap
	ref7926795a.maxInterpolationOffset, cmaxInterpolationOffset_allocs = (C.float)(x.MaxInterpolationOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxInterpolationOffset_allocs)

	var csubPixelInterpolationOffsetBits_allocs *cgoAllocMap
	ref7926795a.subPixelInterpolationOffsetBits, csubPixelInterpolationOffsetBits_allocs = (C.uint32_t)(x.SubPixelInterpolationOffsetBits), cgoAllocsUnknown
	allocs7926795a.Borrow(csubPixelInterpolationOffsetBits_allocs)

	var cmaxFramebufferWidth_allocs *cgoAllocMap
	ref7926795a.maxFramebufferWidth, cmaxFramebufferWidth_allocs = (C.uint32_t)(x.MaxFramebufferWidth), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFramebufferWidth_allocs)

	var cmaxFramebufferHeight_allocs *cgoAllocMap
	ref7926795a.maxFramebufferHeight, cmaxFramebufferHeight_allocs = (C.uint32_t)(x.MaxFramebufferHeight), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFramebufferHeight_allocs)

	var cmaxFramebufferLayers_allocs *cgoAllocMap
	ref7926795a.maxFramebufferLayers, cmaxFramebufferLayers_allocs = (C.uint32_t)(x.MaxFramebufferLayers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFramebufferLayers_allocs)

	var cframebufferColorSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferColorSampleCounts, cframebufferColorSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferColorSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferColorSampleCounts_allocs)

	var cframebufferDepthSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferDepthSampleCounts, cframebufferDepthSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferDepthSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferDepthSampleCounts_allocs)

	var cframebufferStencilSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferStencilSampleCounts, cframebufferStencilSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferStencilSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferStencilSampleCounts_allocs)

	var cframebufferNoAttachmentsSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferNoAttachmentsSampleCounts, cframebufferNoAttachmentsSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferNoAttachmentsSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferNoAttachmentsSampleCounts_allocs)

	var cmaxColorAttachments_allocs *cgoAllocMap
	ref7926795a.maxColorAttachments, cmaxColorAttachments_allocs = (C.uint32_t)(x.MaxColorAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxColorAttachments_allocs)

	var csampledImageColorSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageColorSampleCounts, csampledImageColorSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageColorSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageColorSampleCounts_allocs)

	var csampledImageIntegerSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageIntegerSampleCounts, csampledImageIntegerSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageIntegerSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageIntegerSampleCounts_allocs)

	var csampledImageDepthSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageDepthSampleCounts, csampledImageDepthSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageDepthSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageDepthSampleCounts_allocs)

	var csampledImageStencilSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageStencilSampleCounts, csampledImageStencilSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageStencilSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageStencilSampleCounts_allocs)

	var cstorageImageSampleCounts_allocs *cgoAllocMap
	ref7926795a.storageImageSampleCounts, cstorageImageSampleCounts_allocs = (C.VkSampleCountFlags)(x.StorageImageSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cstorageImageSampleCounts_allocs)

	var cmaxSampleMaskWords_allocs *cgoAllocMap
	ref7926795a.maxSampleMaskWords, cmaxSampleMaskWords_allocs = (C.uint32_t)(x.MaxSampleMaskWords), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSampleMaskWords_allocs)

	var ctimestampComputeAndGraphics_allocs *cgoAllocMap
	ref7926795a.timestampComputeAndGraphics, ctimestampComputeAndGraphics_allocs = (C.VkBool32)(x.TimestampComputeAndGraphics), cgoAllocsUnknown
	allocs7926795a.Borrow(ctimestampComputeAndGraphics_allocs)

	var ctimestampPeriod_allocs *cgoAllocMap
	ref7926795a.timestampPeriod, ctimestampPeriod_allocs = (C.float)(x.TimestampPeriod), cgoAllocsUnknown
	allocs7926795a.Borrow(ctimestampPeriod_allocs)

	var cmaxClipDistances_allocs *cgoAllocMap
	ref7926795a.maxClipDistances, cmaxClipDistances_allocs = (C.uint32_t)(x.MaxClipDistances), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxClipDistances_allocs)

	var cmaxCullDistances_allocs *cgoAllocMap
	ref7926795a.maxCullDistances, cmaxCullDistances_allocs = (C.uint32_t)(x.MaxCullDistances), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxCullDistances_allocs)

	var cmaxCombinedClipAndCullDistances_allocs *cgoAllocMap
	ref7926795a.maxCombinedClipAndCullDistances, cmaxCombinedClipAndCullDistances_allocs = (C.uint32_t)(x.MaxCombinedClipAndCullDistances), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxCombinedClipAndCullDistances_allocs)

	var cdiscreteQueuePriorities_allocs *cgoAllocMap
	ref7926795a.discreteQueuePriorities, cdiscreteQueuePriorities_allocs = (C.uint32_t)(x.DiscreteQueuePriorities), cgoAllocsUnknown
	allocs7926795a.Borrow(cdiscreteQueuePriorities_allocs)

	var cpointSizeRange_allocs *cgoAllocMap
	ref7926795a.pointSizeRange, cpointSizeRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.PointSizeRange)), cgoAllocsUnknown
	allocs7926795a.Borrow(cpointSizeRange_allocs)

	var clineWidthRange_allocs *cgoAllocMap
	ref7926795a.lineWidthRange, clineWidthRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.LineWidthRange)), cgoAllocsUnknown
	allocs7926795a.Borrow(clineWidthRange_allocs)

	var cpointSizeGranularity_allocs *cgoAllocMap
	ref7926795a.pointSizeGranularity, cpointSizeGranularity_allocs = (C.float)(x.PointSizeGranularity), cgoAllocsUnknown
	allocs7926795a.Borrow(cpointSizeGranularity_allocs)

	var clineWidthGranularity_allocs *cgoAllocMap
	ref7926795a.lineWidthGranularity, clineWidthGranularity_allocs = (C.float)(x.LineWidthGranularity), cgoAllocsUnknown
	allocs7926795a.Borrow(clineWidthGranularity_allocs)

	var cstrictLines_allocs *cgoAllocMap
	ref7926795a.strictLines, cstrictLines_allocs = (C.VkBool32)(x.StrictLines), cgoAllocsUnknown
	allocs7926795a.Borrow(cstrictLines_allocs)

	var cstandardSampleLocations_allocs *cgoAllocMap
	ref7926795a.standardSampleLocations, cstandardSampleLocations_allocs = (C.VkBool32)(x.StandardSampleLocations), cgoAllocsUnknown
	allocs7926795a.Borrow(cstandardSampleLocations_allocs)

	var coptimalBufferCopyOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.optimalBufferCopyOffsetAlignment, coptimalBufferCopyOffsetAlignment_allocs = (C.VkDeviceSize)(x.OptimalBufferCopyOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(coptimalBufferCopyOffsetAlignment_allocs)

	var coptimalBufferCopyRowPitchAlignment_allocs *cgoAllocMap
	ref7926795a.optimalBufferCopyRowPitchAlignment, coptimalBufferCopyRowPitchAlignment_allocs = (C.VkDeviceSize)(x.OptimalBufferCopyRowPitchAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(coptimalBufferCopyRowPitchAlignment_allocs)

	var cnonCoherentAtomSize_allocs *cgoAllocMap
	ref7926795a.nonCoherentAtomSize, cnonCoherentAtomSize_allocs = (C.VkDeviceSize)(x.NonCoherentAtomSize), cgoAllocsUnknown
	allocs7926795a.Borrow(cnonCoherentAtomSize_allocs)

	x.ref7926795a = ref7926795a
	x.allocs7926795a = allocs7926795a
	return ref7926795a, allocs7926795a

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PhysicalDeviceLimits) PassValue() (C.VkPhysicalDeviceLimits, *cgoAllocMap) {
	if x.ref7926795a != nil {
		return *x.ref7926795a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PhysicalDeviceLimits) Deref() {
	if x.ref7926795a == nil {
		return
	}
	x.MaxImageDimension1D = (uint32)(x.ref7926795a.maxImageDimension1D)
	x.MaxImageDimension2D = (uint32)(x.ref7926795a.maxImageDimension2D)
	x.MaxImageDimension3D = (uint32)(x.ref7926795a.maxImageDimension3D)
	x.MaxImageDimensionCube = (uint32)(x.ref7926795a.maxImageDimensionCube)
	x.MaxImageArrayLayers = (uint32)(x.ref7926795a.maxImageArrayLayers)
	x.MaxTexelBufferElements = (uint32)(x.ref7926795a.maxTexelBufferElements)
	x.MaxUniformBufferRange = (uint32)(x.ref7926795a.maxUniformBufferRange)
	x.MaxStorageBufferRange = (uint32)(x.ref7926795a.maxStorageBufferRange)
	x.MaxPushConstantsSize = (uint32)(x.ref7926795a.maxPushConstantsSize)
	x.MaxMemoryAllocationCount = (uint32)(x.ref7926795a.maxMemoryAllocationCount)
	x.MaxSamplerAllocationCount = (uint32)(x.ref7926795a.maxSamplerAllocationCount)
	x.BufferImageGranularity = (DeviceSize)(x.ref7926795a.bufferImageGranularity)
	x.SparseAddressSpaceSize = (DeviceSize)(x.ref7926795a.sparseAddressSpaceSize)
	x.MaxBoundDescriptorSets = (uint32)(x.ref7926795a.maxBoundDescriptorSets)
	x.MaxPerStageDescriptorSamplers = (uint32)(x.ref7926795a.maxPerStageDescriptorSamplers)
	x.MaxPerStageDescriptorUniformBuffers = (uint32)(x.ref7926795a.maxPerStageDescriptorUniformBuffers)
	x.MaxPerStageDescriptorStorageBuffers = (uint32)(x.ref7926795a.maxPerStageDescriptorStorageBuffers)
	x.MaxPerStageDescriptorSampledImages = (uint32)(x.ref7926795a.maxPerStageDescriptorSampledImages)
	x.MaxPerStageDescriptorStorageImages = (uint32)(x.ref7926795a.maxPerStageDescriptorStorageImages)
	x.MaxPerStageDescriptorInputAttachments = (uint32)(x.ref7926795a.maxPerStageDescriptorInputAttachments)
	x.MaxPerStageResources = (uint32)(x.ref7926795a.maxPerStageResources)
	x.MaxDescriptorSetSamplers = (uint32)(x.ref7926795a.maxDescriptorSetSamplers)
	x.MaxDescriptorSetUniformBuffers = (uint32)(x.ref7926795a.maxDescriptorSetUniformBuffers)
	x.MaxDescriptorSetUniformBuffersDynamic = (uint32)(x.ref7926795a.maxDescriptorSetUniformBuffersDynamic)
	x.MaxDescriptorSetStorageBuffers = (uint32)(x.ref7926795a.maxDescriptorSetStorageBuffers)
	x.MaxDescriptorSetStorageBuffersDynamic = (uint32)(x.ref7926795a.maxDescriptorSetStorageBuffersDynamic)
	x.MaxDescriptorSetSampledImages = (uint32)(x.ref7926795a.maxDescriptorSetSampledImages)
	x.MaxDescriptorSetStorageImages = (uint32)(x.ref7926795a.maxDescriptorSetStorageImages)
	x.MaxDescriptorSetInputAttachments = (uint32)(x.ref7926795a.maxDescriptorSetInputAttachments)
	x.MaxVertexInputAttributes = (uint32)(x.ref7926795a.maxVertexInputAttributes)
	x.MaxVertexInputBindings = (uint32)(x.ref7926795a.maxVertexInputBindings)
	x.MaxVertexInputAttributeOffset = (uint32)(x.ref7926795a.maxVertexInputAttributeOffset)
	x.MaxVertexInputBindingStride = (uint32)(x.ref7926795a.maxVertexInputBindingStride)
	x.MaxVertexOutputComponents = (uint32)(x.ref7926795a.maxVertexOutputComponents)
	x.MaxTessellationGenerationLevel = (uint32)(x.ref7926795a.maxTessellationGenerationLevel)
	x.MaxTessellationPatchSize = (uint32)(x.ref7926795a.maxTessellationPatchSize)
	x.MaxTessellationControlPerVertexInputComponents = (uint32)(x.ref7926795a.maxTessellationControlPerVertexInputComponents)
	x.MaxTessellationControlPerVertexOutputComponents = (uint32)(x.ref7926795a.maxTessellationControlPerVertexOutputComponents)
	x.MaxTessellationControlPerPatchOutputComponents = (uint32)(x.ref7926795a.maxTessellationControlPerPatchOutputComponents)
	x.MaxTessellationControlTotalOutputComponents = (uint32)(x.ref7926795a.maxTessellationControlTotalOutputComponents)
	x.MaxTessellationEvaluationInputComponents = (uint32)(x.ref7926795a.maxTessellationEvaluationInputComponents)
	x.MaxTessellationEvaluationOutputComponents = (uint32)(x.ref7926795a.maxTessellationEvaluationOutputComponents)
	x.MaxGeometryShaderInvocations = (uint32)(x.ref7926795a.maxGeometryShaderInvocations)
	x.MaxGeometryInputComponents = (uint32)(x.ref7926795a.maxGeometryInputComponents)
	x.MaxGeometryOutputComponents = (uint32)(x.ref7926795a.maxGeometryOutputComponents)
	x.MaxGeometryOutputVertices = (uint32)(x.ref7926795a.maxGeometryOutputVertices)
	x.MaxGeometryTotalOutputComponents = (uint32)(x.ref7926795a.maxGeometryTotalOutputComponents)
	x.MaxFragmentInputComponents = (uint32)(x.ref7926795a.maxFragmentInputComponents)
	x.MaxFragmentOutputAttachments = (uint32)(x.ref7926795a.maxFragmentOutputAttachments)
	x.MaxFragmentDualSrcAttachments = (uint32)(x.ref7926795a.maxFragmentDualSrcAttachments)
	x.MaxFragmentCombinedOutputResources = (uint32)(x.ref7926795a.maxFragmentCombinedOutputResources)
	x.MaxComputeSharedMemorySize = (uint32)(x.ref7926795a.maxComputeSharedMemorySize)
	x.MaxComputeWorkGroupCount = *(*[3]uint32)(unsafe.Pointer(&x.ref7926795a.maxComputeWorkGroupCount))
	x.MaxComputeWorkGroupInvocations = (uint32)(x.ref7926795a.maxComputeWorkGroupInvocations)
	x.MaxComputeWorkGroupSize = *(*[3]uint32)(unsafe.Pointer(&x.ref7926795a.maxComputeWorkGroupSize))
	x.SubPixelPrecisionBits = (uint32)(x.ref7926795a.subPixelPrecisionBits)
	x.SubTexelPrecisionBits = (uint32)(x.ref7926795a.subTexelPrecisionBits)
	x.MipmapPrecisionBits = (uint32)(x.ref7926795a.mipmapPrecisionBits)
	x.MaxDrawIndexedIndexValue = (uint32)(x.ref7926795a.maxDrawIndexedIndexValue)
	x.MaxDrawIndirectCount = (uint32)(x.ref7926795a.maxDrawIndirectCount)
	x.MaxSamplerLodBias = (float32)(x.ref7926795a.maxSamplerLodBias)
	x.MaxSamplerAnisotropy = (float32)(x.ref7926795a.maxSamplerAnisotropy)
	x.MaxViewports = (uint32)(x.ref7926795a.maxViewports)
	x.MaxViewportDimensions = *(*[2]uint32)(unsafe.Pointer(&x.ref7926795a.maxViewportDimensions))
	x.ViewportBoundsRange = *(*[2]float32)(unsafe.Pointer(&x.ref7926795a.viewportBoundsRange))
	x.ViewportSubPixelBits = (uint32)(x.ref7926795a.viewportSubPixelBits)
	x.MinMemoryMapAlignment = (uint)(x.ref7926795a.minMemoryMapAlignment)
	x.MinTexelBufferOffsetAlignment = (DeviceSize)(x.ref7926795a.minTexelBufferOffsetAlignment)
	x.MinUniformBufferOffsetAlignment = (DeviceSize)(x.ref7926795a.minUniformBufferOffsetAlignment)
	x.MinStorageBufferOffsetAlignment = (DeviceSize)(x.ref7926795a.minStorageBufferOffsetAlignment)
	x.MinTexelOffset = (int32)(x.ref7926795a.minTexelOffset)
	x.MaxTexelOffset = (uint32)(x.ref7926795a.maxTexelOffset)
	x.MinTexelGatherOffset = (int32)(x.ref7926795a.minTexelGatherOffset)
	x.MaxTexelGatherOffset = (uint32)(x.ref7926795a.maxTexelGatherOffset)
	x.MinInterpolationOffset = (float32)(x.ref7926795a.minInterpolationOffset)
	x.MaxInterpolationOffset = (float32)(x.ref7926795a.maxInterpolationOffset)
	x.SubPixelInterpolationOffsetBits = (uint32)(x.ref7926795a.subPixelInterpolationOffsetBits)
	x.MaxFramebufferWidth = (uint32)(x.ref7926795a.maxFramebufferWidth)
	x.MaxFramebufferHeight = (uint32)(x.ref7926795a.maxFramebufferHeight)
	x.MaxFramebufferLayers = (uint32)(x.ref7926795a.maxFramebufferLayers)
	x.FramebufferColorSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferColorSampleCounts)
	x.FramebufferDepthSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferDepthSampleCounts)
	x.FramebufferStencilSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferStencilSampleCounts)
	x.FramebufferNoAttachmentsSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferNoAttachmentsSampleCounts)
	x.MaxColorAttachments = (uint32)(x.ref7926795a.maxColorAttachments)
	x.SampledImageColorSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageColorSampleCounts)
	x.SampledImageIntegerSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageIntegerSampleCounts)
	x.SampledImageDepthSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageDepthSampleCounts)
	x.SampledImageStencilSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageStencilSampleCounts)
	x.StorageImageSampleCounts = (SampleCountFlags)(x.ref7926795a.storageImageSampleCounts)
	x.MaxSampleMaskWords = (uint32)(x.ref7926795a.maxSampleMaskWords)
	x.TimestampComputeAndGraphics = (Bool32)(x.ref7926795a.timestampComputeAndGraphics)
	x.TimestampPeriod = (float32)(x.ref7926795a.timestampPeriod)
	x.MaxClipDistances = (uint32)(x.ref7926795a.maxClipDistances)
	x.MaxCullDistances = (uint32)(x.ref7926795a.maxCullDistances)
	x.MaxCombinedClipAndCullDistances = (uint32)(x.ref7926795a.maxCombinedClipAndCullDistances)
	x.DiscreteQueuePriorities = (uint32)(x.ref7926795a.discreteQueuePriorities)
	x.PointSizeRange = *(*[2]float32)(unsafe.Pointer(&x.ref7926795a.pointSizeRange))
	x.LineWidthRange = *(*[2]float32)(unsafe.Pointer(&x.ref7926795a.lineWidthRange))
	x.PointSizeGranularity = (float32)(x.ref7926795a.pointSizeGranularity)
	x.LineWidthGranularity = (float32)(x.ref7926795a.lineWidthGranularity)
	x.StrictLines = (Bool32)(x.ref7926795a.strictLines)
	x.StandardSampleLocations = (Bool32)(x.ref7926795a.standardSampleLocations)
	x.OptimalBufferCopyOffsetAlignment = (DeviceSize)(x.ref7926795a.optimalBufferCopyOffsetAlignment)
	x.OptimalBufferCopyRowPitchAlignment = (DeviceSize)(x.ref7926795a.optimalBufferCopyRowPitchAlignment)
	x.NonCoherentAtomSize = (DeviceSize)(x.ref7926795a.nonCoherentAtomSize)
}

// allocPhysicalDeviceSparsePropertiesMemory allocates memory for type C.VkPhysicalDeviceSparseProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSparsePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSparsePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSparsePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSparseProperties{})

// Ref returns a reference.
func (x *PhysicalDeviceSparseProperties) Ref() *C.VkPhysicalDeviceSparseProperties {
	if x == nil {
		return nil
	}
	return x.ref6d7c11e6
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PhysicalDeviceSparseProperties) Free() {
	if x != nil && x.allocs6d7c11e6 != nil {
		x.allocs6d7c11e6.(*cgoAllocMap).Free()
		x.ref6d7c11e6 = nil
	}
}

// NewPhysicalDeviceSparsePropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewPhysicalDeviceSparsePropertiesRef(ref interface{}) *PhysicalDeviceSparseProperties {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PhysicalDeviceSparseProperties)
	obj.ref6d7c11e6 = (*C.VkPhysicalDeviceSparseProperties)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PhysicalDeviceSparseProperties) PassRef() (*C.VkPhysicalDeviceSparseProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6d7c11e6 != nil {
		return x.ref6d7c11e6, nil
	}
	mem6d7c11e6 := allocPhysicalDeviceSparsePropertiesMemory(1)
	ref6d7c11e6 := (*C.VkPhysicalDeviceSparseProperties)(mem6d7c11e6)
	allocs6d7c11e6 := new(cgoAllocMap)
	var cresidencyStandard2DBlockShape_allocs *cgoAllocMap
	ref6d7c11e6.residencyStandard2DBlockShape, cresidencyStandard2DBlockShape_allocs = (C.VkBool32)(x.ResidencyStandard2DBlockShape), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyStandard2DBlockShape_allocs)

	var cresidencyStandard2DMultisampleBlockShape_allocs *cgoAllocMap
	ref6d7c11e6.residencyStandard2DMultisampleBlockShape, cresidencyStandard2DMultisampleBlockShape_allocs = (C.VkBool32)(x.ResidencyStandard2DMultisampleBlockShape), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyStandard2DMultisampleBlockShape_allocs)

	var cresidencyStandard3DBlockShape_allocs *cgoAllocMap
	ref6d7c11e6.residencyStandard3DBlockShape, cresidencyStandard3DBlockShape_allocs = (C.VkBool32)(x.ResidencyStandard3DBlockShape), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyStandard3DBlockShape_allocs)

	var cresidencyAlignedMipSize_allocs *cgoAllocMap
	ref6d7c11e6.residencyAlignedMipSize, cresidencyAlignedMipSize_allocs = (C.VkBool32)(x.ResidencyAlignedMipSize), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyAlignedMipSize_allocs)

	var cresidencyNonResidentStrict_allocs *cgoAllocMap
	ref6d7c11e6.residencyNonResidentStrict, cresidencyNonResidentStrict_allocs = (C.VkBool32)(x.ResidencyNonResidentStrict), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyNonResidentStrict_allocs)

	x.ref6d7c11e6 = ref6d7c11e6
	x.allocs6d7c11e6 = allocs6d7c11e6
	return ref6d7c11e6, allocs6d7c11e6

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PhysicalDeviceSparseProperties) PassValue() (C.VkPhysicalDeviceSparseProperties, *cgoAllocMap) {
	if x.ref6d7c11e6 != nil {
		return *x.ref6d7c11e6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PhysicalDeviceSparseProperties) Deref() {
	if x.ref6d7c11e6 == nil {
		return
	}
	x.ResidencyStandard2DBlockShape = (Bool32)(x.ref6d7c11e6.residencyStandard2DBlockShape)
	x.ResidencyStandard2DMultisampleBlockShape = (Bool32)(x.ref6d7c11e6.residencyStandard2DMultisampleBlockShape)
	x.ResidencyStandard3DBlockShape = (Bool32)(x.ref6d7c11e6.residencyStandard3DBlockShape)
	x.ResidencyAlignedMipSize = (Bool32)(x.ref6d7c11e6.residencyAlignedMipSize)
	x.ResidencyNonResidentStrict = (Bool32)(x.ref6d7c11e6.residencyNonResidentStrict)
}

// allocPhysicalDevicePropertiesMemory allocates memory for type C.VkPhysicalDeviceProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDevicePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceProperties{})

// Ref returns a reference.
func (x *PhysicalDeviceProperties) Ref() *C.VkPhysicalDeviceProperties {
	if x == nil {
		return nil
	}
	return x.ref1080ca9d
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PhysicalDeviceProperties) Free() {
	if x != nil && x.allocs1080ca9d != nil {
		x.allocs1080ca9d.(*cgoAllocMap).Free()
		x.ref1080ca9d = nil
	}
}

// NewPhysicalDevicePropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewPhysicalDevicePropertiesRef(ref interface{}) *PhysicalDeviceProperties {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PhysicalDeviceProperties)
	obj.ref1080ca9d = (*C.VkPhysicalDeviceProperties)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PhysicalDeviceProperties) PassRef() (*C.VkPhysicalDeviceProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1080ca9d != nil {
		return x.ref1080ca9d, nil
	}
	mem1080ca9d := allocPhysicalDevicePropertiesMemory(1)
	ref1080ca9d := (*C.VkPhysicalDeviceProperties)(mem1080ca9d)
	allocs1080ca9d := new(cgoAllocMap)
	var capiVersion_allocs *cgoAllocMap
	ref1080ca9d.apiVersion, capiVersion_allocs = (C.uint32_t)(x.ApiVersion), cgoAllocsUnknown
	allocs1080ca9d.Borrow(capiVersion_allocs)

	var cdriverVersion_allocs *cgoAllocMap
	ref1080ca9d.driverVersion, cdriverVersion_allocs = (C.uint32_t)(x.DriverVersion), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdriverVersion_allocs)

	var cvendorID_allocs *cgoAllocMap
	ref1080ca9d.vendorID, cvendorID_allocs = (C.uint32_t)(x.VendorID), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cvendorID_allocs)

	var cdeviceID_allocs *cgoAllocMap
	ref1080ca9d.deviceID, cdeviceID_allocs = (C.uint32_t)(x.DeviceID), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdeviceID_allocs)

	var cdeviceType_allocs *cgoAllocMap
	ref1080ca9d.deviceType, cdeviceType_allocs = (C.VkPhysicalDeviceType)(x.DeviceType), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdeviceType_allocs)

	var cdeviceName_allocs *cgoAllocMap
	ref1080ca9d.deviceName, cdeviceName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.DeviceName)), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdeviceName_allocs)

	var cpipelineCacheUUID_allocs *cgoAllocMap
	ref1080ca9d.pipelineCacheUUID, cpipelineCacheUUID_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.PipelineCacheUUID)), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cpipelineCacheUUID_allocs)

	var climits_allocs *cgoAllocMap
	ref1080ca9d.limits, climits_allocs = x.Limits.PassValue()
	allocs1080ca9d.Borrow(climits_allocs)

	var csparseProperties_allocs *cgoAllocMap
	ref1080ca9d.sparseProperties, csparseProperties_allocs = x.SparseProperties.PassValue()
	allocs1080ca9d.Borrow(csparseProperties_allocs)

	x.ref1080ca9d = ref1080ca9d
	x.allocs1080ca9d = allocs1080ca9d
	return ref1080ca9d, allocs1080ca9d

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PhysicalDeviceProperties) PassValue() (C.VkPhysicalDeviceProperties, *cgoAllocMap) {
	if x.ref1080ca9d != nil {
		return *x.ref1080ca9d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PhysicalDeviceProperties) Deref() {
	if x.ref1080ca9d == nil {
		return
	}
	x.ApiVersion = (uint32)(x.ref1080ca9d.apiVersion)
	x.DriverVersion = (uint32)(x.ref1080ca9d.driverVersion)
	x.VendorID = (uint32)(x.ref1080ca9d.vendorID)
	x.DeviceID = (uint32)(x.ref1080ca9d.deviceID)
	x.DeviceType = (PhysicalDeviceType)(x.ref1080ca9d.deviceType)
	x.DeviceName = *(*[256]byte)(unsafe.Pointer(&x.ref1080ca9d.deviceName))
	x.PipelineCacheUUID = *(*[16]byte)(unsafe.Pointer(&x.ref1080ca9d.pipelineCacheUUID))
	x.Limits = *NewPhysicalDeviceLimitsRef(&x.ref1080ca9d.limits)
	x.SparseProperties = *NewPhysicalDeviceSparsePropertiesRef(&x.ref1080ca9d.sparseProperties)
}

// allocQueueFamilyPropertiesMemory allocates memory for type C.VkQueueFamilyProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueueFamilyPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueueFamilyPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfQueueFamilyPropertiesValue = unsafe.Sizeof([1]C.VkQueueFamilyProperties{})

// Ref returns a reference.
func (x *QueueFamilyProperties) Ref() *C.VkQueueFamilyProperties {
	if x == nil {
		return nil
	}
	return x.refd538c446
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *QueueFamilyProperties) Free() {
	if x != nil && x.allocsd538c446 != nil {
		x.allocsd538c446.(*cgoAllocMap).Free()
		x.refd538c446 = nil
	}
}

// NewQueueFamilyPropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewQueueFamilyPropertiesRef(ref interface{}) *QueueFamilyProperties {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(QueueFamilyProperties)
	obj.refd538c446 = (*C.VkQueueFamilyProperties)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *QueueFamilyProperties) PassRef() (*C.VkQueueFamilyProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd538c446 != nil {
		return x.refd538c446, nil
	}
	memd538c446 := allocQueueFamilyPropertiesMemory(1)
	refd538c446 := (*C.VkQueueFamilyProperties)(memd538c446)
	allocsd538c446 := new(cgoAllocMap)
	var cqueueFlags_allocs *cgoAllocMap
	refd538c446.queueFlags, cqueueFlags_allocs = (C.VkQueueFlags)(x.QueueFlags), cgoAllocsUnknown
	allocsd538c446.Borrow(cqueueFlags_allocs)

	var cqueueCount_allocs *cgoAllocMap
	refd538c446.queueCount, cqueueCount_allocs = (C.uint32_t)(x.QueueCount), cgoAllocsUnknown
	allocsd538c446.Borrow(cqueueCount_allocs)

	var ctimestampValidBits_allocs *cgoAllocMap
	refd538c446.timestampValidBits, ctimestampValidBits_allocs = (C.uint32_t)(x.TimestampValidBits), cgoAllocsUnknown
	allocsd538c446.Borrow(ctimestampValidBits_allocs)

	var cminImageTransferGranularity_allocs *cgoAllocMap
	refd538c446.minImageTransferGranularity, cminImageTransferGranularity_allocs = x.MinImageTransferGranularity.PassValue()
	allocsd538c446.Borrow(cminImageTransferGranularity_allocs)

	x.refd538c446 = refd538c446
	x.allocsd538c446 = allocsd538c446
	return refd538c446, allocsd538c446

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x QueueFamilyProperties) PassValue() (C.VkQueueFamilyProperties, *cgoAllocMap) {
	if x.refd538c446 != nil {
		return *x.refd538c446, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *QueueFamilyProperties) Deref() {
	if x.refd538c446 == nil {
		return
	}
	x.QueueFlags = (QueueFlags)(x.refd538c446.queueFlags)
	x.QueueCount = (uint32)(x.refd538c446.queueCount)
	x.TimestampValidBits = (uint32)(x.refd538c446.timestampValidBits)
	x.MinImageTransferGranularity = *NewExtent3DRef(&x.refd538c446.minImageTransferGranularity)
}

// allocMemoryTypeMemory allocates memory for type C.VkMemoryType in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryTypeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryTypeValue = unsafe.Sizeof([1]C.VkMemoryType{})

// Ref returns a reference.
func (x *MemoryType) Ref() *C.VkMemoryType {
	if x == nil {
		return nil
	}
	return x.ref2f46e01d
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *MemoryType) Free() {
	if x != nil && x.allocs2f46e01d != nil {
		x.allocs2f46e01d.(*cgoAllocMap).Free()
		x.ref2f46e01d = nil
	}
}

// NewMemoryTypeRef initialises a new struct holding the reference to the originaitng C struct.
func NewMemoryTypeRef(ref interface{}) *MemoryType {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(MemoryType)
	obj.ref2f46e01d = (*C.VkMemoryType)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *MemoryType) PassRef() (*C.VkMemoryType, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f46e01d != nil {
		return x.ref2f46e01d, nil
	}
	mem2f46e01d := allocMemoryTypeMemory(1)
	ref2f46e01d := (*C.VkMemoryType)(mem2f46e01d)
	allocs2f46e01d := new(cgoAllocMap)
	var cpropertyFlags_allocs *cgoAllocMap
	ref2f46e01d.propertyFlags, cpropertyFlags_allocs = (C.VkMemoryPropertyFlags)(x.PropertyFlags), cgoAllocsUnknown
	allocs2f46e01d.Borrow(cpropertyFlags_allocs)

	var cheapIndex_allocs *cgoAllocMap
	ref2f46e01d.heapIndex, cheapIndex_allocs = (C.uint32_t)(x.HeapIndex), cgoAllocsUnknown
	allocs2f46e01d.Borrow(cheapIndex_allocs)

	x.ref2f46e01d = ref2f46e01d
	x.allocs2f46e01d = allocs2f46e01d
	return ref2f46e01d, allocs2f46e01d

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x MemoryType) PassValue() (C.VkMemoryType, *cgoAllocMap) {
	if x.ref2f46e01d != nil {
		return *x.ref2f46e01d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *MemoryType) Deref() {
	if x.ref2f46e01d == nil {
		return
	}
	x.PropertyFlags = (MemoryPropertyFlags)(x.ref2f46e01d.propertyFlags)
	x.HeapIndex = (uint32)(x.ref2f46e01d.heapIndex)
}

// allocMemoryHeapMemory allocates memory for type C.VkMemoryHeap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryHeapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryHeapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryHeapValue = unsafe.Sizeof([1]C.VkMemoryHeap{})

// Ref returns a reference.
func (x *MemoryHeap) Ref() *C.VkMemoryHeap {
	if x == nil {
		return nil
	}
	return x.ref1eb195d5
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *MemoryHeap) Free() {
	if x != nil && x.allocs1eb195d5 != nil {
		x.allocs1eb195d5.(*cgoAllocMap).Free()
		x.ref1eb195d5 = nil
	}
}

// NewMemoryHeapRef initialises a new struct holding the reference to the originaitng C struct.
func NewMemoryHeapRef(ref interface{}) *MemoryHeap {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(MemoryHeap)
	obj.ref1eb195d5 = (*C.VkMemoryHeap)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *MemoryHeap) PassRef() (*C.VkMemoryHeap, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1eb195d5 != nil {
		return x.ref1eb195d5, nil
	}
	mem1eb195d5 := allocMemoryHeapMemory(1)
	ref1eb195d5 := (*C.VkMemoryHeap)(mem1eb195d5)
	allocs1eb195d5 := new(cgoAllocMap)
	var csize_allocs *cgoAllocMap
	ref1eb195d5.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs1eb195d5.Borrow(csize_allocs)

	var cflags_allocs *cgoAllocMap
	ref1eb195d5.flags, cflags_allocs = (C.VkMemoryHeapFlags)(x.Flags), cgoAllocsUnknown
	allocs1eb195d5.Borrow(cflags_allocs)

	x.ref1eb195d5 = ref1eb195d5
	x.allocs1eb195d5 = allocs1eb195d5
	return ref1eb195d5, allocs1eb195d5

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x MemoryHeap) PassValue() (C.VkMemoryHeap, *cgoAllocMap) {
	if x.ref1eb195d5 != nil {
		return *x.ref1eb195d5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *MemoryHeap) Deref() {
	if x.ref1eb195d5 == nil {
		return
	}
	x.Size = (DeviceSize)(x.ref1eb195d5.size)
	x.Flags = (MemoryHeapFlags)(x.ref1eb195d5.flags)
}

// allocPhysicalDeviceMemoryPropertiesMemory allocates memory for type C.VkPhysicalDeviceMemoryProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMemoryPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMemoryPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMemoryPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMemoryProperties{})

// allocA32MemoryTypeMemory allocates memory for type [32]C.VkMemoryType in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA32MemoryTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA32MemoryTypeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA32MemoryTypeValue = unsafe.Sizeof([1][32]C.VkMemoryType{})

// unpackA32MemoryType transforms a sliced Go data structure into plain C format.
func unpackA32MemoryType(x [32]MemoryType) (unpacked [32]C.VkMemoryType, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkMemoryType) {
		go allocs.Free()
	})

	mem0 := allocA32MemoryTypeMemory(1)
	allocs.Add(mem0)
	v0 := (*[32]C.VkMemoryType)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[32]C.VkMemoryType)(mem0)
	return
}

// allocA16MemoryHeapMemory allocates memory for type [16]C.VkMemoryHeap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA16MemoryHeapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA16MemoryHeapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA16MemoryHeapValue = unsafe.Sizeof([1][16]C.VkMemoryHeap{})

// unpackA16MemoryHeap transforms a sliced Go data structure into plain C format.
func unpackA16MemoryHeap(x [16]MemoryHeap) (unpacked [16]C.VkMemoryHeap, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkMemoryHeap) {
		go allocs.Free()
	})

	mem0 := allocA16MemoryHeapMemory(1)
	allocs.Add(mem0)
	v0 := (*[16]C.VkMemoryHeap)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[16]C.VkMemoryHeap)(mem0)
	return
}

// packA32MemoryType reads sliced Go data structure out from plain C format.
func packA32MemoryType(v *[32]MemoryType, ptr0 *[32]C.VkMemoryType) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewMemoryTypeRef(unsafe.Pointer(&ptr1))
	}
}

// packA16MemoryHeap reads sliced Go data structure out from plain C format.
func packA16MemoryHeap(v *[16]MemoryHeap, ptr0 *[16]C.VkMemoryHeap) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewMemoryHeapRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *PhysicalDeviceMemoryProperties) Ref() *C.VkPhysicalDeviceMemoryProperties {
	if x == nil {
		return nil
	}
	return x.ref3aabb5fd
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PhysicalDeviceMemoryProperties) Free() {
	if x != nil && x.allocs3aabb5fd != nil {
		x.allocs3aabb5fd.(*cgoAllocMap).Free()
		x.ref3aabb5fd = nil
	}
}

// NewPhysicalDeviceMemoryPropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewPhysicalDeviceMemoryPropertiesRef(ref interface{}) *PhysicalDeviceMemoryProperties {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PhysicalDeviceMemoryProperties)
	obj.ref3aabb5fd = (*C.VkPhysicalDeviceMemoryProperties)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PhysicalDeviceMemoryProperties) PassRef() (*C.VkPhysicalDeviceMemoryProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3aabb5fd != nil {
		return x.ref3aabb5fd, nil
	}
	mem3aabb5fd := allocPhysicalDeviceMemoryPropertiesMemory(1)
	ref3aabb5fd := (*C.VkPhysicalDeviceMemoryProperties)(mem3aabb5fd)
	allocs3aabb5fd := new(cgoAllocMap)
	var cmemoryTypeCount_allocs *cgoAllocMap
	ref3aabb5fd.memoryTypeCount, cmemoryTypeCount_allocs = (C.uint32_t)(x.MemoryTypeCount), cgoAllocsUnknown
	allocs3aabb5fd.Borrow(cmemoryTypeCount_allocs)

	var cmemoryTypes_allocs *cgoAllocMap
	ref3aabb5fd.memoryTypes, cmemoryTypes_allocs = unpackA32MemoryType(x.MemoryTypes)
	allocs3aabb5fd.Borrow(cmemoryTypes_allocs)

	var cmemoryHeapCount_allocs *cgoAllocMap
	ref3aabb5fd.memoryHeapCount, cmemoryHeapCount_allocs = (C.uint32_t)(x.MemoryHeapCount), cgoAllocsUnknown
	allocs3aabb5fd.Borrow(cmemoryHeapCount_allocs)

	var cmemoryHeaps_allocs *cgoAllocMap
	ref3aabb5fd.memoryHeaps, cmemoryHeaps_allocs = unpackA16MemoryHeap(x.MemoryHeaps)
	allocs3aabb5fd.Borrow(cmemoryHeaps_allocs)

	x.ref3aabb5fd = ref3aabb5fd
	x.allocs3aabb5fd = allocs3aabb5fd
	return ref3aabb5fd, allocs3aabb5fd

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PhysicalDeviceMemoryProperties) PassValue() (C.VkPhysicalDeviceMemoryProperties, *cgoAllocMap) {
	if x.ref3aabb5fd != nil {
		return *x.ref3aabb5fd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PhysicalDeviceMemoryProperties) Deref() {
	if x.ref3aabb5fd == nil {
		return
	}
	x.MemoryTypeCount = (uint32)(x.ref3aabb5fd.memoryTypeCount)
	packA32MemoryType(&x.MemoryTypes, (*[32]C.VkMemoryType)(unsafe.Pointer(&x.ref3aabb5fd.memoryTypes)))
	x.MemoryHeapCount = (uint32)(x.ref3aabb5fd.memoryHeapCount)
	packA16MemoryHeap(&x.MemoryHeaps, (*[16]C.VkMemoryHeap)(unsafe.Pointer(&x.ref3aabb5fd.memoryHeaps)))
}

// allocDeviceQueueCreateInfoMemory allocates memory for type C.VkDeviceQueueCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceQueueCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceQueueCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceQueueCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceQueueCreateInfo{})

// Ref returns a reference.
func (x *DeviceQueueCreateInfo) Ref() *C.VkDeviceQueueCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref6087b30d
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DeviceQueueCreateInfo) Free() {
	if x != nil && x.allocs6087b30d != nil {
		x.allocs6087b30d.(*cgoAllocMap).Free()
		x.ref6087b30d = nil
	}
}

// NewDeviceQueueCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDeviceQueueCreateInfoRef(ref interface{}) *DeviceQueueCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DeviceQueueCreateInfo)
	obj.ref6087b30d = (*C.VkDeviceQueueCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DeviceQueueCreateInfo) PassRef() (*C.VkDeviceQueueCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6087b30d != nil {
		return x.ref6087b30d, nil
	}
	mem6087b30d := allocDeviceQueueCreateInfoMemory(1)
	ref6087b30d := (*C.VkDeviceQueueCreateInfo)(mem6087b30d)
	allocs6087b30d := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref6087b30d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6087b30d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6087b30d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6087b30d.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref6087b30d.flags, cflags_allocs = (C.VkDeviceQueueCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs6087b30d.Borrow(cflags_allocs)

	var cqueueFamilyIndex_allocs *cgoAllocMap
	ref6087b30d.queueFamilyIndex, cqueueFamilyIndex_allocs = (C.uint32_t)(x.QueueFamilyIndex), cgoAllocsUnknown
	allocs6087b30d.Borrow(cqueueFamilyIndex_allocs)

	var cqueueCount_allocs *cgoAllocMap
	ref6087b30d.queueCount, cqueueCount_allocs = (C.uint32_t)(x.QueueCount), cgoAllocsUnknown
	allocs6087b30d.Borrow(cqueueCount_allocs)

	var cpQueuePriorities_allocs *cgoAllocMap
	ref6087b30d.pQueuePriorities, cpQueuePriorities_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueuePriorities)).Data)), cgoAllocsUnknown
	allocs6087b30d.Borrow(cpQueuePriorities_allocs)

	x.ref6087b30d = ref6087b30d
	x.allocs6087b30d = allocs6087b30d
	return ref6087b30d, allocs6087b30d

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DeviceQueueCreateInfo) PassValue() (C.VkDeviceQueueCreateInfo, *cgoAllocMap) {
	if x.ref6087b30d != nil {
		return *x.ref6087b30d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DeviceQueueCreateInfo) Deref() {
	if x.ref6087b30d == nil {
		return
	}
	x.SType = (StructureType)(x.ref6087b30d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6087b30d.pNext))
	x.Flags = (DeviceQueueCreateFlags)(x.ref6087b30d.flags)
	x.QueueFamilyIndex = (uint32)(x.ref6087b30d.queueFamilyIndex)
	x.QueueCount = (uint32)(x.ref6087b30d.queueCount)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.PQueuePriorities))
	hxfc4425b.Data = uintptr(unsafe.Pointer(x.ref6087b30d.pQueuePriorities))
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

}

// allocDeviceCreateInfoMemory allocates memory for type C.VkDeviceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceCreateInfo{})

// unpackSDeviceQueueCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSDeviceQueueCreateInfo(x []DeviceQueueCreateInfo) (unpacked *C.VkDeviceQueueCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDeviceQueueCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDeviceQueueCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDeviceQueueCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDeviceQueueCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPhysicalDeviceFeatures transforms a sliced Go data structure into plain C format.
func unpackSPhysicalDeviceFeatures(x []PhysicalDeviceFeatures) (unpacked *C.VkPhysicalDeviceFeatures, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceFeatures) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceFeaturesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceFeatures)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceFeatures)(unsafe.Pointer(h.Data))
	return
}

// packSDeviceQueueCreateInfo reads sliced Go data structure out from plain C format.
func packSDeviceQueueCreateInfo(v []DeviceQueueCreateInfo, ptr0 *C.VkDeviceQueueCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDeviceQueueCreateInfoValue]C.VkDeviceQueueCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceQueueCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPhysicalDeviceFeatures reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceFeatures(v []PhysicalDeviceFeatures, ptr0 *C.VkPhysicalDeviceFeatures) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceFeaturesValue]C.VkPhysicalDeviceFeatures)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceFeaturesRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *DeviceCreateInfo) Ref() *C.VkDeviceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc0d8b997
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DeviceCreateInfo) Free() {
	if x != nil && x.allocsc0d8b997 != nil {
		x.allocsc0d8b997.(*cgoAllocMap).Free()
		x.refc0d8b997 = nil
	}
}

// NewDeviceCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDeviceCreateInfoRef(ref interface{}) *DeviceCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DeviceCreateInfo)
	obj.refc0d8b997 = (*C.VkDeviceCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DeviceCreateInfo) PassRef() (*C.VkDeviceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0d8b997 != nil {
		return x.refc0d8b997, nil
	}
	memc0d8b997 := allocDeviceCreateInfoMemory(1)
	refc0d8b997 := (*C.VkDeviceCreateInfo)(memc0d8b997)
	allocsc0d8b997 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refc0d8b997.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc0d8b997.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc0d8b997.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc0d8b997.flags, cflags_allocs = (C.VkDeviceCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cflags_allocs)

	var cqueueCreateInfoCount_allocs *cgoAllocMap
	refc0d8b997.queueCreateInfoCount, cqueueCreateInfoCount_allocs = (C.uint32_t)(x.QueueCreateInfoCount), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cqueueCreateInfoCount_allocs)

	var cpQueueCreateInfos_allocs *cgoAllocMap
	refc0d8b997.pQueueCreateInfos, cpQueueCreateInfos_allocs = unpackSDeviceQueueCreateInfo(x.PQueueCreateInfos)
	allocsc0d8b997.Borrow(cpQueueCreateInfos_allocs)

	var cenabledLayerCount_allocs *cgoAllocMap
	refc0d8b997.enabledLayerCount, cenabledLayerCount_allocs = (C.uint32_t)(x.EnabledLayerCount), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cenabledLayerCount_allocs)

	var cppEnabledLayerNames_allocs *cgoAllocMap
	refc0d8b997.ppEnabledLayerNames, cppEnabledLayerNames_allocs = unpackSString(x.PpEnabledLayerNames)
	allocsc0d8b997.Borrow(cppEnabledLayerNames_allocs)

	var cenabledExtensionCount_allocs *cgoAllocMap
	refc0d8b997.enabledExtensionCount, cenabledExtensionCount_allocs = (C.uint32_t)(x.EnabledExtensionCount), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cenabledExtensionCount_allocs)

	var cppEnabledExtensionNames_allocs *cgoAllocMap
	refc0d8b997.ppEnabledExtensionNames, cppEnabledExtensionNames_allocs = unpackSString(x.PpEnabledExtensionNames)
	allocsc0d8b997.Borrow(cppEnabledExtensionNames_allocs)

	var cpEnabledFeatures_allocs *cgoAllocMap
	refc0d8b997.pEnabledFeatures, cpEnabledFeatures_allocs = unpackSPhysicalDeviceFeatures(x.PEnabledFeatures)
	allocsc0d8b997.Borrow(cpEnabledFeatures_allocs)

	x.refc0d8b997 = refc0d8b997
	x.allocsc0d8b997 = allocsc0d8b997
	return refc0d8b997, allocsc0d8b997

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DeviceCreateInfo) PassValue() (C.VkDeviceCreateInfo, *cgoAllocMap) {
	if x.refc0d8b997 != nil {
		return *x.refc0d8b997, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DeviceCreateInfo) Deref() {
	if x.refc0d8b997 == nil {
		return
	}
	x.SType = (StructureType)(x.refc0d8b997.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc0d8b997.pNext))
	x.Flags = (DeviceCreateFlags)(x.refc0d8b997.flags)
	x.QueueCreateInfoCount = (uint32)(x.refc0d8b997.queueCreateInfoCount)
	packSDeviceQueueCreateInfo(x.PQueueCreateInfos, x.refc0d8b997.pQueueCreateInfos)
	x.EnabledLayerCount = (uint32)(x.refc0d8b997.enabledLayerCount)
	packSString(x.PpEnabledLayerNames, x.refc0d8b997.ppEnabledLayerNames)
	x.EnabledExtensionCount = (uint32)(x.refc0d8b997.enabledExtensionCount)
	packSString(x.PpEnabledExtensionNames, x.refc0d8b997.ppEnabledExtensionNames)
	packSPhysicalDeviceFeatures(x.PEnabledFeatures, x.refc0d8b997.pEnabledFeatures)
}

// allocExtensionPropertiesMemory allocates memory for type C.VkExtensionProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtensionPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtensionPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExtensionPropertiesValue = unsafe.Sizeof([1]C.VkExtensionProperties{})

// Ref returns a reference.
func (x *ExtensionProperties) Ref() *C.VkExtensionProperties {
	if x == nil {
		return nil
	}
	return x.ref2f001956
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ExtensionProperties) Free() {
	if x != nil && x.allocs2f001956 != nil {
		x.allocs2f001956.(*cgoAllocMap).Free()
		x.ref2f001956 = nil
	}
}

// NewExtensionPropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewExtensionPropertiesRef(ref interface{}) *ExtensionProperties {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ExtensionProperties)
	obj.ref2f001956 = (*C.VkExtensionProperties)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ExtensionProperties) PassRef() (*C.VkExtensionProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f001956 != nil {
		return x.ref2f001956, nil
	}
	mem2f001956 := allocExtensionPropertiesMemory(1)
	ref2f001956 := (*C.VkExtensionProperties)(mem2f001956)
	allocs2f001956 := new(cgoAllocMap)
	var cextensionName_allocs *cgoAllocMap
	ref2f001956.extensionName, cextensionName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.ExtensionName)), cgoAllocsUnknown
	allocs2f001956.Borrow(cextensionName_allocs)

	var cspecVersion_allocs *cgoAllocMap
	ref2f001956.specVersion, cspecVersion_allocs = (C.uint32_t)(x.SpecVersion), cgoAllocsUnknown
	allocs2f001956.Borrow(cspecVersion_allocs)

	x.ref2f001956 = ref2f001956
	x.allocs2f001956 = allocs2f001956
	return ref2f001956, allocs2f001956

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ExtensionProperties) PassValue() (C.VkExtensionProperties, *cgoAllocMap) {
	if x.ref2f001956 != nil {
		return *x.ref2f001956, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ExtensionProperties) Deref() {
	if x.ref2f001956 == nil {
		return
	}
	x.ExtensionName = *(*[256]byte)(unsafe.Pointer(&x.ref2f001956.extensionName))
	x.SpecVersion = (uint32)(x.ref2f001956.specVersion)
}

// allocLayerPropertiesMemory allocates memory for type C.VkLayerProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLayerPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLayerPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLayerPropertiesValue = unsafe.Sizeof([1]C.VkLayerProperties{})

// Ref returns a reference.
func (x *LayerProperties) Ref() *C.VkLayerProperties {
	if x == nil {
		return nil
	}
	return x.refd9407ce7
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *LayerProperties) Free() {
	if x != nil && x.allocsd9407ce7 != nil {
		x.allocsd9407ce7.(*cgoAllocMap).Free()
		x.refd9407ce7 = nil
	}
}

// NewLayerPropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewLayerPropertiesRef(ref interface{}) *LayerProperties {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(LayerProperties)
	obj.refd9407ce7 = (*C.VkLayerProperties)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *LayerProperties) PassRef() (*C.VkLayerProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9407ce7 != nil {
		return x.refd9407ce7, nil
	}
	memd9407ce7 := allocLayerPropertiesMemory(1)
	refd9407ce7 := (*C.VkLayerProperties)(memd9407ce7)
	allocsd9407ce7 := new(cgoAllocMap)
	var clayerName_allocs *cgoAllocMap
	refd9407ce7.layerName, clayerName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.LayerName)), cgoAllocsUnknown
	allocsd9407ce7.Borrow(clayerName_allocs)

	var cspecVersion_allocs *cgoAllocMap
	refd9407ce7.specVersion, cspecVersion_allocs = (C.uint32_t)(x.SpecVersion), cgoAllocsUnknown
	allocsd9407ce7.Borrow(cspecVersion_allocs)

	var cimplementationVersion_allocs *cgoAllocMap
	refd9407ce7.implementationVersion, cimplementationVersion_allocs = (C.uint32_t)(x.ImplementationVersion), cgoAllocsUnknown
	allocsd9407ce7.Borrow(cimplementationVersion_allocs)

	var cdescription_allocs *cgoAllocMap
	refd9407ce7.description, cdescription_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Description)), cgoAllocsUnknown
	allocsd9407ce7.Borrow(cdescription_allocs)

	x.refd9407ce7 = refd9407ce7
	x.allocsd9407ce7 = allocsd9407ce7
	return refd9407ce7, allocsd9407ce7

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x LayerProperties) PassValue() (C.VkLayerProperties, *cgoAllocMap) {
	if x.refd9407ce7 != nil {
		return *x.refd9407ce7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *LayerProperties) Deref() {
	if x.refd9407ce7 == nil {
		return
	}
	x.LayerName = *(*[256]byte)(unsafe.Pointer(&x.refd9407ce7.layerName))
	x.SpecVersion = (uint32)(x.refd9407ce7.specVersion)
	x.ImplementationVersion = (uint32)(x.refd9407ce7.implementationVersion)
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.refd9407ce7.description))
}

// allocSubmitInfoMemory allocates memory for type C.VkSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubmitInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubmitInfoValue = unsafe.Sizeof([1]C.VkSubmitInfo{})

// Ref returns a reference.
func (x *SubmitInfo) Ref() *C.VkSubmitInfo {
	if x == nil {
		return nil
	}
	return x.ref22884025
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SubmitInfo) Free() {
	if x != nil && x.allocs22884025 != nil {
		x.allocs22884025.(*cgoAllocMap).Free()
		x.ref22884025 = nil
	}
}

// NewSubmitInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewSubmitInfoRef(ref interface{}) *SubmitInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SubmitInfo)
	obj.ref22884025 = (*C.VkSubmitInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SubmitInfo) PassRef() (*C.VkSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref22884025 != nil {
		return x.ref22884025, nil
	}
	mem22884025 := allocSubmitInfoMemory(1)
	ref22884025 := (*C.VkSubmitInfo)(mem22884025)
	allocs22884025 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref22884025.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs22884025.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref22884025.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs22884025.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	ref22884025.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocs22884025.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphores_allocs *cgoAllocMap
	ref22884025.pWaitSemaphores, cpWaitSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpWaitSemaphores_allocs)

	var cpWaitDstStageMask_allocs *cgoAllocMap
	ref22884025.pWaitDstStageMask, cpWaitDstStageMask_allocs = (*C.VkPipelineStageFlags)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitDstStageMask)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpWaitDstStageMask_allocs)

	var ccommandBufferCount_allocs *cgoAllocMap
	ref22884025.commandBufferCount, ccommandBufferCount_allocs = (C.uint32_t)(x.CommandBufferCount), cgoAllocsUnknown
	allocs22884025.Borrow(ccommandBufferCount_allocs)

	var cpCommandBuffers_allocs *cgoAllocMap
	ref22884025.pCommandBuffers, cpCommandBuffers_allocs = (*C.VkCommandBuffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCommandBuffers)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpCommandBuffers_allocs)

	var csignalSemaphoreCount_allocs *cgoAllocMap
	ref22884025.signalSemaphoreCount, csignalSemaphoreCount_allocs = (C.uint32_t)(x.SignalSemaphoreCount), cgoAllocsUnknown
	allocs22884025.Borrow(csignalSemaphoreCount_allocs)

	var cpSignalSemaphores_allocs *cgoAllocMap
	ref22884025.pSignalSemaphores, cpSignalSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpSignalSemaphores_allocs)

	x.ref22884025 = ref22884025
	x.allocs22884025 = allocs22884025
	return ref22884025, allocs22884025

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SubmitInfo) PassValue() (C.VkSubmitInfo, *cgoAllocMap) {
	if x.ref22884025 != nil {
		return *x.ref22884025, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SubmitInfo) Deref() {
	if x.ref22884025 == nil {
		return
	}
	x.SType = (StructureType)(x.ref22884025.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref22884025.pNext))
	x.WaitSemaphoreCount = (uint32)(x.ref22884025.waitSemaphoreCount)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxf95e7c8.Data = uintptr(unsafe.Pointer(x.ref22884025.pWaitSemaphores))
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.PWaitDstStageMask))
	hxff2234b.Data = uintptr(unsafe.Pointer(x.ref22884025.pWaitDstStageMask))
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	x.CommandBufferCount = (uint32)(x.ref22884025.commandBufferCount)
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.PCommandBuffers))
	hxff73280.Data = uintptr(unsafe.Pointer(x.ref22884025.pCommandBuffers))
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	x.SignalSemaphoreCount = (uint32)(x.ref22884025.signalSemaphoreCount)
	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores))
	hxfa9955c.Data = uintptr(unsafe.Pointer(x.ref22884025.pSignalSemaphores))
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

}

// allocMemoryAllocateInfoMemory allocates memory for type C.VkMemoryAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryAllocateInfoValue = unsafe.Sizeof([1]C.VkMemoryAllocateInfo{})

// Ref returns a reference.
func (x *MemoryAllocateInfo) Ref() *C.VkMemoryAllocateInfo {
	if x == nil {
		return nil
	}
	return x.ref31032b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *MemoryAllocateInfo) Free() {
	if x != nil && x.allocs31032b != nil {
		x.allocs31032b.(*cgoAllocMap).Free()
		x.ref31032b = nil
	}
}

// NewMemoryAllocateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewMemoryAllocateInfoRef(ref interface{}) *MemoryAllocateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(MemoryAllocateInfo)
	obj.ref31032b = (*C.VkMemoryAllocateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *MemoryAllocateInfo) PassRef() (*C.VkMemoryAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref31032b != nil {
		return x.ref31032b, nil
	}
	mem31032b := allocMemoryAllocateInfoMemory(1)
	ref31032b := (*C.VkMemoryAllocateInfo)(mem31032b)
	allocs31032b := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref31032b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs31032b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref31032b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs31032b.Borrow(cpNext_allocs)

	var callocationSize_allocs *cgoAllocMap
	ref31032b.allocationSize, callocationSize_allocs = (C.VkDeviceSize)(x.AllocationSize), cgoAllocsUnknown
	allocs31032b.Borrow(callocationSize_allocs)

	var cmemoryTypeIndex_allocs *cgoAllocMap
	ref31032b.memoryTypeIndex, cmemoryTypeIndex_allocs = (C.uint32_t)(x.MemoryTypeIndex), cgoAllocsUnknown
	allocs31032b.Borrow(cmemoryTypeIndex_allocs)

	x.ref31032b = ref31032b
	x.allocs31032b = allocs31032b
	return ref31032b, allocs31032b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x MemoryAllocateInfo) PassValue() (C.VkMemoryAllocateInfo, *cgoAllocMap) {
	if x.ref31032b != nil {
		return *x.ref31032b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *MemoryAllocateInfo) Deref() {
	if x.ref31032b == nil {
		return
	}
	x.SType = (StructureType)(x.ref31032b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref31032b.pNext))
	x.AllocationSize = (DeviceSize)(x.ref31032b.allocationSize)
	x.MemoryTypeIndex = (uint32)(x.ref31032b.memoryTypeIndex)
}

// allocMappedMemoryRangeMemory allocates memory for type C.VkMappedMemoryRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMappedMemoryRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMappedMemoryRangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMappedMemoryRangeValue = unsafe.Sizeof([1]C.VkMappedMemoryRange{})

// Ref returns a reference.
func (x *MappedMemoryRange) Ref() *C.VkMappedMemoryRange {
	if x == nil {
		return nil
	}
	return x.ref42a37320
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *MappedMemoryRange) Free() {
	if x != nil && x.allocs42a37320 != nil {
		x.allocs42a37320.(*cgoAllocMap).Free()
		x.ref42a37320 = nil
	}
}

// NewMappedMemoryRangeRef initialises a new struct holding the reference to the originaitng C struct.
func NewMappedMemoryRangeRef(ref interface{}) *MappedMemoryRange {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(MappedMemoryRange)
	obj.ref42a37320 = (*C.VkMappedMemoryRange)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *MappedMemoryRange) PassRef() (*C.VkMappedMemoryRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref42a37320 != nil {
		return x.ref42a37320, nil
	}
	mem42a37320 := allocMappedMemoryRangeMemory(1)
	ref42a37320 := (*C.VkMappedMemoryRange)(mem42a37320)
	allocs42a37320 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref42a37320.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs42a37320.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref42a37320.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs42a37320.Borrow(cpNext_allocs)

	var cmemory_allocs *cgoAllocMap
	ref42a37320.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs42a37320.Borrow(cmemory_allocs)

	var coffset_allocs *cgoAllocMap
	ref42a37320.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs42a37320.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref42a37320.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs42a37320.Borrow(csize_allocs)

	x.ref42a37320 = ref42a37320
	x.allocs42a37320 = allocs42a37320
	return ref42a37320, allocs42a37320

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x MappedMemoryRange) PassValue() (C.VkMappedMemoryRange, *cgoAllocMap) {
	if x.ref42a37320 != nil {
		return *x.ref42a37320, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *MappedMemoryRange) Deref() {
	if x.ref42a37320 == nil {
		return
	}
	x.SType = (StructureType)(x.ref42a37320.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref42a37320.pNext))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref42a37320.memory))
	x.Offset = (DeviceSize)(x.ref42a37320.offset)
	x.Size = (DeviceSize)(x.ref42a37320.size)
}

// allocMemoryRequirementsMemory allocates memory for type C.VkMemoryRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryRequirementsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryRequirementsValue = unsafe.Sizeof([1]C.VkMemoryRequirements{})

// Ref returns a reference.
func (x *MemoryRequirements) Ref() *C.VkMemoryRequirements {
	if x == nil {
		return nil
	}
	return x.ref5259fc6b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *MemoryRequirements) Free() {
	if x != nil && x.allocs5259fc6b != nil {
		x.allocs5259fc6b.(*cgoAllocMap).Free()
		x.ref5259fc6b = nil
	}
}

// NewMemoryRequirementsRef initialises a new struct holding the reference to the originaitng C struct.
func NewMemoryRequirementsRef(ref interface{}) *MemoryRequirements {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(MemoryRequirements)
	obj.ref5259fc6b = (*C.VkMemoryRequirements)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *MemoryRequirements) PassRef() (*C.VkMemoryRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5259fc6b != nil {
		return x.ref5259fc6b, nil
	}
	mem5259fc6b := allocMemoryRequirementsMemory(1)
	ref5259fc6b := (*C.VkMemoryRequirements)(mem5259fc6b)
	allocs5259fc6b := new(cgoAllocMap)
	var csize_allocs *cgoAllocMap
	ref5259fc6b.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs5259fc6b.Borrow(csize_allocs)

	var calignment_allocs *cgoAllocMap
	ref5259fc6b.alignment, calignment_allocs = (C.VkDeviceSize)(x.Alignment), cgoAllocsUnknown
	allocs5259fc6b.Borrow(calignment_allocs)

	var cmemoryTypeBits_allocs *cgoAllocMap
	ref5259fc6b.memoryTypeBits, cmemoryTypeBits_allocs = (C.uint32_t)(x.MemoryTypeBits), cgoAllocsUnknown
	allocs5259fc6b.Borrow(cmemoryTypeBits_allocs)

	x.ref5259fc6b = ref5259fc6b
	x.allocs5259fc6b = allocs5259fc6b
	return ref5259fc6b, allocs5259fc6b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x MemoryRequirements) PassValue() (C.VkMemoryRequirements, *cgoAllocMap) {
	if x.ref5259fc6b != nil {
		return *x.ref5259fc6b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *MemoryRequirements) Deref() {
	if x.ref5259fc6b == nil {
		return
	}
	x.Size = (DeviceSize)(x.ref5259fc6b.size)
	x.Alignment = (DeviceSize)(x.ref5259fc6b.alignment)
	x.MemoryTypeBits = (uint32)(x.ref5259fc6b.memoryTypeBits)
}

// allocSparseImageFormatPropertiesMemory allocates memory for type C.VkSparseImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkSparseImageFormatProperties{})

// Ref returns a reference.
func (x *SparseImageFormatProperties) Ref() *C.VkSparseImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.ref2c12cf44
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SparseImageFormatProperties) Free() {
	if x != nil && x.allocs2c12cf44 != nil {
		x.allocs2c12cf44.(*cgoAllocMap).Free()
		x.ref2c12cf44 = nil
	}
}

// NewSparseImageFormatPropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewSparseImageFormatPropertiesRef(ref interface{}) *SparseImageFormatProperties {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SparseImageFormatProperties)
	obj.ref2c12cf44 = (*C.VkSparseImageFormatProperties)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SparseImageFormatProperties) PassRef() (*C.VkSparseImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2c12cf44 != nil {
		return x.ref2c12cf44, nil
	}
	mem2c12cf44 := allocSparseImageFormatPropertiesMemory(1)
	ref2c12cf44 := (*C.VkSparseImageFormatProperties)(mem2c12cf44)
	allocs2c12cf44 := new(cgoAllocMap)
	var caspectMask_allocs *cgoAllocMap
	ref2c12cf44.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs2c12cf44.Borrow(caspectMask_allocs)

	var cimageGranularity_allocs *cgoAllocMap
	ref2c12cf44.imageGranularity, cimageGranularity_allocs = x.ImageGranularity.PassValue()
	allocs2c12cf44.Borrow(cimageGranularity_allocs)

	var cflags_allocs *cgoAllocMap
	ref2c12cf44.flags, cflags_allocs = (C.VkSparseImageFormatFlags)(x.Flags), cgoAllocsUnknown
	allocs2c12cf44.Borrow(cflags_allocs)

	x.ref2c12cf44 = ref2c12cf44
	x.allocs2c12cf44 = allocs2c12cf44
	return ref2c12cf44, allocs2c12cf44

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SparseImageFormatProperties) PassValue() (C.VkSparseImageFormatProperties, *cgoAllocMap) {
	if x.ref2c12cf44 != nil {
		return *x.ref2c12cf44, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SparseImageFormatProperties) Deref() {
	if x.ref2c12cf44 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.ref2c12cf44.aspectMask)
	x.ImageGranularity = *NewExtent3DRef(&x.ref2c12cf44.imageGranularity)
	x.Flags = (SparseImageFormatFlags)(x.ref2c12cf44.flags)
}

// allocSparseImageMemoryRequirementsMemory allocates memory for type C.VkSparseImageMemoryRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryRequirementsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageMemoryRequirementsValue = unsafe.Sizeof([1]C.VkSparseImageMemoryRequirements{})

// Ref returns a reference.
func (x *SparseImageMemoryRequirements) Ref() *C.VkSparseImageMemoryRequirements {
	if x == nil {
		return nil
	}
	return x.ref685a2323
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SparseImageMemoryRequirements) Free() {
	if x != nil && x.allocs685a2323 != nil {
		x.allocs685a2323.(*cgoAllocMap).Free()
		x.ref685a2323 = nil
	}
}

// NewSparseImageMemoryRequirementsRef initialises a new struct holding the reference to the originaitng C struct.
func NewSparseImageMemoryRequirementsRef(ref interface{}) *SparseImageMemoryRequirements {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SparseImageMemoryRequirements)
	obj.ref685a2323 = (*C.VkSparseImageMemoryRequirements)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SparseImageMemoryRequirements) PassRef() (*C.VkSparseImageMemoryRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref685a2323 != nil {
		return x.ref685a2323, nil
	}
	mem685a2323 := allocSparseImageMemoryRequirementsMemory(1)
	ref685a2323 := (*C.VkSparseImageMemoryRequirements)(mem685a2323)
	allocs685a2323 := new(cgoAllocMap)
	var cformatProperties_allocs *cgoAllocMap
	ref685a2323.formatProperties, cformatProperties_allocs = x.FormatProperties.PassValue()
	allocs685a2323.Borrow(cformatProperties_allocs)

	var cimageMipTailFirstLod_allocs *cgoAllocMap
	ref685a2323.imageMipTailFirstLod, cimageMipTailFirstLod_allocs = (C.uint32_t)(x.ImageMipTailFirstLod), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailFirstLod_allocs)

	var cimageMipTailSize_allocs *cgoAllocMap
	ref685a2323.imageMipTailSize, cimageMipTailSize_allocs = (C.VkDeviceSize)(x.ImageMipTailSize), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailSize_allocs)

	var cimageMipTailOffset_allocs *cgoAllocMap
	ref685a2323.imageMipTailOffset, cimageMipTailOffset_allocs = (C.VkDeviceSize)(x.ImageMipTailOffset), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailOffset_allocs)

	var cimageMipTailStride_allocs *cgoAllocMap
	ref685a2323.imageMipTailStride, cimageMipTailStride_allocs = (C.VkDeviceSize)(x.ImageMipTailStride), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailStride_allocs)

	x.ref685a2323 = ref685a2323
	x.allocs685a2323 = allocs685a2323
	return ref685a2323, allocs685a2323

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SparseImageMemoryRequirements) PassValue() (C.VkSparseImageMemoryRequirements, *cgoAllocMap) {
	if x.ref685a2323 != nil {
		return *x.ref685a2323, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SparseImageMemoryRequirements) Deref() {
	if x.ref685a2323 == nil {
		return
	}
	x.FormatProperties = *NewSparseImageFormatPropertiesRef(&x.ref685a2323.formatProperties)
	x.ImageMipTailFirstLod = (uint32)(x.ref685a2323.imageMipTailFirstLod)
	x.ImageMipTailSize = (DeviceSize)(x.ref685a2323.imageMipTailSize)
	x.ImageMipTailOffset = (DeviceSize)(x.ref685a2323.imageMipTailOffset)
	x.ImageMipTailStride = (DeviceSize)(x.ref685a2323.imageMipTailStride)
}

// allocSparseMemoryBindMemory allocates memory for type C.VkSparseMemoryBind in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseMemoryBindMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseMemoryBindValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseMemoryBindValue = unsafe.Sizeof([1]C.VkSparseMemoryBind{})

// Ref returns a reference.
func (x *SparseMemoryBind) Ref() *C.VkSparseMemoryBind {
	if x == nil {
		return nil
	}
	return x.ref5bf418e8
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SparseMemoryBind) Free() {
	if x != nil && x.allocs5bf418e8 != nil {
		x.allocs5bf418e8.(*cgoAllocMap).Free()
		x.ref5bf418e8 = nil
	}
}

// NewSparseMemoryBindRef initialises a new struct holding the reference to the originaitng C struct.
func NewSparseMemoryBindRef(ref interface{}) *SparseMemoryBind {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SparseMemoryBind)
	obj.ref5bf418e8 = (*C.VkSparseMemoryBind)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SparseMemoryBind) PassRef() (*C.VkSparseMemoryBind, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5bf418e8 != nil {
		return x.ref5bf418e8, nil
	}
	mem5bf418e8 := allocSparseMemoryBindMemory(1)
	ref5bf418e8 := (*C.VkSparseMemoryBind)(mem5bf418e8)
	allocs5bf418e8 := new(cgoAllocMap)
	var cresourceOffset_allocs *cgoAllocMap
	ref5bf418e8.resourceOffset, cresourceOffset_allocs = (C.VkDeviceSize)(x.ResourceOffset), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cresourceOffset_allocs)

	var csize_allocs *cgoAllocMap
	ref5bf418e8.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs5bf418e8.Borrow(csize_allocs)

	var cmemory_allocs *cgoAllocMap
	ref5bf418e8.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	ref5bf418e8.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cmemoryOffset_allocs)

	var cflags_allocs *cgoAllocMap
	ref5bf418e8.flags, cflags_allocs = (C.VkSparseMemoryBindFlags)(x.Flags), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cflags_allocs)

	x.ref5bf418e8 = ref5bf418e8
	x.allocs5bf418e8 = allocs5bf418e8
	return ref5bf418e8, allocs5bf418e8

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SparseMemoryBind) PassValue() (C.VkSparseMemoryBind, *cgoAllocMap) {
	if x.ref5bf418e8 != nil {
		return *x.ref5bf418e8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SparseMemoryBind) Deref() {
	if x.ref5bf418e8 == nil {
		return
	}
	x.ResourceOffset = (DeviceSize)(x.ref5bf418e8.resourceOffset)
	x.Size = (DeviceSize)(x.ref5bf418e8.size)
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref5bf418e8.memory))
	x.MemoryOffset = (DeviceSize)(x.ref5bf418e8.memoryOffset)
	x.Flags = (SparseMemoryBindFlags)(x.ref5bf418e8.flags)
}

// allocSparseBufferMemoryBindInfoMemory allocates memory for type C.VkSparseBufferMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseBufferMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseBufferMemoryBindInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseBufferMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseBufferMemoryBindInfo{})

// unpackSSparseMemoryBind transforms a sliced Go data structure into plain C format.
func unpackSSparseMemoryBind(x []SparseMemoryBind) (unpacked *C.VkSparseMemoryBind, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseMemoryBind) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseMemoryBindMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseMemoryBind)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseMemoryBind)(unsafe.Pointer(h.Data))
	return
}

// packSSparseMemoryBind reads sliced Go data structure out from plain C format.
func packSSparseMemoryBind(v []SparseMemoryBind, ptr0 *C.VkSparseMemoryBind) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseMemoryBindValue]C.VkSparseMemoryBind)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseMemoryBindRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *SparseBufferMemoryBindInfo) Ref() *C.VkSparseBufferMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.refebcaf40c
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SparseBufferMemoryBindInfo) Free() {
	if x != nil && x.allocsebcaf40c != nil {
		x.allocsebcaf40c.(*cgoAllocMap).Free()
		x.refebcaf40c = nil
	}
}

// NewSparseBufferMemoryBindInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewSparseBufferMemoryBindInfoRef(ref interface{}) *SparseBufferMemoryBindInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SparseBufferMemoryBindInfo)
	obj.refebcaf40c = (*C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SparseBufferMemoryBindInfo) PassRef() (*C.VkSparseBufferMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refebcaf40c != nil {
		return x.refebcaf40c, nil
	}
	memebcaf40c := allocSparseBufferMemoryBindInfoMemory(1)
	refebcaf40c := (*C.VkSparseBufferMemoryBindInfo)(memebcaf40c)
	allocsebcaf40c := new(cgoAllocMap)
	var cbuffer_allocs *cgoAllocMap
	refebcaf40c.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsebcaf40c.Borrow(cbuffer_allocs)

	var cbindCount_allocs *cgoAllocMap
	refebcaf40c.bindCount, cbindCount_allocs = (C.uint32_t)(x.BindCount), cgoAllocsUnknown
	allocsebcaf40c.Borrow(cbindCount_allocs)

	var cpBinds_allocs *cgoAllocMap
	refebcaf40c.pBinds, cpBinds_allocs = unpackSSparseMemoryBind(x.PBinds)
	allocsebcaf40c.Borrow(cpBinds_allocs)

	x.refebcaf40c = refebcaf40c
	x.allocsebcaf40c = allocsebcaf40c
	return refebcaf40c, allocsebcaf40c

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SparseBufferMemoryBindInfo) PassValue() (C.VkSparseBufferMemoryBindInfo, *cgoAllocMap) {
	if x.refebcaf40c != nil {
		return *x.refebcaf40c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SparseBufferMemoryBindInfo) Deref() {
	if x.refebcaf40c == nil {
		return
	}
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refebcaf40c.buffer))
	x.BindCount = (uint32)(x.refebcaf40c.bindCount)
	packSSparseMemoryBind(x.PBinds, x.refebcaf40c.pBinds)
}

// allocSparseImageOpaqueMemoryBindInfoMemory allocates memory for type C.VkSparseImageOpaqueMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageOpaqueMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageOpaqueMemoryBindInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageOpaqueMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseImageOpaqueMemoryBindInfo{})

// Ref returns a reference.
func (x *SparseImageOpaqueMemoryBindInfo) Ref() *C.VkSparseImageOpaqueMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.reffb1b3d56
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SparseImageOpaqueMemoryBindInfo) Free() {
	if x != nil && x.allocsfb1b3d56 != nil {
		x.allocsfb1b3d56.(*cgoAllocMap).Free()
		x.reffb1b3d56 = nil
	}
}

// NewSparseImageOpaqueMemoryBindInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewSparseImageOpaqueMemoryBindInfoRef(ref interface{}) *SparseImageOpaqueMemoryBindInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SparseImageOpaqueMemoryBindInfo)
	obj.reffb1b3d56 = (*C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SparseImageOpaqueMemoryBindInfo) PassRef() (*C.VkSparseImageOpaqueMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffb1b3d56 != nil {
		return x.reffb1b3d56, nil
	}
	memfb1b3d56 := allocSparseImageOpaqueMemoryBindInfoMemory(1)
	reffb1b3d56 := (*C.VkSparseImageOpaqueMemoryBindInfo)(memfb1b3d56)
	allocsfb1b3d56 := new(cgoAllocMap)
	var cimage_allocs *cgoAllocMap
	reffb1b3d56.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocsfb1b3d56.Borrow(cimage_allocs)

	var cbindCount_allocs *cgoAllocMap
	reffb1b3d56.bindCount, cbindCount_allocs = (C.uint32_t)(x.BindCount), cgoAllocsUnknown
	allocsfb1b3d56.Borrow(cbindCount_allocs)

	var cpBinds_allocs *cgoAllocMap
	reffb1b3d56.pBinds, cpBinds_allocs = unpackSSparseMemoryBind(x.PBinds)
	allocsfb1b3d56.Borrow(cpBinds_allocs)

	x.reffb1b3d56 = reffb1b3d56
	x.allocsfb1b3d56 = allocsfb1b3d56
	return reffb1b3d56, allocsfb1b3d56

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SparseImageOpaqueMemoryBindInfo) PassValue() (C.VkSparseImageOpaqueMemoryBindInfo, *cgoAllocMap) {
	if x.reffb1b3d56 != nil {
		return *x.reffb1b3d56, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SparseImageOpaqueMemoryBindInfo) Deref() {
	if x.reffb1b3d56 == nil {
		return
	}
	x.Image = *(*Image)(unsafe.Pointer(&x.reffb1b3d56.image))
	x.BindCount = (uint32)(x.reffb1b3d56.bindCount)
	packSSparseMemoryBind(x.PBinds, x.reffb1b3d56.pBinds)
}

// allocImageSubresourceMemory allocates memory for type C.VkImageSubresource in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSubresourceValue = unsafe.Sizeof([1]C.VkImageSubresource{})

// Ref returns a reference.
func (x *ImageSubresource) Ref() *C.VkImageSubresource {
	if x == nil {
		return nil
	}
	return x.reffeaa0d8a
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageSubresource) Free() {
	if x != nil && x.allocsfeaa0d8a != nil {
		x.allocsfeaa0d8a.(*cgoAllocMap).Free()
		x.reffeaa0d8a = nil
	}
}

// NewImageSubresourceRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageSubresourceRef(ref interface{}) *ImageSubresource {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ImageSubresource)
	obj.reffeaa0d8a = (*C.VkImageSubresource)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageSubresource) PassRef() (*C.VkImageSubresource, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffeaa0d8a != nil {
		return x.reffeaa0d8a, nil
	}
	memfeaa0d8a := allocImageSubresourceMemory(1)
	reffeaa0d8a := (*C.VkImageSubresource)(memfeaa0d8a)
	allocsfeaa0d8a := new(cgoAllocMap)
	var caspectMask_allocs *cgoAllocMap
	reffeaa0d8a.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocsfeaa0d8a.Borrow(caspectMask_allocs)

	var cmipLevel_allocs *cgoAllocMap
	reffeaa0d8a.mipLevel, cmipLevel_allocs = (C.uint32_t)(x.MipLevel), cgoAllocsUnknown
	allocsfeaa0d8a.Borrow(cmipLevel_allocs)

	var carrayLayer_allocs *cgoAllocMap
	reffeaa0d8a.arrayLayer, carrayLayer_allocs = (C.uint32_t)(x.ArrayLayer), cgoAllocsUnknown
	allocsfeaa0d8a.Borrow(carrayLayer_allocs)

	x.reffeaa0d8a = reffeaa0d8a
	x.allocsfeaa0d8a = allocsfeaa0d8a
	return reffeaa0d8a, allocsfeaa0d8a

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ImageSubresource) PassValue() (C.VkImageSubresource, *cgoAllocMap) {
	if x.reffeaa0d8a != nil {
		return *x.reffeaa0d8a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageSubresource) Deref() {
	if x.reffeaa0d8a == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.reffeaa0d8a.aspectMask)
	x.MipLevel = (uint32)(x.reffeaa0d8a.mipLevel)
	x.ArrayLayer = (uint32)(x.reffeaa0d8a.arrayLayer)
}

// allocOffset3DMemory allocates memory for type C.VkOffset3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOffset3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOffset3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOffset3DValue = unsafe.Sizeof([1]C.VkOffset3D{})

// Ref returns a reference.
func (x *Offset3D) Ref() *C.VkOffset3D {
	if x == nil {
		return nil
	}
	return x.ref2b6879c2
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Offset3D) Free() {
	if x != nil && x.allocs2b6879c2 != nil {
		x.allocs2b6879c2.(*cgoAllocMap).Free()
		x.ref2b6879c2 = nil
	}
}

// NewOffset3DRef initialises a new struct holding the reference to the originaitng C struct.
func NewOffset3DRef(ref interface{}) *Offset3D {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(Offset3D)
	obj.ref2b6879c2 = (*C.VkOffset3D)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Offset3D) PassRef() (*C.VkOffset3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2b6879c2 != nil {
		return x.ref2b6879c2, nil
	}
	mem2b6879c2 := allocOffset3DMemory(1)
	ref2b6879c2 := (*C.VkOffset3D)(mem2b6879c2)
	allocs2b6879c2 := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	ref2b6879c2.x, cx_allocs = (C.int32_t)(x.X), cgoAllocsUnknown
	allocs2b6879c2.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref2b6879c2.y, cy_allocs = (C.int32_t)(x.Y), cgoAllocsUnknown
	allocs2b6879c2.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	ref2b6879c2.z, cz_allocs = (C.int32_t)(x.Z), cgoAllocsUnknown
	allocs2b6879c2.Borrow(cz_allocs)

	x.ref2b6879c2 = ref2b6879c2
	x.allocs2b6879c2 = allocs2b6879c2
	return ref2b6879c2, allocs2b6879c2

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x Offset3D) PassValue() (C.VkOffset3D, *cgoAllocMap) {
	if x.ref2b6879c2 != nil {
		return *x.ref2b6879c2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Offset3D) Deref() {
	if x.ref2b6879c2 == nil {
		return
	}
	x.X = (int32)(x.ref2b6879c2.x)
	x.Y = (int32)(x.ref2b6879c2.y)
	x.Z = (int32)(x.ref2b6879c2.z)
}

// allocSparseImageMemoryBindMemory allocates memory for type C.VkSparseImageMemoryBind in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryBindMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryBindValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageMemoryBindValue = unsafe.Sizeof([1]C.VkSparseImageMemoryBind{})

// Ref returns a reference.
func (x *SparseImageMemoryBind) Ref() *C.VkSparseImageMemoryBind {
	if x == nil {
		return nil
	}
	return x.ref41b516d7
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SparseImageMemoryBind) Free() {
	if x != nil && x.allocs41b516d7 != nil {
		x.allocs41b516d7.(*cgoAllocMap).Free()
		x.ref41b516d7 = nil
	}
}

// NewSparseImageMemoryBindRef initialises a new struct holding the reference to the originaitng C struct.
func NewSparseImageMemoryBindRef(ref interface{}) *SparseImageMemoryBind {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SparseImageMemoryBind)
	obj.ref41b516d7 = (*C.VkSparseImageMemoryBind)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SparseImageMemoryBind) PassRef() (*C.VkSparseImageMemoryBind, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref41b516d7 != nil {
		return x.ref41b516d7, nil
	}
	mem41b516d7 := allocSparseImageMemoryBindMemory(1)
	ref41b516d7 := (*C.VkSparseImageMemoryBind)(mem41b516d7)
	allocs41b516d7 := new(cgoAllocMap)
	var csubresource_allocs *cgoAllocMap
	ref41b516d7.subresource, csubresource_allocs = x.Subresource.PassValue()
	allocs41b516d7.Borrow(csubresource_allocs)

	var coffset_allocs *cgoAllocMap
	ref41b516d7.offset, coffset_allocs = x.Offset.PassValue()
	allocs41b516d7.Borrow(coffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref41b516d7.extent, cextent_allocs = x.Extent.PassValue()
	allocs41b516d7.Borrow(cextent_allocs)

	var cmemory_allocs *cgoAllocMap
	ref41b516d7.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs41b516d7.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	ref41b516d7.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocs41b516d7.Borrow(cmemoryOffset_allocs)

	var cflags_allocs *cgoAllocMap
	ref41b516d7.flags, cflags_allocs = (C.VkSparseMemoryBindFlags)(x.Flags), cgoAllocsUnknown
	allocs41b516d7.Borrow(cflags_allocs)

	x.ref41b516d7 = ref41b516d7
	x.allocs41b516d7 = allocs41b516d7
	return ref41b516d7, allocs41b516d7

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SparseImageMemoryBind) PassValue() (C.VkSparseImageMemoryBind, *cgoAllocMap) {
	if x.ref41b516d7 != nil {
		return *x.ref41b516d7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SparseImageMemoryBind) Deref() {
	if x.ref41b516d7 == nil {
		return
	}
	x.Subresource = *NewImageSubresourceRef(&x.ref41b516d7.subresource)
	x.Offset = *NewOffset3DRef(&x.ref41b516d7.offset)
	x.Extent = *NewExtent3DRef(&x.ref41b516d7.extent)
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref41b516d7.memory))
	x.MemoryOffset = (DeviceSize)(x.ref41b516d7.memoryOffset)
	x.Flags = (SparseMemoryBindFlags)(x.ref41b516d7.flags)
}

// allocSparseImageMemoryBindInfoMemory allocates memory for type C.VkSparseImageMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryBindInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseImageMemoryBindInfo{})

// unpackSSparseImageMemoryBind transforms a sliced Go data structure into plain C format.
func unpackSSparseImageMemoryBind(x []SparseImageMemoryBind) (unpacked *C.VkSparseImageMemoryBind, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageMemoryBind) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryBindMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryBind)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryBind)(unsafe.Pointer(h.Data))
	return
}

// packSSparseImageMemoryBind reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryBind(v []SparseImageMemoryBind, ptr0 *C.VkSparseImageMemoryBind) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryBindValue]C.VkSparseImageMemoryBind)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryBindRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *SparseImageMemoryBindInfo) Ref() *C.VkSparseImageMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.ref50faeb70
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SparseImageMemoryBindInfo) Free() {
	if x != nil && x.allocs50faeb70 != nil {
		x.allocs50faeb70.(*cgoAllocMap).Free()
		x.ref50faeb70 = nil
	}
}

// NewSparseImageMemoryBindInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewSparseImageMemoryBindInfoRef(ref interface{}) *SparseImageMemoryBindInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SparseImageMemoryBindInfo)
	obj.ref50faeb70 = (*C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SparseImageMemoryBindInfo) PassRef() (*C.VkSparseImageMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50faeb70 != nil {
		return x.ref50faeb70, nil
	}
	mem50faeb70 := allocSparseImageMemoryBindInfoMemory(1)
	ref50faeb70 := (*C.VkSparseImageMemoryBindInfo)(mem50faeb70)
	allocs50faeb70 := new(cgoAllocMap)
	var cimage_allocs *cgoAllocMap
	ref50faeb70.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs50faeb70.Borrow(cimage_allocs)

	var cbindCount_allocs *cgoAllocMap
	ref50faeb70.bindCount, cbindCount_allocs = (C.uint32_t)(x.BindCount), cgoAllocsUnknown
	allocs50faeb70.Borrow(cbindCount_allocs)

	var cpBinds_allocs *cgoAllocMap
	ref50faeb70.pBinds, cpBinds_allocs = unpackSSparseImageMemoryBind(x.PBinds)
	allocs50faeb70.Borrow(cpBinds_allocs)

	x.ref50faeb70 = ref50faeb70
	x.allocs50faeb70 = allocs50faeb70
	return ref50faeb70, allocs50faeb70

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SparseImageMemoryBindInfo) PassValue() (C.VkSparseImageMemoryBindInfo, *cgoAllocMap) {
	if x.ref50faeb70 != nil {
		return *x.ref50faeb70, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SparseImageMemoryBindInfo) Deref() {
	if x.ref50faeb70 == nil {
		return
	}
	x.Image = *(*Image)(unsafe.Pointer(&x.ref50faeb70.image))
	x.BindCount = (uint32)(x.ref50faeb70.bindCount)
	packSSparseImageMemoryBind(x.PBinds, x.ref50faeb70.pBinds)
}

// allocBindSparseInfoMemory allocates memory for type C.VkBindSparseInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindSparseInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindSparseInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindSparseInfoValue = unsafe.Sizeof([1]C.VkBindSparseInfo{})

// unpackSSparseBufferMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseBufferMemoryBindInfo(x []SparseBufferMemoryBindInfo) (unpacked *C.VkSparseBufferMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseBufferMemoryBindInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseBufferMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSSparseImageOpaqueMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseImageOpaqueMemoryBindInfo(x []SparseImageOpaqueMemoryBindInfo) (unpacked *C.VkSparseImageOpaqueMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageOpaqueMemoryBindInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageOpaqueMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSSparseImageMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseImageMemoryBindInfo(x []SparseImageMemoryBindInfo) (unpacked *C.VkSparseImageMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageMemoryBindInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(h.Data))
	return
}

// packSSparseBufferMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseBufferMemoryBindInfo(v []SparseBufferMemoryBindInfo, ptr0 *C.VkSparseBufferMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseBufferMemoryBindInfoValue]C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseBufferMemoryBindInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSSparseImageOpaqueMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseImageOpaqueMemoryBindInfo(v []SparseImageOpaqueMemoryBindInfo, ptr0 *C.VkSparseImageOpaqueMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageOpaqueMemoryBindInfoValue]C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageOpaqueMemoryBindInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSSparseImageMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryBindInfo(v []SparseImageMemoryBindInfo, ptr0 *C.VkSparseImageMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryBindInfoValue]C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryBindInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *BindSparseInfo) Ref() *C.VkBindSparseInfo {
	if x == nil {
		return nil
	}
	return x.refb0cbe910
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *BindSparseInfo) Free() {
	if x != nil && x.allocsb0cbe910 != nil {
		x.allocsb0cbe910.(*cgoAllocMap).Free()
		x.refb0cbe910 = nil
	}
}

// NewBindSparseInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewBindSparseInfoRef(ref interface{}) *BindSparseInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(BindSparseInfo)
	obj.refb0cbe910 = (*C.VkBindSparseInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *BindSparseInfo) PassRef() (*C.VkBindSparseInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0cbe910 != nil {
		return x.refb0cbe910, nil
	}
	memb0cbe910 := allocBindSparseInfoMemory(1)
	refb0cbe910 := (*C.VkBindSparseInfo)(memb0cbe910)
	allocsb0cbe910 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refb0cbe910.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb0cbe910.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb0cbe910.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	refb0cbe910.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphores_allocs *cgoAllocMap
	refb0cbe910.pWaitSemaphores, cpWaitSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)).Data)), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cpWaitSemaphores_allocs)

	var cbufferBindCount_allocs *cgoAllocMap
	refb0cbe910.bufferBindCount, cbufferBindCount_allocs = (C.uint32_t)(x.BufferBindCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cbufferBindCount_allocs)

	var cpBufferBinds_allocs *cgoAllocMap
	refb0cbe910.pBufferBinds, cpBufferBinds_allocs = unpackSSparseBufferMemoryBindInfo(x.PBufferBinds)
	allocsb0cbe910.Borrow(cpBufferBinds_allocs)

	var cimageOpaqueBindCount_allocs *cgoAllocMap
	refb0cbe910.imageOpaqueBindCount, cimageOpaqueBindCount_allocs = (C.uint32_t)(x.ImageOpaqueBindCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cimageOpaqueBindCount_allocs)

	var cpImageOpaqueBinds_allocs *cgoAllocMap
	refb0cbe910.pImageOpaqueBinds, cpImageOpaqueBinds_allocs = unpackSSparseImageOpaqueMemoryBindInfo(x.PImageOpaqueBinds)
	allocsb0cbe910.Borrow(cpImageOpaqueBinds_allocs)

	var cimageBindCount_allocs *cgoAllocMap
	refb0cbe910.imageBindCount, cimageBindCount_allocs = (C.uint32_t)(x.ImageBindCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cimageBindCount_allocs)

	var cpImageBinds_allocs *cgoAllocMap
	refb0cbe910.pImageBinds, cpImageBinds_allocs = unpackSSparseImageMemoryBindInfo(x.PImageBinds)
	allocsb0cbe910.Borrow(cpImageBinds_allocs)

	var csignalSemaphoreCount_allocs *cgoAllocMap
	refb0cbe910.signalSemaphoreCount, csignalSemaphoreCount_allocs = (C.uint32_t)(x.SignalSemaphoreCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(csignalSemaphoreCount_allocs)

	var cpSignalSemaphores_allocs *cgoAllocMap
	refb0cbe910.pSignalSemaphores, cpSignalSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores)).Data)), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cpSignalSemaphores_allocs)

	x.refb0cbe910 = refb0cbe910
	x.allocsb0cbe910 = allocsb0cbe910
	return refb0cbe910, allocsb0cbe910

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x BindSparseInfo) PassValue() (C.VkBindSparseInfo, *cgoAllocMap) {
	if x.refb0cbe910 != nil {
		return *x.refb0cbe910, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *BindSparseInfo) Deref() {
	if x.refb0cbe910 == nil {
		return
	}
	x.SType = (StructureType)(x.refb0cbe910.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb0cbe910.pNext))
	x.WaitSemaphoreCount = (uint32)(x.refb0cbe910.waitSemaphoreCount)
	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxfa3f05c.Data = uintptr(unsafe.Pointer(x.refb0cbe910.pWaitSemaphores))
	hxfa3f05c.Cap = 0x7fffffff
	// hxfa3f05c.Len = ?

	x.BufferBindCount = (uint32)(x.refb0cbe910.bufferBindCount)
	packSSparseBufferMemoryBindInfo(x.PBufferBinds, x.refb0cbe910.pBufferBinds)
	x.ImageOpaqueBindCount = (uint32)(x.refb0cbe910.imageOpaqueBindCount)
	packSSparseImageOpaqueMemoryBindInfo(x.PImageOpaqueBinds, x.refb0cbe910.pImageOpaqueBinds)
	x.ImageBindCount = (uint32)(x.refb0cbe910.imageBindCount)
	packSSparseImageMemoryBindInfo(x.PImageBinds, x.refb0cbe910.pImageBinds)
	x.SignalSemaphoreCount = (uint32)(x.refb0cbe910.signalSemaphoreCount)
	hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores))
	hxf0d18b7.Data = uintptr(unsafe.Pointer(x.refb0cbe910.pSignalSemaphores))
	hxf0d18b7.Cap = 0x7fffffff
	// hxf0d18b7.Len = ?

}

// allocFenceCreateInfoMemory allocates memory for type C.VkFenceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFenceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFenceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFenceCreateInfoValue = unsafe.Sizeof([1]C.VkFenceCreateInfo{})

// Ref returns a reference.
func (x *FenceCreateInfo) Ref() *C.VkFenceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb8ff4840
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *FenceCreateInfo) Free() {
	if x != nil && x.allocsb8ff4840 != nil {
		x.allocsb8ff4840.(*cgoAllocMap).Free()
		x.refb8ff4840 = nil
	}
}

// NewFenceCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewFenceCreateInfoRef(ref interface{}) *FenceCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(FenceCreateInfo)
	obj.refb8ff4840 = (*C.VkFenceCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *FenceCreateInfo) PassRef() (*C.VkFenceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8ff4840 != nil {
		return x.refb8ff4840, nil
	}
	memb8ff4840 := allocFenceCreateInfoMemory(1)
	refb8ff4840 := (*C.VkFenceCreateInfo)(memb8ff4840)
	allocsb8ff4840 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refb8ff4840.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb8ff4840.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb8ff4840.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb8ff4840.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refb8ff4840.flags, cflags_allocs = (C.VkFenceCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsb8ff4840.Borrow(cflags_allocs)

	x.refb8ff4840 = refb8ff4840
	x.allocsb8ff4840 = allocsb8ff4840
	return refb8ff4840, allocsb8ff4840

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x FenceCreateInfo) PassValue() (C.VkFenceCreateInfo, *cgoAllocMap) {
	if x.refb8ff4840 != nil {
		return *x.refb8ff4840, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *FenceCreateInfo) Deref() {
	if x.refb8ff4840 == nil {
		return
	}
	x.SType = (StructureType)(x.refb8ff4840.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb8ff4840.pNext))
	x.Flags = (FenceCreateFlags)(x.refb8ff4840.flags)
}

// allocSemaphoreCreateInfoMemory allocates memory for type C.VkSemaphoreCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSemaphoreCreateInfoValue = unsafe.Sizeof([1]C.VkSemaphoreCreateInfo{})

// Ref returns a reference.
func (x *SemaphoreCreateInfo) Ref() *C.VkSemaphoreCreateInfo {
	if x == nil {
		return nil
	}
	return x.reff130cd2b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SemaphoreCreateInfo) Free() {
	if x != nil && x.allocsf130cd2b != nil {
		x.allocsf130cd2b.(*cgoAllocMap).Free()
		x.reff130cd2b = nil
	}
}

// NewSemaphoreCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewSemaphoreCreateInfoRef(ref interface{}) *SemaphoreCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SemaphoreCreateInfo)
	obj.reff130cd2b = (*C.VkSemaphoreCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SemaphoreCreateInfo) PassRef() (*C.VkSemaphoreCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff130cd2b != nil {
		return x.reff130cd2b, nil
	}
	memf130cd2b := allocSemaphoreCreateInfoMemory(1)
	reff130cd2b := (*C.VkSemaphoreCreateInfo)(memf130cd2b)
	allocsf130cd2b := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	reff130cd2b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf130cd2b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff130cd2b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf130cd2b.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reff130cd2b.flags, cflags_allocs = (C.VkSemaphoreCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsf130cd2b.Borrow(cflags_allocs)

	x.reff130cd2b = reff130cd2b
	x.allocsf130cd2b = allocsf130cd2b
	return reff130cd2b, allocsf130cd2b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SemaphoreCreateInfo) PassValue() (C.VkSemaphoreCreateInfo, *cgoAllocMap) {
	if x.reff130cd2b != nil {
		return *x.reff130cd2b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SemaphoreCreateInfo) Deref() {
	if x.reff130cd2b == nil {
		return
	}
	x.SType = (StructureType)(x.reff130cd2b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff130cd2b.pNext))
	x.Flags = (SemaphoreCreateFlags)(x.reff130cd2b.flags)
}

// allocEventCreateInfoMemory allocates memory for type C.VkEventCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventCreateInfoValue = unsafe.Sizeof([1]C.VkEventCreateInfo{})

// Ref returns a reference.
func (x *EventCreateInfo) Ref() *C.VkEventCreateInfo {
	if x == nil {
		return nil
	}
	return x.refa54f9ec8
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *EventCreateInfo) Free() {
	if x != nil && x.allocsa54f9ec8 != nil {
		x.allocsa54f9ec8.(*cgoAllocMap).Free()
		x.refa54f9ec8 = nil
	}
}

// NewEventCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewEventCreateInfoRef(ref interface{}) *EventCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(EventCreateInfo)
	obj.refa54f9ec8 = (*C.VkEventCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *EventCreateInfo) PassRef() (*C.VkEventCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa54f9ec8 != nil {
		return x.refa54f9ec8, nil
	}
	mema54f9ec8 := allocEventCreateInfoMemory(1)
	refa54f9ec8 := (*C.VkEventCreateInfo)(mema54f9ec8)
	allocsa54f9ec8 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refa54f9ec8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa54f9ec8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa54f9ec8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa54f9ec8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refa54f9ec8.flags, cflags_allocs = (C.VkEventCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsa54f9ec8.Borrow(cflags_allocs)

	x.refa54f9ec8 = refa54f9ec8
	x.allocsa54f9ec8 = allocsa54f9ec8
	return refa54f9ec8, allocsa54f9ec8

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x EventCreateInfo) PassValue() (C.VkEventCreateInfo, *cgoAllocMap) {
	if x.refa54f9ec8 != nil {
		return *x.refa54f9ec8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *EventCreateInfo) Deref() {
	if x.refa54f9ec8 == nil {
		return
	}
	x.SType = (StructureType)(x.refa54f9ec8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa54f9ec8.pNext))
	x.Flags = (EventCreateFlags)(x.refa54f9ec8.flags)
}

// allocQueryPoolCreateInfoMemory allocates memory for type C.VkQueryPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueryPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueryPoolCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfQueryPoolCreateInfoValue = unsafe.Sizeof([1]C.VkQueryPoolCreateInfo{})

// Ref returns a reference.
func (x *QueryPoolCreateInfo) Ref() *C.VkQueryPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref85dfcd4a
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *QueryPoolCreateInfo) Free() {
	if x != nil && x.allocs85dfcd4a != nil {
		x.allocs85dfcd4a.(*cgoAllocMap).Free()
		x.ref85dfcd4a = nil
	}
}

// NewQueryPoolCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewQueryPoolCreateInfoRef(ref interface{}) *QueryPoolCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(QueryPoolCreateInfo)
	obj.ref85dfcd4a = (*C.VkQueryPoolCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *QueryPoolCreateInfo) PassRef() (*C.VkQueryPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85dfcd4a != nil {
		return x.ref85dfcd4a, nil
	}
	mem85dfcd4a := allocQueryPoolCreateInfoMemory(1)
	ref85dfcd4a := (*C.VkQueryPoolCreateInfo)(mem85dfcd4a)
	allocs85dfcd4a := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref85dfcd4a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref85dfcd4a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref85dfcd4a.flags, cflags_allocs = (C.VkQueryPoolCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cflags_allocs)

	var cqueryType_allocs *cgoAllocMap
	ref85dfcd4a.queryType, cqueryType_allocs = (C.VkQueryType)(x.QueryType), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cqueryType_allocs)

	var cqueryCount_allocs *cgoAllocMap
	ref85dfcd4a.queryCount, cqueryCount_allocs = (C.uint32_t)(x.QueryCount), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cqueryCount_allocs)

	var cpipelineStatistics_allocs *cgoAllocMap
	ref85dfcd4a.pipelineStatistics, cpipelineStatistics_allocs = (C.VkQueryPipelineStatisticFlags)(x.PipelineStatistics), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cpipelineStatistics_allocs)

	x.ref85dfcd4a = ref85dfcd4a
	x.allocs85dfcd4a = allocs85dfcd4a
	return ref85dfcd4a, allocs85dfcd4a

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x QueryPoolCreateInfo) PassValue() (C.VkQueryPoolCreateInfo, *cgoAllocMap) {
	if x.ref85dfcd4a != nil {
		return *x.ref85dfcd4a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *QueryPoolCreateInfo) Deref() {
	if x.ref85dfcd4a == nil {
		return
	}
	x.SType = (StructureType)(x.ref85dfcd4a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref85dfcd4a.pNext))
	x.Flags = (QueryPoolCreateFlags)(x.ref85dfcd4a.flags)
	x.QueryType = (QueryType)(x.ref85dfcd4a.queryType)
	x.QueryCount = (uint32)(x.ref85dfcd4a.queryCount)
	x.PipelineStatistics = (QueryPipelineStatisticFlags)(x.ref85dfcd4a.pipelineStatistics)
}

// allocBufferCreateInfoMemory allocates memory for type C.VkBufferCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferCreateInfoValue = unsafe.Sizeof([1]C.VkBufferCreateInfo{})

// Ref returns a reference.
func (x *BufferCreateInfo) Ref() *C.VkBufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.reffe19d2cd
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *BufferCreateInfo) Free() {
	if x != nil && x.allocsfe19d2cd != nil {
		x.allocsfe19d2cd.(*cgoAllocMap).Free()
		x.reffe19d2cd = nil
	}
}

// NewBufferCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewBufferCreateInfoRef(ref interface{}) *BufferCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(BufferCreateInfo)
	obj.reffe19d2cd = (*C.VkBufferCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *BufferCreateInfo) PassRef() (*C.VkBufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe19d2cd != nil {
		return x.reffe19d2cd, nil
	}
	memfe19d2cd := allocBufferCreateInfoMemory(1)
	reffe19d2cd := (*C.VkBufferCreateInfo)(memfe19d2cd)
	allocsfe19d2cd := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	reffe19d2cd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe19d2cd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reffe19d2cd.flags, cflags_allocs = (C.VkBufferCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cflags_allocs)

	var csize_allocs *cgoAllocMap
	reffe19d2cd.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(csize_allocs)

	var cusage_allocs *cgoAllocMap
	reffe19d2cd.usage, cusage_allocs = (C.VkBufferUsageFlags)(x.Usage), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cusage_allocs)

	var csharingMode_allocs *cgoAllocMap
	reffe19d2cd.sharingMode, csharingMode_allocs = (C.VkSharingMode)(x.SharingMode), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(csharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	reffe19d2cd.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	reffe19d2cd.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)).Data)), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cpQueueFamilyIndices_allocs)

	x.reffe19d2cd = reffe19d2cd
	x.allocsfe19d2cd = allocsfe19d2cd
	return reffe19d2cd, allocsfe19d2cd

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x BufferCreateInfo) PassValue() (C.VkBufferCreateInfo, *cgoAllocMap) {
	if x.reffe19d2cd != nil {
		return *x.reffe19d2cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *BufferCreateInfo) Deref() {
	if x.reffe19d2cd == nil {
		return
	}
	x.SType = (StructureType)(x.reffe19d2cd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe19d2cd.pNext))
	x.Flags = (BufferCreateFlags)(x.reffe19d2cd.flags)
	x.Size = (DeviceSize)(x.reffe19d2cd.size)
	x.Usage = (BufferUsageFlags)(x.reffe19d2cd.usage)
	x.SharingMode = (SharingMode)(x.reffe19d2cd.sharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.reffe19d2cd.queueFamilyIndexCount)
	hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf2fab0d.Data = uintptr(unsafe.Pointer(x.reffe19d2cd.pQueueFamilyIndices))
	hxf2fab0d.Cap = 0x7fffffff
	// hxf2fab0d.Len = ?

}

// allocBufferViewCreateInfoMemory allocates memory for type C.VkBufferViewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferViewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferViewCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferViewCreateInfoValue = unsafe.Sizeof([1]C.VkBufferViewCreateInfo{})

// Ref returns a reference.
func (x *BufferViewCreateInfo) Ref() *C.VkBufferViewCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref49b97027
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *BufferViewCreateInfo) Free() {
	if x != nil && x.allocs49b97027 != nil {
		x.allocs49b97027.(*cgoAllocMap).Free()
		x.ref49b97027 = nil
	}
}

// NewBufferViewCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewBufferViewCreateInfoRef(ref interface{}) *BufferViewCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(BufferViewCreateInfo)
	obj.ref49b97027 = (*C.VkBufferViewCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *BufferViewCreateInfo) PassRef() (*C.VkBufferViewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref49b97027 != nil {
		return x.ref49b97027, nil
	}
	mem49b97027 := allocBufferViewCreateInfoMemory(1)
	ref49b97027 := (*C.VkBufferViewCreateInfo)(mem49b97027)
	allocs49b97027 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref49b97027.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs49b97027.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref49b97027.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs49b97027.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref49b97027.flags, cflags_allocs = (C.VkBufferViewCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs49b97027.Borrow(cflags_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref49b97027.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs49b97027.Borrow(cbuffer_allocs)

	var cformat_allocs *cgoAllocMap
	ref49b97027.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs49b97027.Borrow(cformat_allocs)

	var coffset_allocs *cgoAllocMap
	ref49b97027.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs49b97027.Borrow(coffset_allocs)

	var c_range_allocs *cgoAllocMap
	ref49b97027._range, c_range_allocs = (C.VkDeviceSize)(x._range), cgoAllocsUnknown
	allocs49b97027.Borrow(c_range_allocs)

	x.ref49b97027 = ref49b97027
	x.allocs49b97027 = allocs49b97027
	return ref49b97027, allocs49b97027

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x BufferViewCreateInfo) PassValue() (C.VkBufferViewCreateInfo, *cgoAllocMap) {
	if x.ref49b97027 != nil {
		return *x.ref49b97027, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *BufferViewCreateInfo) Deref() {
	if x.ref49b97027 == nil {
		return
	}
	x.SType = (StructureType)(x.ref49b97027.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref49b97027.pNext))
	x.Flags = (BufferViewCreateFlags)(x.ref49b97027.flags)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref49b97027.buffer))
	x.Format = (Format)(x.ref49b97027.format)
	x.Offset = (DeviceSize)(x.ref49b97027.offset)
	x._range = (DeviceSize)(x.ref49b97027._range)
}

// allocImageCreateInfoMemory allocates memory for type C.VkImageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageCreateInfoValue = unsafe.Sizeof([1]C.VkImageCreateInfo{})

// Ref returns a reference.
func (x *ImageCreateInfo) Ref() *C.VkImageCreateInfo {
	if x == nil {
		return nil
	}
	return x.reffb587ba1
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageCreateInfo) Free() {
	if x != nil && x.allocsfb587ba1 != nil {
		x.allocsfb587ba1.(*cgoAllocMap).Free()
		x.reffb587ba1 = nil
	}
}

// NewImageCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageCreateInfoRef(ref interface{}) *ImageCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ImageCreateInfo)
	obj.reffb587ba1 = (*C.VkImageCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageCreateInfo) PassRef() (*C.VkImageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffb587ba1 != nil {
		return x.reffb587ba1, nil
	}
	memfb587ba1 := allocImageCreateInfoMemory(1)
	reffb587ba1 := (*C.VkImageCreateInfo)(memfb587ba1)
	allocsfb587ba1 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	reffb587ba1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfb587ba1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffb587ba1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reffb587ba1.flags, cflags_allocs = (C.VkImageCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cflags_allocs)

	var cimageType_allocs *cgoAllocMap
	reffb587ba1.imageType, cimageType_allocs = (C.VkImageType)(x.ImageType), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cimageType_allocs)

	var cformat_allocs *cgoAllocMap
	reffb587ba1.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cformat_allocs)

	var cextent_allocs *cgoAllocMap
	reffb587ba1.extent, cextent_allocs = x.Extent.PassValue()
	allocsfb587ba1.Borrow(cextent_allocs)

	var cmipLevels_allocs *cgoAllocMap
	reffb587ba1.mipLevels, cmipLevels_allocs = (C.uint32_t)(x.MipLevels), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cmipLevels_allocs)

	var carrayLayers_allocs *cgoAllocMap
	reffb587ba1.arrayLayers, carrayLayers_allocs = (C.uint32_t)(x.ArrayLayers), cgoAllocsUnknown
	allocsfb587ba1.Borrow(carrayLayers_allocs)

	var csamples_allocs *cgoAllocMap
	reffb587ba1.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocsfb587ba1.Borrow(csamples_allocs)

	var ctiling_allocs *cgoAllocMap
	reffb587ba1.tiling, ctiling_allocs = (C.VkImageTiling)(x.Tiling), cgoAllocsUnknown
	allocsfb587ba1.Borrow(ctiling_allocs)

	var cusage_allocs *cgoAllocMap
	reffb587ba1.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cusage_allocs)

	var csharingMode_allocs *cgoAllocMap
	reffb587ba1.sharingMode, csharingMode_allocs = (C.VkSharingMode)(x.SharingMode), cgoAllocsUnknown
	allocsfb587ba1.Borrow(csharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	reffb587ba1.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	reffb587ba1.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)).Data)), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cpQueueFamilyIndices_allocs)

	var cinitialLayout_allocs *cgoAllocMap
	reffb587ba1.initialLayout, cinitialLayout_allocs = (C.VkImageLayout)(x.InitialLayout), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cinitialLayout_allocs)

	x.reffb587ba1 = reffb587ba1
	x.allocsfb587ba1 = allocsfb587ba1
	return reffb587ba1, allocsfb587ba1

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ImageCreateInfo) PassValue() (C.VkImageCreateInfo, *cgoAllocMap) {
	if x.reffb587ba1 != nil {
		return *x.reffb587ba1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageCreateInfo) Deref() {
	if x.reffb587ba1 == nil {
		return
	}
	x.SType = (StructureType)(x.reffb587ba1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffb587ba1.pNext))
	x.Flags = (ImageCreateFlags)(x.reffb587ba1.flags)
	x.ImageType = (ImageType)(x.reffb587ba1.imageType)
	x.Format = (Format)(x.reffb587ba1.format)
	x.Extent = *NewExtent3DRef(&x.reffb587ba1.extent)
	x.MipLevels = (uint32)(x.reffb587ba1.mipLevels)
	x.ArrayLayers = (uint32)(x.reffb587ba1.arrayLayers)
	x.Samples = (SampleCountFlagBits)(x.reffb587ba1.samples)
	x.Tiling = (ImageTiling)(x.reffb587ba1.tiling)
	x.Usage = (ImageUsageFlags)(x.reffb587ba1.usage)
	x.SharingMode = (SharingMode)(x.reffb587ba1.sharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.reffb587ba1.queueFamilyIndexCount)
	hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf69fe70.Data = uintptr(unsafe.Pointer(x.reffb587ba1.pQueueFamilyIndices))
	hxf69fe70.Cap = 0x7fffffff
	// hxf69fe70.Len = ?

	x.InitialLayout = (ImageLayout)(x.reffb587ba1.initialLayout)
}

// allocSubresourceLayoutMemory allocates memory for type C.VkSubresourceLayout in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubresourceLayoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubresourceLayoutValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubresourceLayoutValue = unsafe.Sizeof([1]C.VkSubresourceLayout{})

// Ref returns a reference.
func (x *SubresourceLayout) Ref() *C.VkSubresourceLayout {
	if x == nil {
		return nil
	}
	return x.ref182612ad
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SubresourceLayout) Free() {
	if x != nil && x.allocs182612ad != nil {
		x.allocs182612ad.(*cgoAllocMap).Free()
		x.ref182612ad = nil
	}
}

// NewSubresourceLayoutRef initialises a new struct holding the reference to the originaitng C struct.
func NewSubresourceLayoutRef(ref interface{}) *SubresourceLayout {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SubresourceLayout)
	obj.ref182612ad = (*C.VkSubresourceLayout)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SubresourceLayout) PassRef() (*C.VkSubresourceLayout, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref182612ad != nil {
		return x.ref182612ad, nil
	}
	mem182612ad := allocSubresourceLayoutMemory(1)
	ref182612ad := (*C.VkSubresourceLayout)(mem182612ad)
	allocs182612ad := new(cgoAllocMap)
	var coffset_allocs *cgoAllocMap
	ref182612ad.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs182612ad.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref182612ad.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs182612ad.Borrow(csize_allocs)

	var crowPitch_allocs *cgoAllocMap
	ref182612ad.rowPitch, crowPitch_allocs = (C.VkDeviceSize)(x.RowPitch), cgoAllocsUnknown
	allocs182612ad.Borrow(crowPitch_allocs)

	var carrayPitch_allocs *cgoAllocMap
	ref182612ad.arrayPitch, carrayPitch_allocs = (C.VkDeviceSize)(x.ArrayPitch), cgoAllocsUnknown
	allocs182612ad.Borrow(carrayPitch_allocs)

	var cdepthPitch_allocs *cgoAllocMap
	ref182612ad.depthPitch, cdepthPitch_allocs = (C.VkDeviceSize)(x.DepthPitch), cgoAllocsUnknown
	allocs182612ad.Borrow(cdepthPitch_allocs)

	x.ref182612ad = ref182612ad
	x.allocs182612ad = allocs182612ad
	return ref182612ad, allocs182612ad

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SubresourceLayout) PassValue() (C.VkSubresourceLayout, *cgoAllocMap) {
	if x.ref182612ad != nil {
		return *x.ref182612ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SubresourceLayout) Deref() {
	if x.ref182612ad == nil {
		return
	}
	x.Offset = (DeviceSize)(x.ref182612ad.offset)
	x.Size = (DeviceSize)(x.ref182612ad.size)
	x.RowPitch = (DeviceSize)(x.ref182612ad.rowPitch)
	x.ArrayPitch = (DeviceSize)(x.ref182612ad.arrayPitch)
	x.DepthPitch = (DeviceSize)(x.ref182612ad.depthPitch)
}

// allocComponentMappingMemory allocates memory for type C.VkComponentMapping in C.
// The caller is responsible for freeing the this memory via C.free.
func allocComponentMappingMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfComponentMappingValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfComponentMappingValue = unsafe.Sizeof([1]C.VkComponentMapping{})

// Ref returns a reference.
func (x *ComponentMapping) Ref() *C.VkComponentMapping {
	if x == nil {
		return nil
	}
	return x.ref63d3d563
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ComponentMapping) Free() {
	if x != nil && x.allocs63d3d563 != nil {
		x.allocs63d3d563.(*cgoAllocMap).Free()
		x.ref63d3d563 = nil
	}
}

// NewComponentMappingRef initialises a new struct holding the reference to the originaitng C struct.
func NewComponentMappingRef(ref interface{}) *ComponentMapping {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ComponentMapping)
	obj.ref63d3d563 = (*C.VkComponentMapping)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ComponentMapping) PassRef() (*C.VkComponentMapping, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref63d3d563 != nil {
		return x.ref63d3d563, nil
	}
	mem63d3d563 := allocComponentMappingMemory(1)
	ref63d3d563 := (*C.VkComponentMapping)(mem63d3d563)
	allocs63d3d563 := new(cgoAllocMap)
	var cr_allocs *cgoAllocMap
	ref63d3d563.r, cr_allocs = (C.VkComponentSwizzle)(x.R), cgoAllocsUnknown
	allocs63d3d563.Borrow(cr_allocs)

	var cg_allocs *cgoAllocMap
	ref63d3d563.g, cg_allocs = (C.VkComponentSwizzle)(x.G), cgoAllocsUnknown
	allocs63d3d563.Borrow(cg_allocs)

	var cb_allocs *cgoAllocMap
	ref63d3d563.b, cb_allocs = (C.VkComponentSwizzle)(x.B), cgoAllocsUnknown
	allocs63d3d563.Borrow(cb_allocs)

	var ca_allocs *cgoAllocMap
	ref63d3d563.a, ca_allocs = (C.VkComponentSwizzle)(x.A), cgoAllocsUnknown
	allocs63d3d563.Borrow(ca_allocs)

	x.ref63d3d563 = ref63d3d563
	x.allocs63d3d563 = allocs63d3d563
	return ref63d3d563, allocs63d3d563

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ComponentMapping) PassValue() (C.VkComponentMapping, *cgoAllocMap) {
	if x.ref63d3d563 != nil {
		return *x.ref63d3d563, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ComponentMapping) Deref() {
	if x.ref63d3d563 == nil {
		return
	}
	x.R = (ComponentSwizzle)(x.ref63d3d563.r)
	x.G = (ComponentSwizzle)(x.ref63d3d563.g)
	x.B = (ComponentSwizzle)(x.ref63d3d563.b)
	x.A = (ComponentSwizzle)(x.ref63d3d563.a)
}

// allocImageSubresourceRangeMemory allocates memory for type C.VkImageSubresourceRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceRangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSubresourceRangeValue = unsafe.Sizeof([1]C.VkImageSubresourceRange{})

// Ref returns a reference.
func (x *ImageSubresourceRange) Ref() *C.VkImageSubresourceRange {
	if x == nil {
		return nil
	}
	return x.ref5aa1126
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageSubresourceRange) Free() {
	if x != nil && x.allocs5aa1126 != nil {
		x.allocs5aa1126.(*cgoAllocMap).Free()
		x.ref5aa1126 = nil
	}
}

// NewImageSubresourceRangeRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageSubresourceRangeRef(ref interface{}) *ImageSubresourceRange {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ImageSubresourceRange)
	obj.ref5aa1126 = (*C.VkImageSubresourceRange)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageSubresourceRange) PassRef() (*C.VkImageSubresourceRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5aa1126 != nil {
		return x.ref5aa1126, nil
	}
	mem5aa1126 := allocImageSubresourceRangeMemory(1)
	ref5aa1126 := (*C.VkImageSubresourceRange)(mem5aa1126)
	allocs5aa1126 := new(cgoAllocMap)
	var caspectMask_allocs *cgoAllocMap
	ref5aa1126.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs5aa1126.Borrow(caspectMask_allocs)

	var cbaseMipLevel_allocs *cgoAllocMap
	ref5aa1126.baseMipLevel, cbaseMipLevel_allocs = (C.uint32_t)(x.BaseMipLevel), cgoAllocsUnknown
	allocs5aa1126.Borrow(cbaseMipLevel_allocs)

	var clevelCount_allocs *cgoAllocMap
	ref5aa1126.levelCount, clevelCount_allocs = (C.uint32_t)(x.LevelCount), cgoAllocsUnknown
	allocs5aa1126.Borrow(clevelCount_allocs)

	var cbaseArrayLayer_allocs *cgoAllocMap
	ref5aa1126.baseArrayLayer, cbaseArrayLayer_allocs = (C.uint32_t)(x.BaseArrayLayer), cgoAllocsUnknown
	allocs5aa1126.Borrow(cbaseArrayLayer_allocs)

	var clayerCount_allocs *cgoAllocMap
	ref5aa1126.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocs5aa1126.Borrow(clayerCount_allocs)

	x.ref5aa1126 = ref5aa1126
	x.allocs5aa1126 = allocs5aa1126
	return ref5aa1126, allocs5aa1126

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ImageSubresourceRange) PassValue() (C.VkImageSubresourceRange, *cgoAllocMap) {
	if x.ref5aa1126 != nil {
		return *x.ref5aa1126, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageSubresourceRange) Deref() {
	if x.ref5aa1126 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.ref5aa1126.aspectMask)
	x.BaseMipLevel = (uint32)(x.ref5aa1126.baseMipLevel)
	x.LevelCount = (uint32)(x.ref5aa1126.levelCount)
	x.BaseArrayLayer = (uint32)(x.ref5aa1126.baseArrayLayer)
	x.LayerCount = (uint32)(x.ref5aa1126.layerCount)
}

// allocImageViewCreateInfoMemory allocates memory for type C.VkImageViewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageViewCreateInfoValue = unsafe.Sizeof([1]C.VkImageViewCreateInfo{})

// Ref returns a reference.
func (x *ImageViewCreateInfo) Ref() *C.VkImageViewCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref77e8d4b8
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageViewCreateInfo) Free() {
	if x != nil && x.allocs77e8d4b8 != nil {
		x.allocs77e8d4b8.(*cgoAllocMap).Free()
		x.ref77e8d4b8 = nil
	}
}

// NewImageViewCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageViewCreateInfoRef(ref interface{}) *ImageViewCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ImageViewCreateInfo)
	obj.ref77e8d4b8 = (*C.VkImageViewCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageViewCreateInfo) PassRef() (*C.VkImageViewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref77e8d4b8 != nil {
		return x.ref77e8d4b8, nil
	}
	mem77e8d4b8 := allocImageViewCreateInfoMemory(1)
	ref77e8d4b8 := (*C.VkImageViewCreateInfo)(mem77e8d4b8)
	allocs77e8d4b8 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref77e8d4b8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref77e8d4b8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref77e8d4b8.flags, cflags_allocs = (C.VkImageViewCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cflags_allocs)

	var cimage_allocs *cgoAllocMap
	ref77e8d4b8.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cimage_allocs)

	var cviewType_allocs *cgoAllocMap
	ref77e8d4b8.viewType, cviewType_allocs = (C.VkImageViewType)(x.ViewType), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cviewType_allocs)

	var cformat_allocs *cgoAllocMap
	ref77e8d4b8.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cformat_allocs)

	var ccomponents_allocs *cgoAllocMap
	ref77e8d4b8.components, ccomponents_allocs = x.Components.PassValue()
	allocs77e8d4b8.Borrow(ccomponents_allocs)

	var csubresourceRange_allocs *cgoAllocMap
	ref77e8d4b8.subresourceRange, csubresourceRange_allocs = x.SubresourceRange.PassValue()
	allocs77e8d4b8.Borrow(csubresourceRange_allocs)

	x.ref77e8d4b8 = ref77e8d4b8
	x.allocs77e8d4b8 = allocs77e8d4b8
	return ref77e8d4b8, allocs77e8d4b8

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ImageViewCreateInfo) PassValue() (C.VkImageViewCreateInfo, *cgoAllocMap) {
	if x.ref77e8d4b8 != nil {
		return *x.ref77e8d4b8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageViewCreateInfo) Deref() {
	if x.ref77e8d4b8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref77e8d4b8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref77e8d4b8.pNext))
	x.Flags = (ImageViewCreateFlags)(x.ref77e8d4b8.flags)
	x.Image = *(*Image)(unsafe.Pointer(&x.ref77e8d4b8.image))
	x.ViewType = (ImageViewType)(x.ref77e8d4b8.viewType)
	x.Format = (Format)(x.ref77e8d4b8.format)
	x.Components = *NewComponentMappingRef(&x.ref77e8d4b8.components)
	x.SubresourceRange = *NewImageSubresourceRangeRef(&x.ref77e8d4b8.subresourceRange)
}

// allocShaderModuleCreateInfoMemory allocates memory for type C.VkShaderModuleCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderModuleCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderModuleCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderModuleCreateInfoValue = unsafe.Sizeof([1]C.VkShaderModuleCreateInfo{})

// Ref returns a reference.
func (x *ShaderModuleCreateInfo) Ref() *C.VkShaderModuleCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc663d23e
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ShaderModuleCreateInfo) Free() {
	if x != nil && x.allocsc663d23e != nil {
		x.allocsc663d23e.(*cgoAllocMap).Free()
		x.refc663d23e = nil
	}
}

// NewShaderModuleCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewShaderModuleCreateInfoRef(ref interface{}) *ShaderModuleCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ShaderModuleCreateInfo)
	obj.refc663d23e = (*C.VkShaderModuleCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ShaderModuleCreateInfo) PassRef() (*C.VkShaderModuleCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc663d23e != nil {
		return x.refc663d23e, nil
	}
	memc663d23e := allocShaderModuleCreateInfoMemory(1)
	refc663d23e := (*C.VkShaderModuleCreateInfo)(memc663d23e)
	allocsc663d23e := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refc663d23e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc663d23e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc663d23e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc663d23e.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc663d23e.flags, cflags_allocs = (C.VkShaderModuleCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsc663d23e.Borrow(cflags_allocs)

	var ccodeSize_allocs *cgoAllocMap
	refc663d23e.codeSize, ccodeSize_allocs = (C.size_t)(x.CodeSize), cgoAllocsUnknown
	allocsc663d23e.Borrow(ccodeSize_allocs)

	var cpCode_allocs *cgoAllocMap
	refc663d23e.pCode, cpCode_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCode)).Data)), cgoAllocsUnknown
	allocsc663d23e.Borrow(cpCode_allocs)

	x.refc663d23e = refc663d23e
	x.allocsc663d23e = allocsc663d23e
	return refc663d23e, allocsc663d23e

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ShaderModuleCreateInfo) PassValue() (C.VkShaderModuleCreateInfo, *cgoAllocMap) {
	if x.refc663d23e != nil {
		return *x.refc663d23e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ShaderModuleCreateInfo) Deref() {
	if x.refc663d23e == nil {
		return
	}
	x.SType = (StructureType)(x.refc663d23e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc663d23e.pNext))
	x.Flags = (ShaderModuleCreateFlags)(x.refc663d23e.flags)
	x.CodeSize = (uint)(x.refc663d23e.codeSize)
	hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&x.PCode))
	hxf65bf54.Data = uintptr(unsafe.Pointer(x.refc663d23e.pCode))
	hxf65bf54.Cap = 0x7fffffff
	// hxf65bf54.Len = ?

}

// allocPipelineCacheCreateInfoMemory allocates memory for type C.VkPipelineCacheCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCacheCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCacheCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineCacheCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineCacheCreateInfo{})

// Ref returns a reference.
func (x *PipelineCacheCreateInfo) Ref() *C.VkPipelineCacheCreateInfo {
	if x == nil {
		return nil
	}
	return x.reff11e7dd1
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineCacheCreateInfo) Free() {
	if x != nil && x.allocsf11e7dd1 != nil {
		x.allocsf11e7dd1.(*cgoAllocMap).Free()
		x.reff11e7dd1 = nil
	}
}

// NewPipelineCacheCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineCacheCreateInfoRef(ref interface{}) *PipelineCacheCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PipelineCacheCreateInfo)
	obj.reff11e7dd1 = (*C.VkPipelineCacheCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineCacheCreateInfo) PassRef() (*C.VkPipelineCacheCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff11e7dd1 != nil {
		return x.reff11e7dd1, nil
	}
	memf11e7dd1 := allocPipelineCacheCreateInfoMemory(1)
	reff11e7dd1 := (*C.VkPipelineCacheCreateInfo)(memf11e7dd1)
	allocsf11e7dd1 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	reff11e7dd1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff11e7dd1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reff11e7dd1.flags, cflags_allocs = (C.VkPipelineCacheCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cflags_allocs)

	var cinitialDataSize_allocs *cgoAllocMap
	reff11e7dd1.initialDataSize, cinitialDataSize_allocs = (C.size_t)(x.InitialDataSize), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cinitialDataSize_allocs)

	var cpInitialData_allocs *cgoAllocMap
	reff11e7dd1.pInitialData, cpInitialData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PInitialData)), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cpInitialData_allocs)

	x.reff11e7dd1 = reff11e7dd1
	x.allocsf11e7dd1 = allocsf11e7dd1
	return reff11e7dd1, allocsf11e7dd1

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PipelineCacheCreateInfo) PassValue() (C.VkPipelineCacheCreateInfo, *cgoAllocMap) {
	if x.reff11e7dd1 != nil {
		return *x.reff11e7dd1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineCacheCreateInfo) Deref() {
	if x.reff11e7dd1 == nil {
		return
	}
	x.SType = (StructureType)(x.reff11e7dd1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff11e7dd1.pNext))
	x.Flags = (PipelineCacheCreateFlags)(x.reff11e7dd1.flags)
	x.InitialDataSize = (uint)(x.reff11e7dd1.initialDataSize)
	x.PInitialData = (unsafe.Pointer)(unsafe.Pointer(x.reff11e7dd1.pInitialData))
}

// allocSpecializationMapEntryMemory allocates memory for type C.VkSpecializationMapEntry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSpecializationMapEntryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSpecializationMapEntryValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSpecializationMapEntryValue = unsafe.Sizeof([1]C.VkSpecializationMapEntry{})

// Ref returns a reference.
func (x *SpecializationMapEntry) Ref() *C.VkSpecializationMapEntry {
	if x == nil {
		return nil
	}
	return x.ref2fd815d1
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SpecializationMapEntry) Free() {
	if x != nil && x.allocs2fd815d1 != nil {
		x.allocs2fd815d1.(*cgoAllocMap).Free()
		x.ref2fd815d1 = nil
	}
}

// NewSpecializationMapEntryRef initialises a new struct holding the reference to the originaitng C struct.
func NewSpecializationMapEntryRef(ref interface{}) *SpecializationMapEntry {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SpecializationMapEntry)
	obj.ref2fd815d1 = (*C.VkSpecializationMapEntry)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SpecializationMapEntry) PassRef() (*C.VkSpecializationMapEntry, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2fd815d1 != nil {
		return x.ref2fd815d1, nil
	}
	mem2fd815d1 := allocSpecializationMapEntryMemory(1)
	ref2fd815d1 := (*C.VkSpecializationMapEntry)(mem2fd815d1)
	allocs2fd815d1 := new(cgoAllocMap)
	var cconstantID_allocs *cgoAllocMap
	ref2fd815d1.constantID, cconstantID_allocs = (C.uint32_t)(x.ConstantID), cgoAllocsUnknown
	allocs2fd815d1.Borrow(cconstantID_allocs)

	var coffset_allocs *cgoAllocMap
	ref2fd815d1.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocs2fd815d1.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref2fd815d1.size, csize_allocs = (C.size_t)(x.Size), cgoAllocsUnknown
	allocs2fd815d1.Borrow(csize_allocs)

	x.ref2fd815d1 = ref2fd815d1
	x.allocs2fd815d1 = allocs2fd815d1
	return ref2fd815d1, allocs2fd815d1

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SpecializationMapEntry) PassValue() (C.VkSpecializationMapEntry, *cgoAllocMap) {
	if x.ref2fd815d1 != nil {
		return *x.ref2fd815d1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SpecializationMapEntry) Deref() {
	if x.ref2fd815d1 == nil {
		return
	}
	x.ConstantID = (uint32)(x.ref2fd815d1.constantID)
	x.Offset = (uint32)(x.ref2fd815d1.offset)
	x.Size = (uint)(x.ref2fd815d1.size)
}

// allocSpecializationInfoMemory allocates memory for type C.VkSpecializationInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSpecializationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSpecializationInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSpecializationInfoValue = unsafe.Sizeof([1]C.VkSpecializationInfo{})

// unpackSSpecializationMapEntry transforms a sliced Go data structure into plain C format.
func unpackSSpecializationMapEntry(x []SpecializationMapEntry) (unpacked *C.VkSpecializationMapEntry, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSpecializationMapEntry) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSpecializationMapEntryMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSpecializationMapEntry)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSpecializationMapEntry)(unsafe.Pointer(h.Data))
	return
}

// packSSpecializationMapEntry reads sliced Go data structure out from plain C format.
func packSSpecializationMapEntry(v []SpecializationMapEntry, ptr0 *C.VkSpecializationMapEntry) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSpecializationMapEntryValue]C.VkSpecializationMapEntry)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSpecializationMapEntryRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *SpecializationInfo) Ref() *C.VkSpecializationInfo {
	if x == nil {
		return nil
	}
	return x.ref6bc395a3
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SpecializationInfo) Free() {
	if x != nil && x.allocs6bc395a3 != nil {
		x.allocs6bc395a3.(*cgoAllocMap).Free()
		x.ref6bc395a3 = nil
	}
}

// NewSpecializationInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewSpecializationInfoRef(ref interface{}) *SpecializationInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SpecializationInfo)
	obj.ref6bc395a3 = (*C.VkSpecializationInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SpecializationInfo) PassRef() (*C.VkSpecializationInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6bc395a3 != nil {
		return x.ref6bc395a3, nil
	}
	mem6bc395a3 := allocSpecializationInfoMemory(1)
	ref6bc395a3 := (*C.VkSpecializationInfo)(mem6bc395a3)
	allocs6bc395a3 := new(cgoAllocMap)
	var cmapEntryCount_allocs *cgoAllocMap
	ref6bc395a3.mapEntryCount, cmapEntryCount_allocs = (C.uint32_t)(x.MapEntryCount), cgoAllocsUnknown
	allocs6bc395a3.Borrow(cmapEntryCount_allocs)

	var cpMapEntries_allocs *cgoAllocMap
	ref6bc395a3.pMapEntries, cpMapEntries_allocs = unpackSSpecializationMapEntry(x.PMapEntries)
	allocs6bc395a3.Borrow(cpMapEntries_allocs)

	var cdataSize_allocs *cgoAllocMap
	ref6bc395a3.dataSize, cdataSize_allocs = (C.size_t)(x.DataSize), cgoAllocsUnknown
	allocs6bc395a3.Borrow(cdataSize_allocs)

	var cpData_allocs *cgoAllocMap
	ref6bc395a3.pData, cpData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocs6bc395a3.Borrow(cpData_allocs)

	x.ref6bc395a3 = ref6bc395a3
	x.allocs6bc395a3 = allocs6bc395a3
	return ref6bc395a3, allocs6bc395a3

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SpecializationInfo) PassValue() (C.VkSpecializationInfo, *cgoAllocMap) {
	if x.ref6bc395a3 != nil {
		return *x.ref6bc395a3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SpecializationInfo) Deref() {
	if x.ref6bc395a3 == nil {
		return
	}
	x.MapEntryCount = (uint32)(x.ref6bc395a3.mapEntryCount)
	packSSpecializationMapEntry(x.PMapEntries, x.ref6bc395a3.pMapEntries)
	x.DataSize = (uint)(x.ref6bc395a3.dataSize)
	x.PData = (unsafe.Pointer)(unsafe.Pointer(x.ref6bc395a3.pData))
}

// allocPipelineShaderStageCreateInfoMemory allocates memory for type C.VkPipelineShaderStageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineShaderStageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineShaderStageCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineShaderStageCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineShaderStageCreateInfo{})

// unpackSSpecializationInfo transforms a sliced Go data structure into plain C format.
func unpackSSpecializationInfo(x []SpecializationInfo) (unpacked *C.VkSpecializationInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSpecializationInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSpecializationInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSpecializationInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSpecializationInfo)(unsafe.Pointer(h.Data))
	return
}

// packSSpecializationInfo reads sliced Go data structure out from plain C format.
func packSSpecializationInfo(v []SpecializationInfo, ptr0 *C.VkSpecializationInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSpecializationInfoValue]C.VkSpecializationInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSpecializationInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *PipelineShaderStageCreateInfo) Ref() *C.VkPipelineShaderStageCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref50ba8b60
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineShaderStageCreateInfo) Free() {
	if x != nil && x.allocs50ba8b60 != nil {
		x.allocs50ba8b60.(*cgoAllocMap).Free()
		x.ref50ba8b60 = nil
	}
}

// NewPipelineShaderStageCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineShaderStageCreateInfoRef(ref interface{}) *PipelineShaderStageCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PipelineShaderStageCreateInfo)
	obj.ref50ba8b60 = (*C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineShaderStageCreateInfo) PassRef() (*C.VkPipelineShaderStageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50ba8b60 != nil {
		return x.ref50ba8b60, nil
	}
	mem50ba8b60 := allocPipelineShaderStageCreateInfoMemory(1)
	ref50ba8b60 := (*C.VkPipelineShaderStageCreateInfo)(mem50ba8b60)
	allocs50ba8b60 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref50ba8b60.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs50ba8b60.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref50ba8b60.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref50ba8b60.flags, cflags_allocs = (C.VkPipelineShaderStageCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cflags_allocs)

	var cstage_allocs *cgoAllocMap
	ref50ba8b60.stage, cstage_allocs = (C.VkShaderStageFlagBits)(x.Stage), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cstage_allocs)

	var cmodule_allocs *cgoAllocMap
	ref50ba8b60.module, cmodule_allocs = *(*C.VkShaderModule)(unsafe.Pointer(&x.Module)), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cmodule_allocs)

	var cpName_allocs *cgoAllocMap
	ref50ba8b60.pName, cpName_allocs = unpackPCharString(x.PName)
	allocs50ba8b60.Borrow(cpName_allocs)

	var cpSpecializationInfo_allocs *cgoAllocMap
	ref50ba8b60.pSpecializationInfo, cpSpecializationInfo_allocs = unpackSSpecializationInfo(x.PSpecializationInfo)
	allocs50ba8b60.Borrow(cpSpecializationInfo_allocs)

	x.ref50ba8b60 = ref50ba8b60
	x.allocs50ba8b60 = allocs50ba8b60
	return ref50ba8b60, allocs50ba8b60

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PipelineShaderStageCreateInfo) PassValue() (C.VkPipelineShaderStageCreateInfo, *cgoAllocMap) {
	if x.ref50ba8b60 != nil {
		return *x.ref50ba8b60, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineShaderStageCreateInfo) Deref() {
	if x.ref50ba8b60 == nil {
		return
	}
	x.SType = (StructureType)(x.ref50ba8b60.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref50ba8b60.pNext))
	x.Flags = (PipelineShaderStageCreateFlags)(x.ref50ba8b60.flags)
	x.Stage = (ShaderStageFlagBits)(x.ref50ba8b60.stage)
	x.Module = *(*ShaderModule)(unsafe.Pointer(&x.ref50ba8b60.module))
	x.PName = packPCharString(x.ref50ba8b60.pName)
	packSSpecializationInfo(x.PSpecializationInfo, x.ref50ba8b60.pSpecializationInfo)
}

// allocVertexInputBindingDescriptionMemory allocates memory for type C.VkVertexInputBindingDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputBindingDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputBindingDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVertexInputBindingDescriptionValue = unsafe.Sizeof([1]C.VkVertexInputBindingDescription{})

// Ref returns a reference.
func (x *VertexInputBindingDescription) Ref() *C.VkVertexInputBindingDescription {
	if x == nil {
		return nil
	}
	return x.ref5c9d8c23
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *VertexInputBindingDescription) Free() {
	if x != nil && x.allocs5c9d8c23 != nil {
		x.allocs5c9d8c23.(*cgoAllocMap).Free()
		x.ref5c9d8c23 = nil
	}
}

// NewVertexInputBindingDescriptionRef initialises a new struct holding the reference to the originaitng C struct.
func NewVertexInputBindingDescriptionRef(ref interface{}) *VertexInputBindingDescription {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(VertexInputBindingDescription)
	obj.ref5c9d8c23 = (*C.VkVertexInputBindingDescription)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *VertexInputBindingDescription) PassRef() (*C.VkVertexInputBindingDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5c9d8c23 != nil {
		return x.ref5c9d8c23, nil
	}
	mem5c9d8c23 := allocVertexInputBindingDescriptionMemory(1)
	ref5c9d8c23 := (*C.VkVertexInputBindingDescription)(mem5c9d8c23)
	allocs5c9d8c23 := new(cgoAllocMap)
	var cbinding_allocs *cgoAllocMap
	ref5c9d8c23.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocs5c9d8c23.Borrow(cbinding_allocs)

	var cstride_allocs *cgoAllocMap
	ref5c9d8c23.stride, cstride_allocs = (C.uint32_t)(x.Stride), cgoAllocsUnknown
	allocs5c9d8c23.Borrow(cstride_allocs)

	var cinputRate_allocs *cgoAllocMap
	ref5c9d8c23.inputRate, cinputRate_allocs = (C.VkVertexInputRate)(x.InputRate), cgoAllocsUnknown
	allocs5c9d8c23.Borrow(cinputRate_allocs)

	x.ref5c9d8c23 = ref5c9d8c23
	x.allocs5c9d8c23 = allocs5c9d8c23
	return ref5c9d8c23, allocs5c9d8c23

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x VertexInputBindingDescription) PassValue() (C.VkVertexInputBindingDescription, *cgoAllocMap) {
	if x.ref5c9d8c23 != nil {
		return *x.ref5c9d8c23, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *VertexInputBindingDescription) Deref() {
	if x.ref5c9d8c23 == nil {
		return
	}
	x.Binding = (uint32)(x.ref5c9d8c23.binding)
	x.Stride = (uint32)(x.ref5c9d8c23.stride)
	x.InputRate = (VertexInputRate)(x.ref5c9d8c23.inputRate)
}

// allocVertexInputAttributeDescriptionMemory allocates memory for type C.VkVertexInputAttributeDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputAttributeDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputAttributeDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVertexInputAttributeDescriptionValue = unsafe.Sizeof([1]C.VkVertexInputAttributeDescription{})

// Ref returns a reference.
func (x *VertexInputAttributeDescription) Ref() *C.VkVertexInputAttributeDescription {
	if x == nil {
		return nil
	}
	return x.refdc4635ff
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *VertexInputAttributeDescription) Free() {
	if x != nil && x.allocsdc4635ff != nil {
		x.allocsdc4635ff.(*cgoAllocMap).Free()
		x.refdc4635ff = nil
	}
}

// NewVertexInputAttributeDescriptionRef initialises a new struct holding the reference to the originaitng C struct.
func NewVertexInputAttributeDescriptionRef(ref interface{}) *VertexInputAttributeDescription {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(VertexInputAttributeDescription)
	obj.refdc4635ff = (*C.VkVertexInputAttributeDescription)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *VertexInputAttributeDescription) PassRef() (*C.VkVertexInputAttributeDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdc4635ff != nil {
		return x.refdc4635ff, nil
	}
	memdc4635ff := allocVertexInputAttributeDescriptionMemory(1)
	refdc4635ff := (*C.VkVertexInputAttributeDescription)(memdc4635ff)
	allocsdc4635ff := new(cgoAllocMap)
	var clocation_allocs *cgoAllocMap
	refdc4635ff.location, clocation_allocs = (C.uint32_t)(x.Location), cgoAllocsUnknown
	allocsdc4635ff.Borrow(clocation_allocs)

	var cbinding_allocs *cgoAllocMap
	refdc4635ff.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocsdc4635ff.Borrow(cbinding_allocs)

	var cformat_allocs *cgoAllocMap
	refdc4635ff.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsdc4635ff.Borrow(cformat_allocs)

	var coffset_allocs *cgoAllocMap
	refdc4635ff.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocsdc4635ff.Borrow(coffset_allocs)

	x.refdc4635ff = refdc4635ff
	x.allocsdc4635ff = allocsdc4635ff
	return refdc4635ff, allocsdc4635ff

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x VertexInputAttributeDescription) PassValue() (C.VkVertexInputAttributeDescription, *cgoAllocMap) {
	if x.refdc4635ff != nil {
		return *x.refdc4635ff, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *VertexInputAttributeDescription) Deref() {
	if x.refdc4635ff == nil {
		return
	}
	x.Location = (uint32)(x.refdc4635ff.location)
	x.Binding = (uint32)(x.refdc4635ff.binding)
	x.Format = (Format)(x.refdc4635ff.format)
	x.Offset = (uint32)(x.refdc4635ff.offset)
}

// allocPipelineVertexInputStateCreateInfoMemory allocates memory for type C.VkPipelineVertexInputStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineVertexInputStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineVertexInputStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineVertexInputStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineVertexInputStateCreateInfo{})

// unpackSVertexInputBindingDescription transforms a sliced Go data structure into plain C format.
func unpackSVertexInputBindingDescription(x []VertexInputBindingDescription) (unpacked *C.VkVertexInputBindingDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkVertexInputBindingDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVertexInputBindingDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkVertexInputBindingDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkVertexInputBindingDescription)(unsafe.Pointer(h.Data))
	return
}

// unpackSVertexInputAttributeDescription transforms a sliced Go data structure into plain C format.
func unpackSVertexInputAttributeDescription(x []VertexInputAttributeDescription) (unpacked *C.VkVertexInputAttributeDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkVertexInputAttributeDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVertexInputAttributeDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkVertexInputAttributeDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkVertexInputAttributeDescription)(unsafe.Pointer(h.Data))
	return
}

// packSVertexInputBindingDescription reads sliced Go data structure out from plain C format.
func packSVertexInputBindingDescription(v []VertexInputBindingDescription, ptr0 *C.VkVertexInputBindingDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVertexInputBindingDescriptionValue]C.VkVertexInputBindingDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVertexInputBindingDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// packSVertexInputAttributeDescription reads sliced Go data structure out from plain C format.
func packSVertexInputAttributeDescription(v []VertexInputAttributeDescription, ptr0 *C.VkVertexInputAttributeDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVertexInputAttributeDescriptionValue]C.VkVertexInputAttributeDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVertexInputAttributeDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *PipelineVertexInputStateCreateInfo) Ref() *C.VkPipelineVertexInputStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5fe4aa50
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineVertexInputStateCreateInfo) Free() {
	if x != nil && x.allocs5fe4aa50 != nil {
		x.allocs5fe4aa50.(*cgoAllocMap).Free()
		x.ref5fe4aa50 = nil
	}
}

// NewPipelineVertexInputStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineVertexInputStateCreateInfoRef(ref interface{}) *PipelineVertexInputStateCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PipelineVertexInputStateCreateInfo)
	obj.ref5fe4aa50 = (*C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineVertexInputStateCreateInfo) PassRef() (*C.VkPipelineVertexInputStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fe4aa50 != nil {
		return x.ref5fe4aa50, nil
	}
	mem5fe4aa50 := allocPipelineVertexInputStateCreateInfoMemory(1)
	ref5fe4aa50 := (*C.VkPipelineVertexInputStateCreateInfo)(mem5fe4aa50)
	allocs5fe4aa50 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref5fe4aa50.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5fe4aa50.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5fe4aa50.flags, cflags_allocs = (C.VkPipelineVertexInputStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cflags_allocs)

	var cvertexBindingDescriptionCount_allocs *cgoAllocMap
	ref5fe4aa50.vertexBindingDescriptionCount, cvertexBindingDescriptionCount_allocs = (C.uint32_t)(x.VertexBindingDescriptionCount), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cvertexBindingDescriptionCount_allocs)

	var cpVertexBindingDescriptions_allocs *cgoAllocMap
	ref5fe4aa50.pVertexBindingDescriptions, cpVertexBindingDescriptions_allocs = unpackSVertexInputBindingDescription(x.PVertexBindingDescriptions)
	allocs5fe4aa50.Borrow(cpVertexBindingDescriptions_allocs)

	var cvertexAttributeDescriptionCount_allocs *cgoAllocMap
	ref5fe4aa50.vertexAttributeDescriptionCount, cvertexAttributeDescriptionCount_allocs = (C.uint32_t)(x.VertexAttributeDescriptionCount), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cvertexAttributeDescriptionCount_allocs)

	var cpVertexAttributeDescriptions_allocs *cgoAllocMap
	ref5fe4aa50.pVertexAttributeDescriptions, cpVertexAttributeDescriptions_allocs = unpackSVertexInputAttributeDescription(x.PVertexAttributeDescriptions)
	allocs5fe4aa50.Borrow(cpVertexAttributeDescriptions_allocs)

	x.ref5fe4aa50 = ref5fe4aa50
	x.allocs5fe4aa50 = allocs5fe4aa50
	return ref5fe4aa50, allocs5fe4aa50

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PipelineVertexInputStateCreateInfo) PassValue() (C.VkPipelineVertexInputStateCreateInfo, *cgoAllocMap) {
	if x.ref5fe4aa50 != nil {
		return *x.ref5fe4aa50, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineVertexInputStateCreateInfo) Deref() {
	if x.ref5fe4aa50 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5fe4aa50.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5fe4aa50.pNext))
	x.Flags = (PipelineVertexInputStateCreateFlags)(x.ref5fe4aa50.flags)
	x.VertexBindingDescriptionCount = (uint32)(x.ref5fe4aa50.vertexBindingDescriptionCount)
	packSVertexInputBindingDescription(x.PVertexBindingDescriptions, x.ref5fe4aa50.pVertexBindingDescriptions)
	x.VertexAttributeDescriptionCount = (uint32)(x.ref5fe4aa50.vertexAttributeDescriptionCount)
	packSVertexInputAttributeDescription(x.PVertexAttributeDescriptions, x.ref5fe4aa50.pVertexAttributeDescriptions)
}

// allocPipelineInputAssemblyStateCreateInfoMemory allocates memory for type C.VkPipelineInputAssemblyStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineInputAssemblyStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineInputAssemblyStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineInputAssemblyStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineInputAssemblyStateCreateInfo{})

// Ref returns a reference.
func (x *PipelineInputAssemblyStateCreateInfo) Ref() *C.VkPipelineInputAssemblyStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref22e1691d
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineInputAssemblyStateCreateInfo) Free() {
	if x != nil && x.allocs22e1691d != nil {
		x.allocs22e1691d.(*cgoAllocMap).Free()
		x.ref22e1691d = nil
	}
}

// NewPipelineInputAssemblyStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineInputAssemblyStateCreateInfoRef(ref interface{}) *PipelineInputAssemblyStateCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PipelineInputAssemblyStateCreateInfo)
	obj.ref22e1691d = (*C.VkPipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineInputAssemblyStateCreateInfo) PassRef() (*C.VkPipelineInputAssemblyStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref22e1691d != nil {
		return x.ref22e1691d, nil
	}
	mem22e1691d := allocPipelineInputAssemblyStateCreateInfoMemory(1)
	ref22e1691d := (*C.VkPipelineInputAssemblyStateCreateInfo)(mem22e1691d)
	allocs22e1691d := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref22e1691d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs22e1691d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref22e1691d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs22e1691d.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref22e1691d.flags, cflags_allocs = (C.VkPipelineInputAssemblyStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs22e1691d.Borrow(cflags_allocs)

	var ctopology_allocs *cgoAllocMap
	ref22e1691d.topology, ctopology_allocs = (C.VkPrimitiveTopology)(x.Topology), cgoAllocsUnknown
	allocs22e1691d.Borrow(ctopology_allocs)

	var cprimitiveRestartEnable_allocs *cgoAllocMap
	ref22e1691d.primitiveRestartEnable, cprimitiveRestartEnable_allocs = (C.VkBool32)(x.PrimitiveRestartEnable), cgoAllocsUnknown
	allocs22e1691d.Borrow(cprimitiveRestartEnable_allocs)

	x.ref22e1691d = ref22e1691d
	x.allocs22e1691d = allocs22e1691d
	return ref22e1691d, allocs22e1691d

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PipelineInputAssemblyStateCreateInfo) PassValue() (C.VkPipelineInputAssemblyStateCreateInfo, *cgoAllocMap) {
	if x.ref22e1691d != nil {
		return *x.ref22e1691d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineInputAssemblyStateCreateInfo) Deref() {
	if x.ref22e1691d == nil {
		return
	}
	x.SType = (StructureType)(x.ref22e1691d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref22e1691d.pNext))
	x.Flags = (PipelineInputAssemblyStateCreateFlags)(x.ref22e1691d.flags)
	x.Topology = (PrimitiveTopology)(x.ref22e1691d.topology)
	x.PrimitiveRestartEnable = (Bool32)(x.ref22e1691d.primitiveRestartEnable)
}

// allocPipelineTessellationStateCreateInfoMemory allocates memory for type C.VkPipelineTessellationStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineTessellationStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineTessellationStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineTessellationStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineTessellationStateCreateInfo{})

// Ref returns a reference.
func (x *PipelineTessellationStateCreateInfo) Ref() *C.VkPipelineTessellationStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref4ef3997a
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineTessellationStateCreateInfo) Free() {
	if x != nil && x.allocs4ef3997a != nil {
		x.allocs4ef3997a.(*cgoAllocMap).Free()
		x.ref4ef3997a = nil
	}
}

// NewPipelineTessellationStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineTessellationStateCreateInfoRef(ref interface{}) *PipelineTessellationStateCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PipelineTessellationStateCreateInfo)
	obj.ref4ef3997a = (*C.VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineTessellationStateCreateInfo) PassRef() (*C.VkPipelineTessellationStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4ef3997a != nil {
		return x.ref4ef3997a, nil
	}
	mem4ef3997a := allocPipelineTessellationStateCreateInfoMemory(1)
	ref4ef3997a := (*C.VkPipelineTessellationStateCreateInfo)(mem4ef3997a)
	allocs4ef3997a := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref4ef3997a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4ef3997a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4ef3997a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4ef3997a.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref4ef3997a.flags, cflags_allocs = (C.VkPipelineTessellationStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs4ef3997a.Borrow(cflags_allocs)

	var cpatchControlPoints_allocs *cgoAllocMap
	ref4ef3997a.patchControlPoints, cpatchControlPoints_allocs = (C.uint32_t)(x.PatchControlPoints), cgoAllocsUnknown
	allocs4ef3997a.Borrow(cpatchControlPoints_allocs)

	x.ref4ef3997a = ref4ef3997a
	x.allocs4ef3997a = allocs4ef3997a
	return ref4ef3997a, allocs4ef3997a

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PipelineTessellationStateCreateInfo) PassValue() (C.VkPipelineTessellationStateCreateInfo, *cgoAllocMap) {
	if x.ref4ef3997a != nil {
		return *x.ref4ef3997a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineTessellationStateCreateInfo) Deref() {
	if x.ref4ef3997a == nil {
		return
	}
	x.SType = (StructureType)(x.ref4ef3997a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4ef3997a.pNext))
	x.Flags = (PipelineTessellationStateCreateFlags)(x.ref4ef3997a.flags)
	x.PatchControlPoints = (uint32)(x.ref4ef3997a.patchControlPoints)
}

// allocViewportMemory allocates memory for type C.VkViewport in C.
// The caller is responsible for freeing the this memory via C.free.
func allocViewportMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfViewportValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfViewportValue = unsafe.Sizeof([1]C.VkViewport{})

// Ref returns a reference.
func (x *Viewport) Ref() *C.VkViewport {
	if x == nil {
		return nil
	}
	return x.ref75cf5291
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Viewport) Free() {
	if x != nil && x.allocs75cf5291 != nil {
		x.allocs75cf5291.(*cgoAllocMap).Free()
		x.ref75cf5291 = nil
	}
}

// NewViewportRef initialises a new struct holding the reference to the originaitng C struct.
func NewViewportRef(ref interface{}) *Viewport {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(Viewport)
	obj.ref75cf5291 = (*C.VkViewport)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Viewport) PassRef() (*C.VkViewport, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75cf5291 != nil {
		return x.ref75cf5291, nil
	}
	mem75cf5291 := allocViewportMemory(1)
	ref75cf5291 := (*C.VkViewport)(mem75cf5291)
	allocs75cf5291 := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	ref75cf5291.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs75cf5291.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref75cf5291.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs75cf5291.Borrow(cy_allocs)

	var cwidth_allocs *cgoAllocMap
	ref75cf5291.width, cwidth_allocs = (C.float)(x.Width), cgoAllocsUnknown
	allocs75cf5291.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref75cf5291.height, cheight_allocs = (C.float)(x.Height), cgoAllocsUnknown
	allocs75cf5291.Borrow(cheight_allocs)

	var cminDepth_allocs *cgoAllocMap
	ref75cf5291.minDepth, cminDepth_allocs = (C.float)(x.MinDepth), cgoAllocsUnknown
	allocs75cf5291.Borrow(cminDepth_allocs)

	var cmaxDepth_allocs *cgoAllocMap
	ref75cf5291.maxDepth, cmaxDepth_allocs = (C.float)(x.MaxDepth), cgoAllocsUnknown
	allocs75cf5291.Borrow(cmaxDepth_allocs)

	x.ref75cf5291 = ref75cf5291
	x.allocs75cf5291 = allocs75cf5291
	return ref75cf5291, allocs75cf5291

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x Viewport) PassValue() (C.VkViewport, *cgoAllocMap) {
	if x.ref75cf5291 != nil {
		return *x.ref75cf5291, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Viewport) Deref() {
	if x.ref75cf5291 == nil {
		return
	}
	x.X = (float32)(x.ref75cf5291.x)
	x.Y = (float32)(x.ref75cf5291.y)
	x.Width = (float32)(x.ref75cf5291.width)
	x.Height = (float32)(x.ref75cf5291.height)
	x.MinDepth = (float32)(x.ref75cf5291.minDepth)
	x.MaxDepth = (float32)(x.ref75cf5291.maxDepth)
}

// allocOffset2DMemory allocates memory for type C.VkOffset2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOffset2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOffset2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOffset2DValue = unsafe.Sizeof([1]C.VkOffset2D{})

// Ref returns a reference.
func (x *Offset2D) Ref() *C.VkOffset2D {
	if x == nil {
		return nil
	}
	return x.ref32734883
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Offset2D) Free() {
	if x != nil && x.allocs32734883 != nil {
		x.allocs32734883.(*cgoAllocMap).Free()
		x.ref32734883 = nil
	}
}

// NewOffset2DRef initialises a new struct holding the reference to the originaitng C struct.
func NewOffset2DRef(ref interface{}) *Offset2D {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(Offset2D)
	obj.ref32734883 = (*C.VkOffset2D)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Offset2D) PassRef() (*C.VkOffset2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref32734883 != nil {
		return x.ref32734883, nil
	}
	mem32734883 := allocOffset2DMemory(1)
	ref32734883 := (*C.VkOffset2D)(mem32734883)
	allocs32734883 := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	ref32734883.x, cx_allocs = (C.int32_t)(x.X), cgoAllocsUnknown
	allocs32734883.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref32734883.y, cy_allocs = (C.int32_t)(x.Y), cgoAllocsUnknown
	allocs32734883.Borrow(cy_allocs)

	x.ref32734883 = ref32734883
	x.allocs32734883 = allocs32734883
	return ref32734883, allocs32734883

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x Offset2D) PassValue() (C.VkOffset2D, *cgoAllocMap) {
	if x.ref32734883 != nil {
		return *x.ref32734883, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Offset2D) Deref() {
	if x.ref32734883 == nil {
		return
	}
	x.X = (int32)(x.ref32734883.x)
	x.Y = (int32)(x.ref32734883.y)
}

// allocExtent2DMemory allocates memory for type C.VkExtent2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtent2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtent2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExtent2DValue = unsafe.Sizeof([1]C.VkExtent2D{})

// Ref returns a reference.
func (x *Extent2D) Ref() *C.VkExtent2D {
	if x == nil {
		return nil
	}
	return x.refe2edf56b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Extent2D) Free() {
	if x != nil && x.allocse2edf56b != nil {
		x.allocse2edf56b.(*cgoAllocMap).Free()
		x.refe2edf56b = nil
	}
}

// NewExtent2DRef initialises a new struct holding the reference to the originaitng C struct.
func NewExtent2DRef(ref interface{}) *Extent2D {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(Extent2D)
	obj.refe2edf56b = (*C.VkExtent2D)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Extent2D) PassRef() (*C.VkExtent2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe2edf56b != nil {
		return x.refe2edf56b, nil
	}
	meme2edf56b := allocExtent2DMemory(1)
	refe2edf56b := (*C.VkExtent2D)(meme2edf56b)
	allocse2edf56b := new(cgoAllocMap)
	var cwidth_allocs *cgoAllocMap
	refe2edf56b.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocse2edf56b.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refe2edf56b.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocse2edf56b.Borrow(cheight_allocs)

	x.refe2edf56b = refe2edf56b
	x.allocse2edf56b = allocse2edf56b
	return refe2edf56b, allocse2edf56b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x Extent2D) PassValue() (C.VkExtent2D, *cgoAllocMap) {
	if x.refe2edf56b != nil {
		return *x.refe2edf56b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Extent2D) Deref() {
	if x.refe2edf56b == nil {
		return
	}
	x.Width = (uint32)(x.refe2edf56b.width)
	x.Height = (uint32)(x.refe2edf56b.height)
}

// allocRect2DMemory allocates memory for type C.VkRect2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRect2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRect2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRect2DValue = unsafe.Sizeof([1]C.VkRect2D{})

// Ref returns a reference.
func (x *Rect2D) Ref() *C.VkRect2D {
	if x == nil {
		return nil
	}
	return x.ref89e4256f
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Rect2D) Free() {
	if x != nil && x.allocs89e4256f != nil {
		x.allocs89e4256f.(*cgoAllocMap).Free()
		x.ref89e4256f = nil
	}
}

// NewRect2DRef initialises a new struct holding the reference to the originaitng C struct.
func NewRect2DRef(ref interface{}) *Rect2D {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(Rect2D)
	obj.ref89e4256f = (*C.VkRect2D)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Rect2D) PassRef() (*C.VkRect2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref89e4256f != nil {
		return x.ref89e4256f, nil
	}
	mem89e4256f := allocRect2DMemory(1)
	ref89e4256f := (*C.VkRect2D)(mem89e4256f)
	allocs89e4256f := new(cgoAllocMap)
	var coffset_allocs *cgoAllocMap
	ref89e4256f.offset, coffset_allocs = x.Offset.PassValue()
	allocs89e4256f.Borrow(coffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref89e4256f.extent, cextent_allocs = x.Extent.PassValue()
	allocs89e4256f.Borrow(cextent_allocs)

	x.ref89e4256f = ref89e4256f
	x.allocs89e4256f = allocs89e4256f
	return ref89e4256f, allocs89e4256f

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x Rect2D) PassValue() (C.VkRect2D, *cgoAllocMap) {
	if x.ref89e4256f != nil {
		return *x.ref89e4256f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Rect2D) Deref() {
	if x.ref89e4256f == nil {
		return
	}
	x.Offset = *NewOffset2DRef(&x.ref89e4256f.offset)
	x.Extent = *NewExtent2DRef(&x.ref89e4256f.extent)
}

// allocPipelineViewportStateCreateInfoMemory allocates memory for type C.VkPipelineViewportStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineViewportStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineViewportStateCreateInfo{})

// unpackSViewport transforms a sliced Go data structure into plain C format.
func unpackSViewport(x []Viewport) (unpacked *C.VkViewport, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkViewport) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocViewportMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewport)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewport)(unsafe.Pointer(h.Data))
	return
}

// unpackSRect2D transforms a sliced Go data structure into plain C format.
func unpackSRect2D(x []Rect2D) (unpacked *C.VkRect2D, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkRect2D) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRect2DMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRect2D)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRect2D)(unsafe.Pointer(h.Data))
	return
}

// packSViewport reads sliced Go data structure out from plain C format.
func packSViewport(v []Viewport, ptr0 *C.VkViewport) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfViewportValue]C.VkViewport)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewViewportRef(unsafe.Pointer(&ptr1))
	}
}

// packSRect2D reads sliced Go data structure out from plain C format.
func packSRect2D(v []Rect2D, ptr0 *C.VkRect2D) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRect2DValue]C.VkRect2D)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRect2DRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *PipelineViewportStateCreateInfo) Ref() *C.VkPipelineViewportStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc4705791
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineViewportStateCreateInfo) Free() {
	if x != nil && x.allocsc4705791 != nil {
		x.allocsc4705791.(*cgoAllocMap).Free()
		x.refc4705791 = nil
	}
}

// NewPipelineViewportStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineViewportStateCreateInfoRef(ref interface{}) *PipelineViewportStateCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PipelineViewportStateCreateInfo)
	obj.refc4705791 = (*C.VkPipelineViewportStateCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineViewportStateCreateInfo) PassRef() (*C.VkPipelineViewportStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc4705791 != nil {
		return x.refc4705791, nil
	}
	memc4705791 := allocPipelineViewportStateCreateInfoMemory(1)
	refc4705791 := (*C.VkPipelineViewportStateCreateInfo)(memc4705791)
	allocsc4705791 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refc4705791.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc4705791.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc4705791.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc4705791.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc4705791.flags, cflags_allocs = (C.VkPipelineViewportStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsc4705791.Borrow(cflags_allocs)

	var cviewportCount_allocs *cgoAllocMap
	refc4705791.viewportCount, cviewportCount_allocs = (C.uint32_t)(x.ViewportCount), cgoAllocsUnknown
	allocsc4705791.Borrow(cviewportCount_allocs)

	var cpViewports_allocs *cgoAllocMap
	refc4705791.pViewports, cpViewports_allocs = unpackSViewport(x.PViewports)
	allocsc4705791.Borrow(cpViewports_allocs)

	var cscissorCount_allocs *cgoAllocMap
	refc4705791.scissorCount, cscissorCount_allocs = (C.uint32_t)(x.ScissorCount), cgoAllocsUnknown
	allocsc4705791.Borrow(cscissorCount_allocs)

	var cpScissors_allocs *cgoAllocMap
	refc4705791.pScissors, cpScissors_allocs = unpackSRect2D(x.PScissors)
	allocsc4705791.Borrow(cpScissors_allocs)

	x.refc4705791 = refc4705791
	x.allocsc4705791 = allocsc4705791
	return refc4705791, allocsc4705791

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PipelineViewportStateCreateInfo) PassValue() (C.VkPipelineViewportStateCreateInfo, *cgoAllocMap) {
	if x.refc4705791 != nil {
		return *x.refc4705791, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineViewportStateCreateInfo) Deref() {
	if x.refc4705791 == nil {
		return
	}
	x.SType = (StructureType)(x.refc4705791.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc4705791.pNext))
	x.Flags = (PipelineViewportStateCreateFlags)(x.refc4705791.flags)
	x.ViewportCount = (uint32)(x.refc4705791.viewportCount)
	packSViewport(x.PViewports, x.refc4705791.pViewports)
	x.ScissorCount = (uint32)(x.refc4705791.scissorCount)
	packSRect2D(x.PScissors, x.refc4705791.pScissors)
}

// allocPipelineRasterizationStateCreateInfoMemory allocates memory for type C.VkPipelineRasterizationStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineRasterizationStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineRasterizationStateCreateInfo{})

// Ref returns a reference.
func (x *PipelineRasterizationStateCreateInfo) Ref() *C.VkPipelineRasterizationStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref48cb9fad
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineRasterizationStateCreateInfo) Free() {
	if x != nil && x.allocs48cb9fad != nil {
		x.allocs48cb9fad.(*cgoAllocMap).Free()
		x.ref48cb9fad = nil
	}
}

// NewPipelineRasterizationStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineRasterizationStateCreateInfoRef(ref interface{}) *PipelineRasterizationStateCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PipelineRasterizationStateCreateInfo)
	obj.ref48cb9fad = (*C.VkPipelineRasterizationStateCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineRasterizationStateCreateInfo) PassRef() (*C.VkPipelineRasterizationStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref48cb9fad != nil {
		return x.ref48cb9fad, nil
	}
	mem48cb9fad := allocPipelineRasterizationStateCreateInfoMemory(1)
	ref48cb9fad := (*C.VkPipelineRasterizationStateCreateInfo)(mem48cb9fad)
	allocs48cb9fad := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref48cb9fad.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs48cb9fad.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref48cb9fad.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref48cb9fad.flags, cflags_allocs = (C.VkPipelineRasterizationStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cflags_allocs)

	var cdepthClampEnable_allocs *cgoAllocMap
	ref48cb9fad.depthClampEnable, cdepthClampEnable_allocs = (C.VkBool32)(x.DepthClampEnable), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthClampEnable_allocs)

	var crasterizerDiscardEnable_allocs *cgoAllocMap
	ref48cb9fad.rasterizerDiscardEnable, crasterizerDiscardEnable_allocs = (C.VkBool32)(x.RasterizerDiscardEnable), cgoAllocsUnknown
	allocs48cb9fad.Borrow(crasterizerDiscardEnable_allocs)

	var cpolygonMode_allocs *cgoAllocMap
	ref48cb9fad.polygonMode, cpolygonMode_allocs = (C.VkPolygonMode)(x.PolygonMode), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cpolygonMode_allocs)

	var ccullMode_allocs *cgoAllocMap
	ref48cb9fad.cullMode, ccullMode_allocs = (C.VkCullModeFlags)(x.CullMode), cgoAllocsUnknown
	allocs48cb9fad.Borrow(ccullMode_allocs)

	var cfrontFace_allocs *cgoAllocMap
	ref48cb9fad.frontFace, cfrontFace_allocs = (C.VkFrontFace)(x.FrontFace), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cfrontFace_allocs)

	var cdepthBiasEnable_allocs *cgoAllocMap
	ref48cb9fad.depthBiasEnable, cdepthBiasEnable_allocs = (C.VkBool32)(x.DepthBiasEnable), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasEnable_allocs)

	var cdepthBiasConstantFactor_allocs *cgoAllocMap
	ref48cb9fad.depthBiasConstantFactor, cdepthBiasConstantFactor_allocs = (C.float)(x.DepthBiasConstantFactor), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasConstantFactor_allocs)

	var cdepthBiasClamp_allocs *cgoAllocMap
	ref48cb9fad.depthBiasClamp, cdepthBiasClamp_allocs = (C.float)(x.DepthBiasClamp), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasClamp_allocs)

	var cdepthBiasSlopeFactor_allocs *cgoAllocMap
	ref48cb9fad.depthBiasSlopeFactor, cdepthBiasSlopeFactor_allocs = (C.float)(x.DepthBiasSlopeFactor), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasSlopeFactor_allocs)

	var clineWidth_allocs *cgoAllocMap
	ref48cb9fad.lineWidth, clineWidth_allocs = (C.float)(x.LineWidth), cgoAllocsUnknown
	allocs48cb9fad.Borrow(clineWidth_allocs)

	x.ref48cb9fad = ref48cb9fad
	x.allocs48cb9fad = allocs48cb9fad
	return ref48cb9fad, allocs48cb9fad

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PipelineRasterizationStateCreateInfo) PassValue() (C.VkPipelineRasterizationStateCreateInfo, *cgoAllocMap) {
	if x.ref48cb9fad != nil {
		return *x.ref48cb9fad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineRasterizationStateCreateInfo) Deref() {
	if x.ref48cb9fad == nil {
		return
	}
	x.SType = (StructureType)(x.ref48cb9fad.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref48cb9fad.pNext))
	x.Flags = (PipelineRasterizationStateCreateFlags)(x.ref48cb9fad.flags)
	x.DepthClampEnable = (Bool32)(x.ref48cb9fad.depthClampEnable)
	x.RasterizerDiscardEnable = (Bool32)(x.ref48cb9fad.rasterizerDiscardEnable)
	x.PolygonMode = (PolygonMode)(x.ref48cb9fad.polygonMode)
	x.CullMode = (CullModeFlags)(x.ref48cb9fad.cullMode)
	x.FrontFace = (FrontFace)(x.ref48cb9fad.frontFace)
	x.DepthBiasEnable = (Bool32)(x.ref48cb9fad.depthBiasEnable)
	x.DepthBiasConstantFactor = (float32)(x.ref48cb9fad.depthBiasConstantFactor)
	x.DepthBiasClamp = (float32)(x.ref48cb9fad.depthBiasClamp)
	x.DepthBiasSlopeFactor = (float32)(x.ref48cb9fad.depthBiasSlopeFactor)
	x.LineWidth = (float32)(x.ref48cb9fad.lineWidth)
}

// allocPipelineMultisampleStateCreateInfoMemory allocates memory for type C.VkPipelineMultisampleStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineMultisampleStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineMultisampleStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineMultisampleStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineMultisampleStateCreateInfo{})

// Ref returns a reference.
func (x *PipelineMultisampleStateCreateInfo) Ref() *C.VkPipelineMultisampleStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb6538bfb
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineMultisampleStateCreateInfo) Free() {
	if x != nil && x.allocsb6538bfb != nil {
		x.allocsb6538bfb.(*cgoAllocMap).Free()
		x.refb6538bfb = nil
	}
}

// NewPipelineMultisampleStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineMultisampleStateCreateInfoRef(ref interface{}) *PipelineMultisampleStateCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PipelineMultisampleStateCreateInfo)
	obj.refb6538bfb = (*C.VkPipelineMultisampleStateCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineMultisampleStateCreateInfo) PassRef() (*C.VkPipelineMultisampleStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb6538bfb != nil {
		return x.refb6538bfb, nil
	}
	memb6538bfb := allocPipelineMultisampleStateCreateInfoMemory(1)
	refb6538bfb := (*C.VkPipelineMultisampleStateCreateInfo)(memb6538bfb)
	allocsb6538bfb := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refb6538bfb.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb6538bfb.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb6538bfb.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refb6538bfb.flags, cflags_allocs = (C.VkPipelineMultisampleStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cflags_allocs)

	var crasterizationSamples_allocs *cgoAllocMap
	refb6538bfb.rasterizationSamples, crasterizationSamples_allocs = (C.VkSampleCountFlagBits)(x.RasterizationSamples), cgoAllocsUnknown
	allocsb6538bfb.Borrow(crasterizationSamples_allocs)

	var csampleShadingEnable_allocs *cgoAllocMap
	refb6538bfb.sampleShadingEnable, csampleShadingEnable_allocs = (C.VkBool32)(x.SampleShadingEnable), cgoAllocsUnknown
	allocsb6538bfb.Borrow(csampleShadingEnable_allocs)

	var cminSampleShading_allocs *cgoAllocMap
	refb6538bfb.minSampleShading, cminSampleShading_allocs = (C.float)(x.MinSampleShading), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cminSampleShading_allocs)

	var cpSampleMask_allocs *cgoAllocMap
	refb6538bfb.pSampleMask, cpSampleMask_allocs = (*C.VkSampleMask)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSampleMask)).Data)), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cpSampleMask_allocs)

	var calphaToCoverageEnable_allocs *cgoAllocMap
	refb6538bfb.alphaToCoverageEnable, calphaToCoverageEnable_allocs = (C.VkBool32)(x.AlphaToCoverageEnable), cgoAllocsUnknown
	allocsb6538bfb.Borrow(calphaToCoverageEnable_allocs)

	var calphaToOneEnable_allocs *cgoAllocMap
	refb6538bfb.alphaToOneEnable, calphaToOneEnable_allocs = (C.VkBool32)(x.AlphaToOneEnable), cgoAllocsUnknown
	allocsb6538bfb.Borrow(calphaToOneEnable_allocs)

	x.refb6538bfb = refb6538bfb
	x.allocsb6538bfb = allocsb6538bfb
	return refb6538bfb, allocsb6538bfb

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PipelineMultisampleStateCreateInfo) PassValue() (C.VkPipelineMultisampleStateCreateInfo, *cgoAllocMap) {
	if x.refb6538bfb != nil {
		return *x.refb6538bfb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineMultisampleStateCreateInfo) Deref() {
	if x.refb6538bfb == nil {
		return
	}
	x.SType = (StructureType)(x.refb6538bfb.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb6538bfb.pNext))
	x.Flags = (PipelineMultisampleStateCreateFlags)(x.refb6538bfb.flags)
	x.RasterizationSamples = (SampleCountFlagBits)(x.refb6538bfb.rasterizationSamples)
	x.SampleShadingEnable = (Bool32)(x.refb6538bfb.sampleShadingEnable)
	x.MinSampleShading = (float32)(x.refb6538bfb.minSampleShading)
	hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&x.PSampleMask))
	hxf3b8dbd.Data = uintptr(unsafe.Pointer(x.refb6538bfb.pSampleMask))
	hxf3b8dbd.Cap = 0x7fffffff
	// hxf3b8dbd.Len = ?

	x.AlphaToCoverageEnable = (Bool32)(x.refb6538bfb.alphaToCoverageEnable)
	x.AlphaToOneEnable = (Bool32)(x.refb6538bfb.alphaToOneEnable)
}

// allocStencilOpStateMemory allocates memory for type C.VkStencilOpState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStencilOpStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStencilOpStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStencilOpStateValue = unsafe.Sizeof([1]C.VkStencilOpState{})

// Ref returns a reference.
func (x *StencilOpState) Ref() *C.VkStencilOpState {
	if x == nil {
		return nil
	}
	return x.ref28886871
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *StencilOpState) Free() {
	if x != nil && x.allocs28886871 != nil {
		x.allocs28886871.(*cgoAllocMap).Free()
		x.ref28886871 = nil
	}
}

// NewStencilOpStateRef initialises a new struct holding the reference to the originaitng C struct.
func NewStencilOpStateRef(ref interface{}) *StencilOpState {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(StencilOpState)
	obj.ref28886871 = (*C.VkStencilOpState)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *StencilOpState) PassRef() (*C.VkStencilOpState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref28886871 != nil {
		return x.ref28886871, nil
	}
	mem28886871 := allocStencilOpStateMemory(1)
	ref28886871 := (*C.VkStencilOpState)(mem28886871)
	allocs28886871 := new(cgoAllocMap)
	var cfailOp_allocs *cgoAllocMap
	ref28886871.failOp, cfailOp_allocs = (C.VkStencilOp)(x.FailOp), cgoAllocsUnknown
	allocs28886871.Borrow(cfailOp_allocs)

	var cpassOp_allocs *cgoAllocMap
	ref28886871.passOp, cpassOp_allocs = (C.VkStencilOp)(x.PassOp), cgoAllocsUnknown
	allocs28886871.Borrow(cpassOp_allocs)

	var cdepthFailOp_allocs *cgoAllocMap
	ref28886871.depthFailOp, cdepthFailOp_allocs = (C.VkStencilOp)(x.DepthFailOp), cgoAllocsUnknown
	allocs28886871.Borrow(cdepthFailOp_allocs)

	var ccompareOp_allocs *cgoAllocMap
	ref28886871.compareOp, ccompareOp_allocs = (C.VkCompareOp)(x.CompareOp), cgoAllocsUnknown
	allocs28886871.Borrow(ccompareOp_allocs)

	var ccompareMask_allocs *cgoAllocMap
	ref28886871.compareMask, ccompareMask_allocs = (C.uint32_t)(x.CompareMask), cgoAllocsUnknown
	allocs28886871.Borrow(ccompareMask_allocs)

	var cwriteMask_allocs *cgoAllocMap
	ref28886871.writeMask, cwriteMask_allocs = (C.uint32_t)(x.WriteMask), cgoAllocsUnknown
	allocs28886871.Borrow(cwriteMask_allocs)

	var creference_allocs *cgoAllocMap
	ref28886871.reference, creference_allocs = (C.uint32_t)(x.Reference), cgoAllocsUnknown
	allocs28886871.Borrow(creference_allocs)

	x.ref28886871 = ref28886871
	x.allocs28886871 = allocs28886871
	return ref28886871, allocs28886871

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x StencilOpState) PassValue() (C.VkStencilOpState, *cgoAllocMap) {
	if x.ref28886871 != nil {
		return *x.ref28886871, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *StencilOpState) Deref() {
	if x.ref28886871 == nil {
		return
	}
	x.FailOp = (StencilOp)(x.ref28886871.failOp)
	x.PassOp = (StencilOp)(x.ref28886871.passOp)
	x.DepthFailOp = (StencilOp)(x.ref28886871.depthFailOp)
	x.CompareOp = (CompareOp)(x.ref28886871.compareOp)
	x.CompareMask = (uint32)(x.ref28886871.compareMask)
	x.WriteMask = (uint32)(x.ref28886871.writeMask)
	x.Reference = (uint32)(x.ref28886871.reference)
}

// allocPipelineDepthStencilStateCreateInfoMemory allocates memory for type C.VkPipelineDepthStencilStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineDepthStencilStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineDepthStencilStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineDepthStencilStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineDepthStencilStateCreateInfo{})

// Ref returns a reference.
func (x *PipelineDepthStencilStateCreateInfo) Ref() *C.VkPipelineDepthStencilStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refeabfcf1
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineDepthStencilStateCreateInfo) Free() {
	if x != nil && x.allocseabfcf1 != nil {
		x.allocseabfcf1.(*cgoAllocMap).Free()
		x.refeabfcf1 = nil
	}
}

// NewPipelineDepthStencilStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineDepthStencilStateCreateInfoRef(ref interface{}) *PipelineDepthStencilStateCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PipelineDepthStencilStateCreateInfo)
	obj.refeabfcf1 = (*C.VkPipelineDepthStencilStateCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineDepthStencilStateCreateInfo) PassRef() (*C.VkPipelineDepthStencilStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeabfcf1 != nil {
		return x.refeabfcf1, nil
	}
	memeabfcf1 := allocPipelineDepthStencilStateCreateInfoMemory(1)
	refeabfcf1 := (*C.VkPipelineDepthStencilStateCreateInfo)(memeabfcf1)
	allocseabfcf1 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refeabfcf1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseabfcf1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeabfcf1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseabfcf1.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refeabfcf1.flags, cflags_allocs = (C.VkPipelineDepthStencilStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocseabfcf1.Borrow(cflags_allocs)

	var cdepthTestEnable_allocs *cgoAllocMap
	refeabfcf1.depthTestEnable, cdepthTestEnable_allocs = (C.VkBool32)(x.DepthTestEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthTestEnable_allocs)

	var cdepthWriteEnable_allocs *cgoAllocMap
	refeabfcf1.depthWriteEnable, cdepthWriteEnable_allocs = (C.VkBool32)(x.DepthWriteEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthWriteEnable_allocs)

	var cdepthCompareOp_allocs *cgoAllocMap
	refeabfcf1.depthCompareOp, cdepthCompareOp_allocs = (C.VkCompareOp)(x.DepthCompareOp), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthCompareOp_allocs)

	var cdepthBoundsTestEnable_allocs *cgoAllocMap
	refeabfcf1.depthBoundsTestEnable, cdepthBoundsTestEnable_allocs = (C.VkBool32)(x.DepthBoundsTestEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthBoundsTestEnable_allocs)

	var cstencilTestEnable_allocs *cgoAllocMap
	refeabfcf1.stencilTestEnable, cstencilTestEnable_allocs = (C.VkBool32)(x.StencilTestEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cstencilTestEnable_allocs)

	var cfront_allocs *cgoAllocMap
	refeabfcf1.front, cfront_allocs = x.Front.PassValue()
	allocseabfcf1.Borrow(cfront_allocs)

	var cback_allocs *cgoAllocMap
	refeabfcf1.back, cback_allocs = x.Back.PassValue()
	allocseabfcf1.Borrow(cback_allocs)

	var cminDepthBounds_allocs *cgoAllocMap
	refeabfcf1.minDepthBounds, cminDepthBounds_allocs = (C.float)(x.MinDepthBounds), cgoAllocsUnknown
	allocseabfcf1.Borrow(cminDepthBounds_allocs)

	var cmaxDepthBounds_allocs *cgoAllocMap
	refeabfcf1.maxDepthBounds, cmaxDepthBounds_allocs = (C.float)(x.MaxDepthBounds), cgoAllocsUnknown
	allocseabfcf1.Borrow(cmaxDepthBounds_allocs)

	x.refeabfcf1 = refeabfcf1
	x.allocseabfcf1 = allocseabfcf1
	return refeabfcf1, allocseabfcf1

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PipelineDepthStencilStateCreateInfo) PassValue() (C.VkPipelineDepthStencilStateCreateInfo, *cgoAllocMap) {
	if x.refeabfcf1 != nil {
		return *x.refeabfcf1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineDepthStencilStateCreateInfo) Deref() {
	if x.refeabfcf1 == nil {
		return
	}
	x.SType = (StructureType)(x.refeabfcf1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeabfcf1.pNext))
	x.Flags = (PipelineDepthStencilStateCreateFlags)(x.refeabfcf1.flags)
	x.DepthTestEnable = (Bool32)(x.refeabfcf1.depthTestEnable)
	x.DepthWriteEnable = (Bool32)(x.refeabfcf1.depthWriteEnable)
	x.DepthCompareOp = (CompareOp)(x.refeabfcf1.depthCompareOp)
	x.DepthBoundsTestEnable = (Bool32)(x.refeabfcf1.depthBoundsTestEnable)
	x.StencilTestEnable = (Bool32)(x.refeabfcf1.stencilTestEnable)
	x.Front = *NewStencilOpStateRef(&x.refeabfcf1.front)
	x.Back = *NewStencilOpStateRef(&x.refeabfcf1.back)
	x.MinDepthBounds = (float32)(x.refeabfcf1.minDepthBounds)
	x.MaxDepthBounds = (float32)(x.refeabfcf1.maxDepthBounds)
}

// allocPipelineColorBlendAttachmentStateMemory allocates memory for type C.VkPipelineColorBlendAttachmentState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorBlendAttachmentStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorBlendAttachmentStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineColorBlendAttachmentStateValue = unsafe.Sizeof([1]C.VkPipelineColorBlendAttachmentState{})

// Ref returns a reference.
func (x *PipelineColorBlendAttachmentState) Ref() *C.VkPipelineColorBlendAttachmentState {
	if x == nil {
		return nil
	}
	return x.ref9e889477
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineColorBlendAttachmentState) Free() {
	if x != nil && x.allocs9e889477 != nil {
		x.allocs9e889477.(*cgoAllocMap).Free()
		x.ref9e889477 = nil
	}
}

// NewPipelineColorBlendAttachmentStateRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineColorBlendAttachmentStateRef(ref interface{}) *PipelineColorBlendAttachmentState {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PipelineColorBlendAttachmentState)
	obj.ref9e889477 = (*C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineColorBlendAttachmentState) PassRef() (*C.VkPipelineColorBlendAttachmentState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9e889477 != nil {
		return x.ref9e889477, nil
	}
	mem9e889477 := allocPipelineColorBlendAttachmentStateMemory(1)
	ref9e889477 := (*C.VkPipelineColorBlendAttachmentState)(mem9e889477)
	allocs9e889477 := new(cgoAllocMap)
	var cblendEnable_allocs *cgoAllocMap
	ref9e889477.blendEnable, cblendEnable_allocs = (C.VkBool32)(x.BlendEnable), cgoAllocsUnknown
	allocs9e889477.Borrow(cblendEnable_allocs)

	var csrcColorBlendFactor_allocs *cgoAllocMap
	ref9e889477.srcColorBlendFactor, csrcColorBlendFactor_allocs = (C.VkBlendFactor)(x.SrcColorBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(csrcColorBlendFactor_allocs)

	var cdstColorBlendFactor_allocs *cgoAllocMap
	ref9e889477.dstColorBlendFactor, cdstColorBlendFactor_allocs = (C.VkBlendFactor)(x.DstColorBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(cdstColorBlendFactor_allocs)

	var ccolorBlendOp_allocs *cgoAllocMap
	ref9e889477.colorBlendOp, ccolorBlendOp_allocs = (C.VkBlendOp)(x.ColorBlendOp), cgoAllocsUnknown
	allocs9e889477.Borrow(ccolorBlendOp_allocs)

	var csrcAlphaBlendFactor_allocs *cgoAllocMap
	ref9e889477.srcAlphaBlendFactor, csrcAlphaBlendFactor_allocs = (C.VkBlendFactor)(x.SrcAlphaBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(csrcAlphaBlendFactor_allocs)

	var cdstAlphaBlendFactor_allocs *cgoAllocMap
	ref9e889477.dstAlphaBlendFactor, cdstAlphaBlendFactor_allocs = (C.VkBlendFactor)(x.DstAlphaBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(cdstAlphaBlendFactor_allocs)

	var calphaBlendOp_allocs *cgoAllocMap
	ref9e889477.alphaBlendOp, calphaBlendOp_allocs = (C.VkBlendOp)(x.AlphaBlendOp), cgoAllocsUnknown
	allocs9e889477.Borrow(calphaBlendOp_allocs)

	var ccolorWriteMask_allocs *cgoAllocMap
	ref9e889477.colorWriteMask, ccolorWriteMask_allocs = (C.VkColorComponentFlags)(x.ColorWriteMask), cgoAllocsUnknown
	allocs9e889477.Borrow(ccolorWriteMask_allocs)

	x.ref9e889477 = ref9e889477
	x.allocs9e889477 = allocs9e889477
	return ref9e889477, allocs9e889477

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PipelineColorBlendAttachmentState) PassValue() (C.VkPipelineColorBlendAttachmentState, *cgoAllocMap) {
	if x.ref9e889477 != nil {
		return *x.ref9e889477, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineColorBlendAttachmentState) Deref() {
	if x.ref9e889477 == nil {
		return
	}
	x.BlendEnable = (Bool32)(x.ref9e889477.blendEnable)
	x.SrcColorBlendFactor = (BlendFactor)(x.ref9e889477.srcColorBlendFactor)
	x.DstColorBlendFactor = (BlendFactor)(x.ref9e889477.dstColorBlendFactor)
	x.ColorBlendOp = (BlendOp)(x.ref9e889477.colorBlendOp)
	x.SrcAlphaBlendFactor = (BlendFactor)(x.ref9e889477.srcAlphaBlendFactor)
	x.DstAlphaBlendFactor = (BlendFactor)(x.ref9e889477.dstAlphaBlendFactor)
	x.AlphaBlendOp = (BlendOp)(x.ref9e889477.alphaBlendOp)
	x.ColorWriteMask = (ColorComponentFlags)(x.ref9e889477.colorWriteMask)
}

// allocPipelineColorBlendStateCreateInfoMemory allocates memory for type C.VkPipelineColorBlendStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorBlendStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorBlendStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineColorBlendStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineColorBlendStateCreateInfo{})

// unpackSPipelineColorBlendAttachmentState transforms a sliced Go data structure into plain C format.
func unpackSPipelineColorBlendAttachmentState(x []PipelineColorBlendAttachmentState) (unpacked *C.VkPipelineColorBlendAttachmentState, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineColorBlendAttachmentState) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineColorBlendAttachmentStateMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(h.Data))
	return
}

// packSPipelineColorBlendAttachmentState reads sliced Go data structure out from plain C format.
func packSPipelineColorBlendAttachmentState(v []PipelineColorBlendAttachmentState, ptr0 *C.VkPipelineColorBlendAttachmentState) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineColorBlendAttachmentStateValue]C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineColorBlendAttachmentStateRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *PipelineColorBlendStateCreateInfo) Ref() *C.VkPipelineColorBlendStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref2a9b490b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineColorBlendStateCreateInfo) Free() {
	if x != nil && x.allocs2a9b490b != nil {
		x.allocs2a9b490b.(*cgoAllocMap).Free()
		x.ref2a9b490b = nil
	}
}

// NewPipelineColorBlendStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineColorBlendStateCreateInfoRef(ref interface{}) *PipelineColorBlendStateCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PipelineColorBlendStateCreateInfo)
	obj.ref2a9b490b = (*C.VkPipelineColorBlendStateCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineColorBlendStateCreateInfo) PassRef() (*C.VkPipelineColorBlendStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2a9b490b != nil {
		return x.ref2a9b490b, nil
	}
	mem2a9b490b := allocPipelineColorBlendStateCreateInfoMemory(1)
	ref2a9b490b := (*C.VkPipelineColorBlendStateCreateInfo)(mem2a9b490b)
	allocs2a9b490b := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref2a9b490b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2a9b490b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2a9b490b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref2a9b490b.flags, cflags_allocs = (C.VkPipelineColorBlendStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cflags_allocs)

	var clogicOpEnable_allocs *cgoAllocMap
	ref2a9b490b.logicOpEnable, clogicOpEnable_allocs = (C.VkBool32)(x.LogicOpEnable), cgoAllocsUnknown
	allocs2a9b490b.Borrow(clogicOpEnable_allocs)

	var clogicOp_allocs *cgoAllocMap
	ref2a9b490b.logicOp, clogicOp_allocs = (C.VkLogicOp)(x.LogicOp), cgoAllocsUnknown
	allocs2a9b490b.Borrow(clogicOp_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	ref2a9b490b.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	ref2a9b490b.pAttachments, cpAttachments_allocs = unpackSPipelineColorBlendAttachmentState(x.PAttachments)
	allocs2a9b490b.Borrow(cpAttachments_allocs)

	var cblendConstants_allocs *cgoAllocMap
	ref2a9b490b.blendConstants, cblendConstants_allocs = *(*[4]C.float)(unsafe.Pointer(&x.BlendConstants)), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cblendConstants_allocs)

	x.ref2a9b490b = ref2a9b490b
	x.allocs2a9b490b = allocs2a9b490b
	return ref2a9b490b, allocs2a9b490b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PipelineColorBlendStateCreateInfo) PassValue() (C.VkPipelineColorBlendStateCreateInfo, *cgoAllocMap) {
	if x.ref2a9b490b != nil {
		return *x.ref2a9b490b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineColorBlendStateCreateInfo) Deref() {
	if x.ref2a9b490b == nil {
		return
	}
	x.SType = (StructureType)(x.ref2a9b490b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2a9b490b.pNext))
	x.Flags = (PipelineColorBlendStateCreateFlags)(x.ref2a9b490b.flags)
	x.LogicOpEnable = (Bool32)(x.ref2a9b490b.logicOpEnable)
	x.LogicOp = (LogicOp)(x.ref2a9b490b.logicOp)
	x.AttachmentCount = (uint32)(x.ref2a9b490b.attachmentCount)
	packSPipelineColorBlendAttachmentState(x.PAttachments, x.ref2a9b490b.pAttachments)
	x.BlendConstants = *(*[4]float32)(unsafe.Pointer(&x.ref2a9b490b.blendConstants))
}

// allocPipelineDynamicStateCreateInfoMemory allocates memory for type C.VkPipelineDynamicStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineDynamicStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineDynamicStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineDynamicStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineDynamicStateCreateInfo{})

// Ref returns a reference.
func (x *PipelineDynamicStateCreateInfo) Ref() *C.VkPipelineDynamicStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref246d7bc8
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineDynamicStateCreateInfo) Free() {
	if x != nil && x.allocs246d7bc8 != nil {
		x.allocs246d7bc8.(*cgoAllocMap).Free()
		x.ref246d7bc8 = nil
	}
}

// NewPipelineDynamicStateCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineDynamicStateCreateInfoRef(ref interface{}) *PipelineDynamicStateCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PipelineDynamicStateCreateInfo)
	obj.ref246d7bc8 = (*C.VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineDynamicStateCreateInfo) PassRef() (*C.VkPipelineDynamicStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref246d7bc8 != nil {
		return x.ref246d7bc8, nil
	}
	mem246d7bc8 := allocPipelineDynamicStateCreateInfoMemory(1)
	ref246d7bc8 := (*C.VkPipelineDynamicStateCreateInfo)(mem246d7bc8)
	allocs246d7bc8 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref246d7bc8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs246d7bc8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref246d7bc8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref246d7bc8.flags, cflags_allocs = (C.VkPipelineDynamicStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cflags_allocs)

	var cdynamicStateCount_allocs *cgoAllocMap
	ref246d7bc8.dynamicStateCount, cdynamicStateCount_allocs = (C.uint32_t)(x.DynamicStateCount), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cdynamicStateCount_allocs)

	var cpDynamicStates_allocs *cgoAllocMap
	ref246d7bc8.pDynamicStates, cpDynamicStates_allocs = (*C.VkDynamicState)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDynamicStates)).Data)), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cpDynamicStates_allocs)

	x.ref246d7bc8 = ref246d7bc8
	x.allocs246d7bc8 = allocs246d7bc8
	return ref246d7bc8, allocs246d7bc8

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PipelineDynamicStateCreateInfo) PassValue() (C.VkPipelineDynamicStateCreateInfo, *cgoAllocMap) {
	if x.ref246d7bc8 != nil {
		return *x.ref246d7bc8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineDynamicStateCreateInfo) Deref() {
	if x.ref246d7bc8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref246d7bc8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref246d7bc8.pNext))
	x.Flags = (PipelineDynamicStateCreateFlags)(x.ref246d7bc8.flags)
	x.DynamicStateCount = (uint32)(x.ref246d7bc8.dynamicStateCount)
	hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&x.PDynamicStates))
	hxf7a6dff.Data = uintptr(unsafe.Pointer(x.ref246d7bc8.pDynamicStates))
	hxf7a6dff.Cap = 0x7fffffff
	// hxf7a6dff.Len = ?

}

// allocGraphicsPipelineCreateInfoMemory allocates memory for type C.VkGraphicsPipelineCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGraphicsPipelineCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGraphicsPipelineCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGraphicsPipelineCreateInfoValue = unsafe.Sizeof([1]C.VkGraphicsPipelineCreateInfo{})

// unpackSPipelineShaderStageCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineShaderStageCreateInfo(x []PipelineShaderStageCreateInfo) (unpacked *C.VkPipelineShaderStageCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineShaderStageCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineShaderStageCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineVertexInputStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineVertexInputStateCreateInfo(x []PipelineVertexInputStateCreateInfo) (unpacked *C.VkPipelineVertexInputStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineVertexInputStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineVertexInputStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineInputAssemblyStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineInputAssemblyStateCreateInfo(x []PipelineInputAssemblyStateCreateInfo) (unpacked *C.VkPipelineInputAssemblyStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineInputAssemblyStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineInputAssemblyStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineTessellationStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineTessellationStateCreateInfo(x []PipelineTessellationStateCreateInfo) (unpacked *C.VkPipelineTessellationStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineTessellationStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineTessellationStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineViewportStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineViewportStateCreateInfo(x []PipelineViewportStateCreateInfo) (unpacked *C.VkPipelineViewportStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineViewportStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineViewportStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineViewportStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineViewportStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineRasterizationStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineRasterizationStateCreateInfo(x []PipelineRasterizationStateCreateInfo) (unpacked *C.VkPipelineRasterizationStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineRasterizationStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineRasterizationStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineRasterizationStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineRasterizationStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineMultisampleStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineMultisampleStateCreateInfo(x []PipelineMultisampleStateCreateInfo) (unpacked *C.VkPipelineMultisampleStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineMultisampleStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineMultisampleStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineMultisampleStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineMultisampleStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineDepthStencilStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineDepthStencilStateCreateInfo(x []PipelineDepthStencilStateCreateInfo) (unpacked *C.VkPipelineDepthStencilStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineDepthStencilStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineDepthStencilStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineDepthStencilStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineDepthStencilStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineColorBlendStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineColorBlendStateCreateInfo(x []PipelineColorBlendStateCreateInfo) (unpacked *C.VkPipelineColorBlendStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineColorBlendStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineColorBlendStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineColorBlendStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineColorBlendStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSPipelineDynamicStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineDynamicStateCreateInfo(x []PipelineDynamicStateCreateInfo) (unpacked *C.VkPipelineDynamicStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineDynamicStateCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineDynamicStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// packSPipelineShaderStageCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineShaderStageCreateInfo(v []PipelineShaderStageCreateInfo, ptr0 *C.VkPipelineShaderStageCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineShaderStageCreateInfoValue]C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineShaderStageCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineVertexInputStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineVertexInputStateCreateInfo(v []PipelineVertexInputStateCreateInfo, ptr0 *C.VkPipelineVertexInputStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineVertexInputStateCreateInfoValue]C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineVertexInputStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineInputAssemblyStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineInputAssemblyStateCreateInfo(v []PipelineInputAssemblyStateCreateInfo, ptr0 *C.VkPipelineInputAssemblyStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineInputAssemblyStateCreateInfoValue]C.VkPipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineInputAssemblyStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineTessellationStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineTessellationStateCreateInfo(v []PipelineTessellationStateCreateInfo, ptr0 *C.VkPipelineTessellationStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineTessellationStateCreateInfoValue]C.VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineTessellationStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineViewportStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineViewportStateCreateInfo(v []PipelineViewportStateCreateInfo, ptr0 *C.VkPipelineViewportStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineViewportStateCreateInfoValue]C.VkPipelineViewportStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineViewportStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineRasterizationStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineRasterizationStateCreateInfo(v []PipelineRasterizationStateCreateInfo, ptr0 *C.VkPipelineRasterizationStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineRasterizationStateCreateInfoValue]C.VkPipelineRasterizationStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineRasterizationStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineMultisampleStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineMultisampleStateCreateInfo(v []PipelineMultisampleStateCreateInfo, ptr0 *C.VkPipelineMultisampleStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineMultisampleStateCreateInfoValue]C.VkPipelineMultisampleStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineMultisampleStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineDepthStencilStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineDepthStencilStateCreateInfo(v []PipelineDepthStencilStateCreateInfo, ptr0 *C.VkPipelineDepthStencilStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineDepthStencilStateCreateInfoValue]C.VkPipelineDepthStencilStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineDepthStencilStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineColorBlendStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineColorBlendStateCreateInfo(v []PipelineColorBlendStateCreateInfo, ptr0 *C.VkPipelineColorBlendStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineColorBlendStateCreateInfoValue]C.VkPipelineColorBlendStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineColorBlendStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineDynamicStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineDynamicStateCreateInfo(v []PipelineDynamicStateCreateInfo, ptr0 *C.VkPipelineDynamicStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineDynamicStateCreateInfoValue]C.VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineDynamicStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *GraphicsPipelineCreateInfo) Ref() *C.VkGraphicsPipelineCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref178f88b6
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *GraphicsPipelineCreateInfo) Free() {
	if x != nil && x.allocs178f88b6 != nil {
		x.allocs178f88b6.(*cgoAllocMap).Free()
		x.ref178f88b6 = nil
	}
}

// NewGraphicsPipelineCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewGraphicsPipelineCreateInfoRef(ref interface{}) *GraphicsPipelineCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(GraphicsPipelineCreateInfo)
	obj.ref178f88b6 = (*C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *GraphicsPipelineCreateInfo) PassRef() (*C.VkGraphicsPipelineCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref178f88b6 != nil {
		return x.ref178f88b6, nil
	}
	mem178f88b6 := allocGraphicsPipelineCreateInfoMemory(1)
	ref178f88b6 := (*C.VkGraphicsPipelineCreateInfo)(mem178f88b6)
	allocs178f88b6 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref178f88b6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs178f88b6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref178f88b6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs178f88b6.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref178f88b6.flags, cflags_allocs = (C.VkPipelineCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs178f88b6.Borrow(cflags_allocs)

	var cstageCount_allocs *cgoAllocMap
	ref178f88b6.stageCount, cstageCount_allocs = (C.uint32_t)(x.StageCount), cgoAllocsUnknown
	allocs178f88b6.Borrow(cstageCount_allocs)

	var cpStages_allocs *cgoAllocMap
	ref178f88b6.pStages, cpStages_allocs = unpackSPipelineShaderStageCreateInfo(x.PStages)
	allocs178f88b6.Borrow(cpStages_allocs)

	var cpVertexInputState_allocs *cgoAllocMap
	ref178f88b6.pVertexInputState, cpVertexInputState_allocs = unpackSPipelineVertexInputStateCreateInfo(x.PVertexInputState)
	allocs178f88b6.Borrow(cpVertexInputState_allocs)

	var cpInputAssemblyState_allocs *cgoAllocMap
	ref178f88b6.pInputAssemblyState, cpInputAssemblyState_allocs = unpackSPipelineInputAssemblyStateCreateInfo(x.PInputAssemblyState)
	allocs178f88b6.Borrow(cpInputAssemblyState_allocs)

	var cpTessellationState_allocs *cgoAllocMap
	ref178f88b6.pTessellationState, cpTessellationState_allocs = unpackSPipelineTessellationStateCreateInfo(x.PTessellationState)
	allocs178f88b6.Borrow(cpTessellationState_allocs)

	var cpViewportState_allocs *cgoAllocMap
	ref178f88b6.pViewportState, cpViewportState_allocs = unpackSPipelineViewportStateCreateInfo(x.PViewportState)
	allocs178f88b6.Borrow(cpViewportState_allocs)

	var cpRasterizationState_allocs *cgoAllocMap
	ref178f88b6.pRasterizationState, cpRasterizationState_allocs = unpackSPipelineRasterizationStateCreateInfo(x.PRasterizationState)
	allocs178f88b6.Borrow(cpRasterizationState_allocs)

	var cpMultisampleState_allocs *cgoAllocMap
	ref178f88b6.pMultisampleState, cpMultisampleState_allocs = unpackSPipelineMultisampleStateCreateInfo(x.PMultisampleState)
	allocs178f88b6.Borrow(cpMultisampleState_allocs)

	var cpDepthStencilState_allocs *cgoAllocMap
	ref178f88b6.pDepthStencilState, cpDepthStencilState_allocs = unpackSPipelineDepthStencilStateCreateInfo(x.PDepthStencilState)
	allocs178f88b6.Borrow(cpDepthStencilState_allocs)

	var cpColorBlendState_allocs *cgoAllocMap
	ref178f88b6.pColorBlendState, cpColorBlendState_allocs = unpackSPipelineColorBlendStateCreateInfo(x.PColorBlendState)
	allocs178f88b6.Borrow(cpColorBlendState_allocs)

	var cpDynamicState_allocs *cgoAllocMap
	ref178f88b6.pDynamicState, cpDynamicState_allocs = unpackSPipelineDynamicStateCreateInfo(x.PDynamicState)
	allocs178f88b6.Borrow(cpDynamicState_allocs)

	var clayout_allocs *cgoAllocMap
	ref178f88b6.layout, clayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.Layout)), cgoAllocsUnknown
	allocs178f88b6.Borrow(clayout_allocs)

	var crenderPass_allocs *cgoAllocMap
	ref178f88b6.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocs178f88b6.Borrow(crenderPass_allocs)

	var csubpass_allocs *cgoAllocMap
	ref178f88b6.subpass, csubpass_allocs = (C.uint32_t)(x.Subpass), cgoAllocsUnknown
	allocs178f88b6.Borrow(csubpass_allocs)

	var cbasePipelineHandle_allocs *cgoAllocMap
	ref178f88b6.basePipelineHandle, cbasePipelineHandle_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.BasePipelineHandle)), cgoAllocsUnknown
	allocs178f88b6.Borrow(cbasePipelineHandle_allocs)

	var cbasePipelineIndex_allocs *cgoAllocMap
	ref178f88b6.basePipelineIndex, cbasePipelineIndex_allocs = (C.int32_t)(x.BasePipelineIndex), cgoAllocsUnknown
	allocs178f88b6.Borrow(cbasePipelineIndex_allocs)

	x.ref178f88b6 = ref178f88b6
	x.allocs178f88b6 = allocs178f88b6
	return ref178f88b6, allocs178f88b6

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x GraphicsPipelineCreateInfo) PassValue() (C.VkGraphicsPipelineCreateInfo, *cgoAllocMap) {
	if x.ref178f88b6 != nil {
		return *x.ref178f88b6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *GraphicsPipelineCreateInfo) Deref() {
	if x.ref178f88b6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref178f88b6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref178f88b6.pNext))
	x.Flags = (PipelineCreateFlags)(x.ref178f88b6.flags)
	x.StageCount = (uint32)(x.ref178f88b6.stageCount)
	packSPipelineShaderStageCreateInfo(x.PStages, x.ref178f88b6.pStages)
	packSPipelineVertexInputStateCreateInfo(x.PVertexInputState, x.ref178f88b6.pVertexInputState)
	packSPipelineInputAssemblyStateCreateInfo(x.PInputAssemblyState, x.ref178f88b6.pInputAssemblyState)
	packSPipelineTessellationStateCreateInfo(x.PTessellationState, x.ref178f88b6.pTessellationState)
	packSPipelineViewportStateCreateInfo(x.PViewportState, x.ref178f88b6.pViewportState)
	packSPipelineRasterizationStateCreateInfo(x.PRasterizationState, x.ref178f88b6.pRasterizationState)
	packSPipelineMultisampleStateCreateInfo(x.PMultisampleState, x.ref178f88b6.pMultisampleState)
	packSPipelineDepthStencilStateCreateInfo(x.PDepthStencilState, x.ref178f88b6.pDepthStencilState)
	packSPipelineColorBlendStateCreateInfo(x.PColorBlendState, x.ref178f88b6.pColorBlendState)
	packSPipelineDynamicStateCreateInfo(x.PDynamicState, x.ref178f88b6.pDynamicState)
	x.Layout = *(*PipelineLayout)(unsafe.Pointer(&x.ref178f88b6.layout))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref178f88b6.renderPass))
	x.Subpass = (uint32)(x.ref178f88b6.subpass)
	x.BasePipelineHandle = *(*Pipeline)(unsafe.Pointer(&x.ref178f88b6.basePipelineHandle))
	x.BasePipelineIndex = (int32)(x.ref178f88b6.basePipelineIndex)
}

// allocComputePipelineCreateInfoMemory allocates memory for type C.VkComputePipelineCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocComputePipelineCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfComputePipelineCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfComputePipelineCreateInfoValue = unsafe.Sizeof([1]C.VkComputePipelineCreateInfo{})

// Ref returns a reference.
func (x *ComputePipelineCreateInfo) Ref() *C.VkComputePipelineCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref77823220
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ComputePipelineCreateInfo) Free() {
	if x != nil && x.allocs77823220 != nil {
		x.allocs77823220.(*cgoAllocMap).Free()
		x.ref77823220 = nil
	}
}

// NewComputePipelineCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewComputePipelineCreateInfoRef(ref interface{}) *ComputePipelineCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ComputePipelineCreateInfo)
	obj.ref77823220 = (*C.VkComputePipelineCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ComputePipelineCreateInfo) PassRef() (*C.VkComputePipelineCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref77823220 != nil {
		return x.ref77823220, nil
	}
	mem77823220 := allocComputePipelineCreateInfoMemory(1)
	ref77823220 := (*C.VkComputePipelineCreateInfo)(mem77823220)
	allocs77823220 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref77823220.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs77823220.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref77823220.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs77823220.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref77823220.flags, cflags_allocs = (C.VkPipelineCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs77823220.Borrow(cflags_allocs)

	var cstage_allocs *cgoAllocMap
	ref77823220.stage, cstage_allocs = x.Stage.PassValue()
	allocs77823220.Borrow(cstage_allocs)

	var clayout_allocs *cgoAllocMap
	ref77823220.layout, clayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.Layout)), cgoAllocsUnknown
	allocs77823220.Borrow(clayout_allocs)

	var cbasePipelineHandle_allocs *cgoAllocMap
	ref77823220.basePipelineHandle, cbasePipelineHandle_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.BasePipelineHandle)), cgoAllocsUnknown
	allocs77823220.Borrow(cbasePipelineHandle_allocs)

	var cbasePipelineIndex_allocs *cgoAllocMap
	ref77823220.basePipelineIndex, cbasePipelineIndex_allocs = (C.int32_t)(x.BasePipelineIndex), cgoAllocsUnknown
	allocs77823220.Borrow(cbasePipelineIndex_allocs)

	x.ref77823220 = ref77823220
	x.allocs77823220 = allocs77823220
	return ref77823220, allocs77823220

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ComputePipelineCreateInfo) PassValue() (C.VkComputePipelineCreateInfo, *cgoAllocMap) {
	if x.ref77823220 != nil {
		return *x.ref77823220, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ComputePipelineCreateInfo) Deref() {
	if x.ref77823220 == nil {
		return
	}
	x.SType = (StructureType)(x.ref77823220.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref77823220.pNext))
	x.Flags = (PipelineCreateFlags)(x.ref77823220.flags)
	x.Stage = *NewPipelineShaderStageCreateInfoRef(&x.ref77823220.stage)
	x.Layout = *(*PipelineLayout)(unsafe.Pointer(&x.ref77823220.layout))
	x.BasePipelineHandle = *(*Pipeline)(unsafe.Pointer(&x.ref77823220.basePipelineHandle))
	x.BasePipelineIndex = (int32)(x.ref77823220.basePipelineIndex)
}

// allocPushConstantRangeMemory allocates memory for type C.VkPushConstantRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPushConstantRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPushConstantRangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPushConstantRangeValue = unsafe.Sizeof([1]C.VkPushConstantRange{})

// Ref returns a reference.
func (x *PushConstantRange) Ref() *C.VkPushConstantRange {
	if x == nil {
		return nil
	}
	return x.ref6f025856
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PushConstantRange) Free() {
	if x != nil && x.allocs6f025856 != nil {
		x.allocs6f025856.(*cgoAllocMap).Free()
		x.ref6f025856 = nil
	}
}

// NewPushConstantRangeRef initialises a new struct holding the reference to the originaitng C struct.
func NewPushConstantRangeRef(ref interface{}) *PushConstantRange {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PushConstantRange)
	obj.ref6f025856 = (*C.VkPushConstantRange)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PushConstantRange) PassRef() (*C.VkPushConstantRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6f025856 != nil {
		return x.ref6f025856, nil
	}
	mem6f025856 := allocPushConstantRangeMemory(1)
	ref6f025856 := (*C.VkPushConstantRange)(mem6f025856)
	allocs6f025856 := new(cgoAllocMap)
	var cstageFlags_allocs *cgoAllocMap
	ref6f025856.stageFlags, cstageFlags_allocs = (C.VkShaderStageFlags)(x.StageFlags), cgoAllocsUnknown
	allocs6f025856.Borrow(cstageFlags_allocs)

	var coffset_allocs *cgoAllocMap
	ref6f025856.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocs6f025856.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref6f025856.size, csize_allocs = (C.uint32_t)(x.Size), cgoAllocsUnknown
	allocs6f025856.Borrow(csize_allocs)

	x.ref6f025856 = ref6f025856
	x.allocs6f025856 = allocs6f025856
	return ref6f025856, allocs6f025856

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PushConstantRange) PassValue() (C.VkPushConstantRange, *cgoAllocMap) {
	if x.ref6f025856 != nil {
		return *x.ref6f025856, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PushConstantRange) Deref() {
	if x.ref6f025856 == nil {
		return
	}
	x.StageFlags = (ShaderStageFlags)(x.ref6f025856.stageFlags)
	x.Offset = (uint32)(x.ref6f025856.offset)
	x.Size = (uint32)(x.ref6f025856.size)
}

// allocPipelineLayoutCreateInfoMemory allocates memory for type C.VkPipelineLayoutCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineLayoutCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineLayoutCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineLayoutCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineLayoutCreateInfo{})

// unpackSPushConstantRange transforms a sliced Go data structure into plain C format.
func unpackSPushConstantRange(x []PushConstantRange) (unpacked *C.VkPushConstantRange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPushConstantRange) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPushConstantRangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPushConstantRange)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPushConstantRange)(unsafe.Pointer(h.Data))
	return
}

// packSPushConstantRange reads sliced Go data structure out from plain C format.
func packSPushConstantRange(v []PushConstantRange, ptr0 *C.VkPushConstantRange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPushConstantRangeValue]C.VkPushConstantRange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPushConstantRangeRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *PipelineLayoutCreateInfo) Ref() *C.VkPipelineLayoutCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref64cc4eed
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineLayoutCreateInfo) Free() {
	if x != nil && x.allocs64cc4eed != nil {
		x.allocs64cc4eed.(*cgoAllocMap).Free()
		x.ref64cc4eed = nil
	}
}

// NewPipelineLayoutCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineLayoutCreateInfoRef(ref interface{}) *PipelineLayoutCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PipelineLayoutCreateInfo)
	obj.ref64cc4eed = (*C.VkPipelineLayoutCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineLayoutCreateInfo) PassRef() (*C.VkPipelineLayoutCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref64cc4eed != nil {
		return x.ref64cc4eed, nil
	}
	mem64cc4eed := allocPipelineLayoutCreateInfoMemory(1)
	ref64cc4eed := (*C.VkPipelineLayoutCreateInfo)(mem64cc4eed)
	allocs64cc4eed := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref64cc4eed.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs64cc4eed.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref64cc4eed.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref64cc4eed.flags, cflags_allocs = (C.VkPipelineLayoutCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cflags_allocs)

	var csetLayoutCount_allocs *cgoAllocMap
	ref64cc4eed.setLayoutCount, csetLayoutCount_allocs = (C.uint32_t)(x.SetLayoutCount), cgoAllocsUnknown
	allocs64cc4eed.Borrow(csetLayoutCount_allocs)

	var cpSetLayouts_allocs *cgoAllocMap
	ref64cc4eed.pSetLayouts, cpSetLayouts_allocs = (*C.VkDescriptorSetLayout)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSetLayouts)).Data)), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cpSetLayouts_allocs)

	var cpushConstantRangeCount_allocs *cgoAllocMap
	ref64cc4eed.pushConstantRangeCount, cpushConstantRangeCount_allocs = (C.uint32_t)(x.PushConstantRangeCount), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cpushConstantRangeCount_allocs)

	var cpPushConstantRanges_allocs *cgoAllocMap
	ref64cc4eed.pPushConstantRanges, cpPushConstantRanges_allocs = unpackSPushConstantRange(x.PPushConstantRanges)
	allocs64cc4eed.Borrow(cpPushConstantRanges_allocs)

	x.ref64cc4eed = ref64cc4eed
	x.allocs64cc4eed = allocs64cc4eed
	return ref64cc4eed, allocs64cc4eed

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PipelineLayoutCreateInfo) PassValue() (C.VkPipelineLayoutCreateInfo, *cgoAllocMap) {
	if x.ref64cc4eed != nil {
		return *x.ref64cc4eed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineLayoutCreateInfo) Deref() {
	if x.ref64cc4eed == nil {
		return
	}
	x.SType = (StructureType)(x.ref64cc4eed.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref64cc4eed.pNext))
	x.Flags = (PipelineLayoutCreateFlags)(x.ref64cc4eed.flags)
	x.SetLayoutCount = (uint32)(x.ref64cc4eed.setLayoutCount)
	hxfe48d67 := (*sliceHeader)(unsafe.Pointer(&x.PSetLayouts))
	hxfe48d67.Data = uintptr(unsafe.Pointer(x.ref64cc4eed.pSetLayouts))
	hxfe48d67.Cap = 0x7fffffff
	// hxfe48d67.Len = ?

	x.PushConstantRangeCount = (uint32)(x.ref64cc4eed.pushConstantRangeCount)
	packSPushConstantRange(x.PPushConstantRanges, x.ref64cc4eed.pPushConstantRanges)
}

// allocSamplerCreateInfoMemory allocates memory for type C.VkSamplerCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSamplerCreateInfoValue = unsafe.Sizeof([1]C.VkSamplerCreateInfo{})

// Ref returns a reference.
func (x *SamplerCreateInfo) Ref() *C.VkSamplerCreateInfo {
	if x == nil {
		return nil
	}
	return x.refce034abf
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SamplerCreateInfo) Free() {
	if x != nil && x.allocsce034abf != nil {
		x.allocsce034abf.(*cgoAllocMap).Free()
		x.refce034abf = nil
	}
}

// NewSamplerCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewSamplerCreateInfoRef(ref interface{}) *SamplerCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SamplerCreateInfo)
	obj.refce034abf = (*C.VkSamplerCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SamplerCreateInfo) PassRef() (*C.VkSamplerCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refce034abf != nil {
		return x.refce034abf, nil
	}
	memce034abf := allocSamplerCreateInfoMemory(1)
	refce034abf := (*C.VkSamplerCreateInfo)(memce034abf)
	allocsce034abf := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refce034abf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsce034abf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refce034abf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsce034abf.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refce034abf.flags, cflags_allocs = (C.VkSamplerCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsce034abf.Borrow(cflags_allocs)

	var cmagFilter_allocs *cgoAllocMap
	refce034abf.magFilter, cmagFilter_allocs = (C.VkFilter)(x.MagFilter), cgoAllocsUnknown
	allocsce034abf.Borrow(cmagFilter_allocs)

	var cminFilter_allocs *cgoAllocMap
	refce034abf.minFilter, cminFilter_allocs = (C.VkFilter)(x.MinFilter), cgoAllocsUnknown
	allocsce034abf.Borrow(cminFilter_allocs)

	var cmipmapMode_allocs *cgoAllocMap
	refce034abf.mipmapMode, cmipmapMode_allocs = (C.VkSamplerMipmapMode)(x.MipmapMode), cgoAllocsUnknown
	allocsce034abf.Borrow(cmipmapMode_allocs)

	var caddressModeU_allocs *cgoAllocMap
	refce034abf.addressModeU, caddressModeU_allocs = (C.VkSamplerAddressMode)(x.AddressModeU), cgoAllocsUnknown
	allocsce034abf.Borrow(caddressModeU_allocs)

	var caddressModeV_allocs *cgoAllocMap
	refce034abf.addressModeV, caddressModeV_allocs = (C.VkSamplerAddressMode)(x.AddressModeV), cgoAllocsUnknown
	allocsce034abf.Borrow(caddressModeV_allocs)

	var caddressModeW_allocs *cgoAllocMap
	refce034abf.addressModeW, caddressModeW_allocs = (C.VkSamplerAddressMode)(x.AddressModeW), cgoAllocsUnknown
	allocsce034abf.Borrow(caddressModeW_allocs)

	var cmipLodBias_allocs *cgoAllocMap
	refce034abf.mipLodBias, cmipLodBias_allocs = (C.float)(x.MipLodBias), cgoAllocsUnknown
	allocsce034abf.Borrow(cmipLodBias_allocs)

	var canisotropyEnable_allocs *cgoAllocMap
	refce034abf.anisotropyEnable, canisotropyEnable_allocs = (C.VkBool32)(x.AnisotropyEnable), cgoAllocsUnknown
	allocsce034abf.Borrow(canisotropyEnable_allocs)

	var cmaxAnisotropy_allocs *cgoAllocMap
	refce034abf.maxAnisotropy, cmaxAnisotropy_allocs = (C.float)(x.MaxAnisotropy), cgoAllocsUnknown
	allocsce034abf.Borrow(cmaxAnisotropy_allocs)

	var ccompareEnable_allocs *cgoAllocMap
	refce034abf.compareEnable, ccompareEnable_allocs = (C.VkBool32)(x.CompareEnable), cgoAllocsUnknown
	allocsce034abf.Borrow(ccompareEnable_allocs)

	var ccompareOp_allocs *cgoAllocMap
	refce034abf.compareOp, ccompareOp_allocs = (C.VkCompareOp)(x.CompareOp), cgoAllocsUnknown
	allocsce034abf.Borrow(ccompareOp_allocs)

	var cminLod_allocs *cgoAllocMap
	refce034abf.minLod, cminLod_allocs = (C.float)(x.MinLod), cgoAllocsUnknown
	allocsce034abf.Borrow(cminLod_allocs)

	var cmaxLod_allocs *cgoAllocMap
	refce034abf.maxLod, cmaxLod_allocs = (C.float)(x.MaxLod), cgoAllocsUnknown
	allocsce034abf.Borrow(cmaxLod_allocs)

	var cborderColor_allocs *cgoAllocMap
	refce034abf.borderColor, cborderColor_allocs = (C.VkBorderColor)(x.BorderColor), cgoAllocsUnknown
	allocsce034abf.Borrow(cborderColor_allocs)

	var cunnormalizedCoordinates_allocs *cgoAllocMap
	refce034abf.unnormalizedCoordinates, cunnormalizedCoordinates_allocs = (C.VkBool32)(x.UnnormalizedCoordinates), cgoAllocsUnknown
	allocsce034abf.Borrow(cunnormalizedCoordinates_allocs)

	x.refce034abf = refce034abf
	x.allocsce034abf = allocsce034abf
	return refce034abf, allocsce034abf

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SamplerCreateInfo) PassValue() (C.VkSamplerCreateInfo, *cgoAllocMap) {
	if x.refce034abf != nil {
		return *x.refce034abf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SamplerCreateInfo) Deref() {
	if x.refce034abf == nil {
		return
	}
	x.SType = (StructureType)(x.refce034abf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refce034abf.pNext))
	x.Flags = (SamplerCreateFlags)(x.refce034abf.flags)
	x.MagFilter = (Filter)(x.refce034abf.magFilter)
	x.MinFilter = (Filter)(x.refce034abf.minFilter)
	x.MipmapMode = (SamplerMipmapMode)(x.refce034abf.mipmapMode)
	x.AddressModeU = (SamplerAddressMode)(x.refce034abf.addressModeU)
	x.AddressModeV = (SamplerAddressMode)(x.refce034abf.addressModeV)
	x.AddressModeW = (SamplerAddressMode)(x.refce034abf.addressModeW)
	x.MipLodBias = (float32)(x.refce034abf.mipLodBias)
	x.AnisotropyEnable = (Bool32)(x.refce034abf.anisotropyEnable)
	x.MaxAnisotropy = (float32)(x.refce034abf.maxAnisotropy)
	x.CompareEnable = (Bool32)(x.refce034abf.compareEnable)
	x.CompareOp = (CompareOp)(x.refce034abf.compareOp)
	x.MinLod = (float32)(x.refce034abf.minLod)
	x.MaxLod = (float32)(x.refce034abf.maxLod)
	x.BorderColor = (BorderColor)(x.refce034abf.borderColor)
	x.UnnormalizedCoordinates = (Bool32)(x.refce034abf.unnormalizedCoordinates)
}

// allocDescriptorSetLayoutBindingMemory allocates memory for type C.VkDescriptorSetLayoutBinding in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutBindingMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutBindingValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetLayoutBindingValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutBinding{})

// Ref returns a reference.
func (x *DescriptorSetLayoutBinding) Ref() *C.VkDescriptorSetLayoutBinding {
	if x == nil {
		return nil
	}
	return x.ref8b50b4ec
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DescriptorSetLayoutBinding) Free() {
	if x != nil && x.allocs8b50b4ec != nil {
		x.allocs8b50b4ec.(*cgoAllocMap).Free()
		x.ref8b50b4ec = nil
	}
}

// NewDescriptorSetLayoutBindingRef initialises a new struct holding the reference to the originaitng C struct.
func NewDescriptorSetLayoutBindingRef(ref interface{}) *DescriptorSetLayoutBinding {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DescriptorSetLayoutBinding)
	obj.ref8b50b4ec = (*C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DescriptorSetLayoutBinding) PassRef() (*C.VkDescriptorSetLayoutBinding, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8b50b4ec != nil {
		return x.ref8b50b4ec, nil
	}
	mem8b50b4ec := allocDescriptorSetLayoutBindingMemory(1)
	ref8b50b4ec := (*C.VkDescriptorSetLayoutBinding)(mem8b50b4ec)
	allocs8b50b4ec := new(cgoAllocMap)
	var cbinding_allocs *cgoAllocMap
	ref8b50b4ec.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cbinding_allocs)

	var cdescriptorType_allocs *cgoAllocMap
	ref8b50b4ec.descriptorType, cdescriptorType_allocs = (C.VkDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cdescriptorType_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	ref8b50b4ec.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cdescriptorCount_allocs)

	var cstageFlags_allocs *cgoAllocMap
	ref8b50b4ec.stageFlags, cstageFlags_allocs = (C.VkShaderStageFlags)(x.StageFlags), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cstageFlags_allocs)

	var cpImmutableSamplers_allocs *cgoAllocMap
	ref8b50b4ec.pImmutableSamplers, cpImmutableSamplers_allocs = (*C.VkSampler)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PImmutableSamplers)).Data)), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cpImmutableSamplers_allocs)

	x.ref8b50b4ec = ref8b50b4ec
	x.allocs8b50b4ec = allocs8b50b4ec
	return ref8b50b4ec, allocs8b50b4ec

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DescriptorSetLayoutBinding) PassValue() (C.VkDescriptorSetLayoutBinding, *cgoAllocMap) {
	if x.ref8b50b4ec != nil {
		return *x.ref8b50b4ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DescriptorSetLayoutBinding) Deref() {
	if x.ref8b50b4ec == nil {
		return
	}
	x.Binding = (uint32)(x.ref8b50b4ec.binding)
	x.DescriptorType = (DescriptorType)(x.ref8b50b4ec.descriptorType)
	x.DescriptorCount = (uint32)(x.ref8b50b4ec.descriptorCount)
	x.StageFlags = (ShaderStageFlags)(x.ref8b50b4ec.stageFlags)
	hxf4171bf := (*sliceHeader)(unsafe.Pointer(&x.PImmutableSamplers))
	hxf4171bf.Data = uintptr(unsafe.Pointer(x.ref8b50b4ec.pImmutableSamplers))
	hxf4171bf.Cap = 0x7fffffff
	// hxf4171bf.Len = ?

}

// allocDescriptorSetLayoutCreateInfoMemory allocates memory for type C.VkDescriptorSetLayoutCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetLayoutCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutCreateInfo{})

// unpackSDescriptorSetLayoutBinding transforms a sliced Go data structure into plain C format.
func unpackSDescriptorSetLayoutBinding(x []DescriptorSetLayoutBinding) (unpacked *C.VkDescriptorSetLayoutBinding, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorSetLayoutBinding) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorSetLayoutBindingMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(h.Data))
	return
}

// packSDescriptorSetLayoutBinding reads sliced Go data structure out from plain C format.
func packSDescriptorSetLayoutBinding(v []DescriptorSetLayoutBinding, ptr0 *C.VkDescriptorSetLayoutBinding) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorSetLayoutBindingValue]C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorSetLayoutBindingRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *DescriptorSetLayoutCreateInfo) Ref() *C.VkDescriptorSetLayoutCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5ee8e0ed
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DescriptorSetLayoutCreateInfo) Free() {
	if x != nil && x.allocs5ee8e0ed != nil {
		x.allocs5ee8e0ed.(*cgoAllocMap).Free()
		x.ref5ee8e0ed = nil
	}
}

// NewDescriptorSetLayoutCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDescriptorSetLayoutCreateInfoRef(ref interface{}) *DescriptorSetLayoutCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DescriptorSetLayoutCreateInfo)
	obj.ref5ee8e0ed = (*C.VkDescriptorSetLayoutCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DescriptorSetLayoutCreateInfo) PassRef() (*C.VkDescriptorSetLayoutCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ee8e0ed != nil {
		return x.ref5ee8e0ed, nil
	}
	mem5ee8e0ed := allocDescriptorSetLayoutCreateInfoMemory(1)
	ref5ee8e0ed := (*C.VkDescriptorSetLayoutCreateInfo)(mem5ee8e0ed)
	allocs5ee8e0ed := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref5ee8e0ed.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5ee8e0ed.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5ee8e0ed.flags, cflags_allocs = (C.VkDescriptorSetLayoutCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(cflags_allocs)

	var cbindingCount_allocs *cgoAllocMap
	ref5ee8e0ed.bindingCount, cbindingCount_allocs = (C.uint32_t)(x.BindingCount), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(cbindingCount_allocs)

	var cpBindings_allocs *cgoAllocMap
	ref5ee8e0ed.pBindings, cpBindings_allocs = unpackSDescriptorSetLayoutBinding(x.PBindings)
	allocs5ee8e0ed.Borrow(cpBindings_allocs)

	x.ref5ee8e0ed = ref5ee8e0ed
	x.allocs5ee8e0ed = allocs5ee8e0ed
	return ref5ee8e0ed, allocs5ee8e0ed

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DescriptorSetLayoutCreateInfo) PassValue() (C.VkDescriptorSetLayoutCreateInfo, *cgoAllocMap) {
	if x.ref5ee8e0ed != nil {
		return *x.ref5ee8e0ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DescriptorSetLayoutCreateInfo) Deref() {
	if x.ref5ee8e0ed == nil {
		return
	}
	x.SType = (StructureType)(x.ref5ee8e0ed.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5ee8e0ed.pNext))
	x.Flags = (DescriptorSetLayoutCreateFlags)(x.ref5ee8e0ed.flags)
	x.BindingCount = (uint32)(x.ref5ee8e0ed.bindingCount)
	packSDescriptorSetLayoutBinding(x.PBindings, x.ref5ee8e0ed.pBindings)
}

// allocDescriptorPoolSizeMemory allocates memory for type C.VkDescriptorPoolSize in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorPoolSizeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorPoolSizeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorPoolSizeValue = unsafe.Sizeof([1]C.VkDescriptorPoolSize{})

// Ref returns a reference.
func (x *DescriptorPoolSize) Ref() *C.VkDescriptorPoolSize {
	if x == nil {
		return nil
	}
	return x.refe15137da
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DescriptorPoolSize) Free() {
	if x != nil && x.allocse15137da != nil {
		x.allocse15137da.(*cgoAllocMap).Free()
		x.refe15137da = nil
	}
}

// NewDescriptorPoolSizeRef initialises a new struct holding the reference to the originaitng C struct.
func NewDescriptorPoolSizeRef(ref interface{}) *DescriptorPoolSize {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DescriptorPoolSize)
	obj.refe15137da = (*C.VkDescriptorPoolSize)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DescriptorPoolSize) PassRef() (*C.VkDescriptorPoolSize, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe15137da != nil {
		return x.refe15137da, nil
	}
	meme15137da := allocDescriptorPoolSizeMemory(1)
	refe15137da := (*C.VkDescriptorPoolSize)(meme15137da)
	allocse15137da := new(cgoAllocMap)
	var c_type_allocs *cgoAllocMap
	refe15137da._type, c_type_allocs = (C.VkDescriptorType)(x._type), cgoAllocsUnknown
	allocse15137da.Borrow(c_type_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	refe15137da.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocse15137da.Borrow(cdescriptorCount_allocs)

	x.refe15137da = refe15137da
	x.allocse15137da = allocse15137da
	return refe15137da, allocse15137da

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DescriptorPoolSize) PassValue() (C.VkDescriptorPoolSize, *cgoAllocMap) {
	if x.refe15137da != nil {
		return *x.refe15137da, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DescriptorPoolSize) Deref() {
	if x.refe15137da == nil {
		return
	}
	x._type = (DescriptorType)(x.refe15137da._type)
	x.DescriptorCount = (uint32)(x.refe15137da.descriptorCount)
}

// allocDescriptorPoolCreateInfoMemory allocates memory for type C.VkDescriptorPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorPoolCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorPoolCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorPoolCreateInfo{})

// unpackSDescriptorPoolSize transforms a sliced Go data structure into plain C format.
func unpackSDescriptorPoolSize(x []DescriptorPoolSize) (unpacked *C.VkDescriptorPoolSize, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorPoolSize) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorPoolSizeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorPoolSize)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorPoolSize)(unsafe.Pointer(h.Data))
	return
}

// packSDescriptorPoolSize reads sliced Go data structure out from plain C format.
func packSDescriptorPoolSize(v []DescriptorPoolSize, ptr0 *C.VkDescriptorPoolSize) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorPoolSizeValue]C.VkDescriptorPoolSize)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorPoolSizeRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *DescriptorPoolCreateInfo) Ref() *C.VkDescriptorPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref19868463
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DescriptorPoolCreateInfo) Free() {
	if x != nil && x.allocs19868463 != nil {
		x.allocs19868463.(*cgoAllocMap).Free()
		x.ref19868463 = nil
	}
}

// NewDescriptorPoolCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDescriptorPoolCreateInfoRef(ref interface{}) *DescriptorPoolCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DescriptorPoolCreateInfo)
	obj.ref19868463 = (*C.VkDescriptorPoolCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DescriptorPoolCreateInfo) PassRef() (*C.VkDescriptorPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref19868463 != nil {
		return x.ref19868463, nil
	}
	mem19868463 := allocDescriptorPoolCreateInfoMemory(1)
	ref19868463 := (*C.VkDescriptorPoolCreateInfo)(mem19868463)
	allocs19868463 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref19868463.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs19868463.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref19868463.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs19868463.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref19868463.flags, cflags_allocs = (C.VkDescriptorPoolCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs19868463.Borrow(cflags_allocs)

	var cmaxSets_allocs *cgoAllocMap
	ref19868463.maxSets, cmaxSets_allocs = (C.uint32_t)(x.MaxSets), cgoAllocsUnknown
	allocs19868463.Borrow(cmaxSets_allocs)

	var cpoolSizeCount_allocs *cgoAllocMap
	ref19868463.poolSizeCount, cpoolSizeCount_allocs = (C.uint32_t)(x.PoolSizeCount), cgoAllocsUnknown
	allocs19868463.Borrow(cpoolSizeCount_allocs)

	var cpPoolSizes_allocs *cgoAllocMap
	ref19868463.pPoolSizes, cpPoolSizes_allocs = unpackSDescriptorPoolSize(x.PPoolSizes)
	allocs19868463.Borrow(cpPoolSizes_allocs)

	x.ref19868463 = ref19868463
	x.allocs19868463 = allocs19868463
	return ref19868463, allocs19868463

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DescriptorPoolCreateInfo) PassValue() (C.VkDescriptorPoolCreateInfo, *cgoAllocMap) {
	if x.ref19868463 != nil {
		return *x.ref19868463, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DescriptorPoolCreateInfo) Deref() {
	if x.ref19868463 == nil {
		return
	}
	x.SType = (StructureType)(x.ref19868463.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref19868463.pNext))
	x.Flags = (DescriptorPoolCreateFlags)(x.ref19868463.flags)
	x.MaxSets = (uint32)(x.ref19868463.maxSets)
	x.PoolSizeCount = (uint32)(x.ref19868463.poolSizeCount)
	packSDescriptorPoolSize(x.PPoolSizes, x.ref19868463.pPoolSizes)
}

// allocDescriptorSetAllocateInfoMemory allocates memory for type C.VkDescriptorSetAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetAllocateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetAllocateInfo{})

// Ref returns a reference.
func (x *DescriptorSetAllocateInfo) Ref() *C.VkDescriptorSetAllocateInfo {
	if x == nil {
		return nil
	}
	return x.ref2dd6cc22
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DescriptorSetAllocateInfo) Free() {
	if x != nil && x.allocs2dd6cc22 != nil {
		x.allocs2dd6cc22.(*cgoAllocMap).Free()
		x.ref2dd6cc22 = nil
	}
}

// NewDescriptorSetAllocateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDescriptorSetAllocateInfoRef(ref interface{}) *DescriptorSetAllocateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DescriptorSetAllocateInfo)
	obj.ref2dd6cc22 = (*C.VkDescriptorSetAllocateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DescriptorSetAllocateInfo) PassRef() (*C.VkDescriptorSetAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2dd6cc22 != nil {
		return x.ref2dd6cc22, nil
	}
	mem2dd6cc22 := allocDescriptorSetAllocateInfoMemory(1)
	ref2dd6cc22 := (*C.VkDescriptorSetAllocateInfo)(mem2dd6cc22)
	allocs2dd6cc22 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref2dd6cc22.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2dd6cc22.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cpNext_allocs)

	var cdescriptorPool_allocs *cgoAllocMap
	ref2dd6cc22.descriptorPool, cdescriptorPool_allocs = *(*C.VkDescriptorPool)(unsafe.Pointer(&x.DescriptorPool)), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cdescriptorPool_allocs)

	var cdescriptorSetCount_allocs *cgoAllocMap
	ref2dd6cc22.descriptorSetCount, cdescriptorSetCount_allocs = (C.uint32_t)(x.DescriptorSetCount), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cdescriptorSetCount_allocs)

	var cpSetLayouts_allocs *cgoAllocMap
	ref2dd6cc22.pSetLayouts, cpSetLayouts_allocs = (*C.VkDescriptorSetLayout)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSetLayouts)).Data)), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cpSetLayouts_allocs)

	x.ref2dd6cc22 = ref2dd6cc22
	x.allocs2dd6cc22 = allocs2dd6cc22
	return ref2dd6cc22, allocs2dd6cc22

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DescriptorSetAllocateInfo) PassValue() (C.VkDescriptorSetAllocateInfo, *cgoAllocMap) {
	if x.ref2dd6cc22 != nil {
		return *x.ref2dd6cc22, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DescriptorSetAllocateInfo) Deref() {
	if x.ref2dd6cc22 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2dd6cc22.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2dd6cc22.pNext))
	x.DescriptorPool = *(*DescriptorPool)(unsafe.Pointer(&x.ref2dd6cc22.descriptorPool))
	x.DescriptorSetCount = (uint32)(x.ref2dd6cc22.descriptorSetCount)
	hxf058b18 := (*sliceHeader)(unsafe.Pointer(&x.PSetLayouts))
	hxf058b18.Data = uintptr(unsafe.Pointer(x.ref2dd6cc22.pSetLayouts))
	hxf058b18.Cap = 0x7fffffff
	// hxf058b18.Len = ?

}

// allocDescriptorImageInfoMemory allocates memory for type C.VkDescriptorImageInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorImageInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorImageInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorImageInfoValue = unsafe.Sizeof([1]C.VkDescriptorImageInfo{})

// Ref returns a reference.
func (x *DescriptorImageInfo) Ref() *C.VkDescriptorImageInfo {
	if x == nil {
		return nil
	}
	return x.refaf073b07
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DescriptorImageInfo) Free() {
	if x != nil && x.allocsaf073b07 != nil {
		x.allocsaf073b07.(*cgoAllocMap).Free()
		x.refaf073b07 = nil
	}
}

// NewDescriptorImageInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDescriptorImageInfoRef(ref interface{}) *DescriptorImageInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DescriptorImageInfo)
	obj.refaf073b07 = (*C.VkDescriptorImageInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DescriptorImageInfo) PassRef() (*C.VkDescriptorImageInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaf073b07 != nil {
		return x.refaf073b07, nil
	}
	memaf073b07 := allocDescriptorImageInfoMemory(1)
	refaf073b07 := (*C.VkDescriptorImageInfo)(memaf073b07)
	allocsaf073b07 := new(cgoAllocMap)
	var csampler_allocs *cgoAllocMap
	refaf073b07.sampler, csampler_allocs = *(*C.VkSampler)(unsafe.Pointer(&x.Sampler)), cgoAllocsUnknown
	allocsaf073b07.Borrow(csampler_allocs)

	var cimageView_allocs *cgoAllocMap
	refaf073b07.imageView, cimageView_allocs = *(*C.VkImageView)(unsafe.Pointer(&x.ImageView)), cgoAllocsUnknown
	allocsaf073b07.Borrow(cimageView_allocs)

	var cimageLayout_allocs *cgoAllocMap
	refaf073b07.imageLayout, cimageLayout_allocs = (C.VkImageLayout)(x.ImageLayout), cgoAllocsUnknown
	allocsaf073b07.Borrow(cimageLayout_allocs)

	x.refaf073b07 = refaf073b07
	x.allocsaf073b07 = allocsaf073b07
	return refaf073b07, allocsaf073b07

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DescriptorImageInfo) PassValue() (C.VkDescriptorImageInfo, *cgoAllocMap) {
	if x.refaf073b07 != nil {
		return *x.refaf073b07, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DescriptorImageInfo) Deref() {
	if x.refaf073b07 == nil {
		return
	}
	x.Sampler = *(*Sampler)(unsafe.Pointer(&x.refaf073b07.sampler))
	x.ImageView = *(*ImageView)(unsafe.Pointer(&x.refaf073b07.imageView))
	x.ImageLayout = (ImageLayout)(x.refaf073b07.imageLayout)
}

// allocDescriptorBufferInfoMemory allocates memory for type C.VkDescriptorBufferInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorBufferInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorBufferInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorBufferInfoValue = unsafe.Sizeof([1]C.VkDescriptorBufferInfo{})

// Ref returns a reference.
func (x *DescriptorBufferInfo) Ref() *C.VkDescriptorBufferInfo {
	if x == nil {
		return nil
	}
	return x.refe64bec0e
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DescriptorBufferInfo) Free() {
	if x != nil && x.allocse64bec0e != nil {
		x.allocse64bec0e.(*cgoAllocMap).Free()
		x.refe64bec0e = nil
	}
}

// NewDescriptorBufferInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDescriptorBufferInfoRef(ref interface{}) *DescriptorBufferInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DescriptorBufferInfo)
	obj.refe64bec0e = (*C.VkDescriptorBufferInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DescriptorBufferInfo) PassRef() (*C.VkDescriptorBufferInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe64bec0e != nil {
		return x.refe64bec0e, nil
	}
	meme64bec0e := allocDescriptorBufferInfoMemory(1)
	refe64bec0e := (*C.VkDescriptorBufferInfo)(meme64bec0e)
	allocse64bec0e := new(cgoAllocMap)
	var cbuffer_allocs *cgoAllocMap
	refe64bec0e.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocse64bec0e.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	refe64bec0e.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocse64bec0e.Borrow(coffset_allocs)

	var c_range_allocs *cgoAllocMap
	refe64bec0e._range, c_range_allocs = (C.VkDeviceSize)(x._range), cgoAllocsUnknown
	allocse64bec0e.Borrow(c_range_allocs)

	x.refe64bec0e = refe64bec0e
	x.allocse64bec0e = allocse64bec0e
	return refe64bec0e, allocse64bec0e

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DescriptorBufferInfo) PassValue() (C.VkDescriptorBufferInfo, *cgoAllocMap) {
	if x.refe64bec0e != nil {
		return *x.refe64bec0e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DescriptorBufferInfo) Deref() {
	if x.refe64bec0e == nil {
		return
	}
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refe64bec0e.buffer))
	x.Offset = (DeviceSize)(x.refe64bec0e.offset)
	x._range = (DeviceSize)(x.refe64bec0e._range)
}

// allocWriteDescriptorSetMemory allocates memory for type C.VkWriteDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWriteDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWriteDescriptorSetValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfWriteDescriptorSetValue = unsafe.Sizeof([1]C.VkWriteDescriptorSet{})

// unpackSDescriptorImageInfo transforms a sliced Go data structure into plain C format.
func unpackSDescriptorImageInfo(x []DescriptorImageInfo) (unpacked *C.VkDescriptorImageInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorImageInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorImageInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorImageInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorImageInfo)(unsafe.Pointer(h.Data))
	return
}

// unpackSDescriptorBufferInfo transforms a sliced Go data structure into plain C format.
func unpackSDescriptorBufferInfo(x []DescriptorBufferInfo) (unpacked *C.VkDescriptorBufferInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorBufferInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorBufferInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorBufferInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorBufferInfo)(unsafe.Pointer(h.Data))
	return
}

// packSDescriptorImageInfo reads sliced Go data structure out from plain C format.
func packSDescriptorImageInfo(v []DescriptorImageInfo, ptr0 *C.VkDescriptorImageInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorImageInfoValue]C.VkDescriptorImageInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorImageInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSDescriptorBufferInfo reads sliced Go data structure out from plain C format.
func packSDescriptorBufferInfo(v []DescriptorBufferInfo, ptr0 *C.VkDescriptorBufferInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorBufferInfoValue]C.VkDescriptorBufferInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorBufferInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *WriteDescriptorSet) Ref() *C.VkWriteDescriptorSet {
	if x == nil {
		return nil
	}
	return x.ref3cec3f3f
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *WriteDescriptorSet) Free() {
	if x != nil && x.allocs3cec3f3f != nil {
		x.allocs3cec3f3f.(*cgoAllocMap).Free()
		x.ref3cec3f3f = nil
	}
}

// NewWriteDescriptorSetRef initialises a new struct holding the reference to the originaitng C struct.
func NewWriteDescriptorSetRef(ref interface{}) *WriteDescriptorSet {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(WriteDescriptorSet)
	obj.ref3cec3f3f = (*C.VkWriteDescriptorSet)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *WriteDescriptorSet) PassRef() (*C.VkWriteDescriptorSet, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3cec3f3f != nil {
		return x.ref3cec3f3f, nil
	}
	mem3cec3f3f := allocWriteDescriptorSetMemory(1)
	ref3cec3f3f := (*C.VkWriteDescriptorSet)(mem3cec3f3f)
	allocs3cec3f3f := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref3cec3f3f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3cec3f3f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cpNext_allocs)

	var cdstSet_allocs *cgoAllocMap
	ref3cec3f3f.dstSet, cdstSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.DstSet)), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdstSet_allocs)

	var cdstBinding_allocs *cgoAllocMap
	ref3cec3f3f.dstBinding, cdstBinding_allocs = (C.uint32_t)(x.DstBinding), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdstBinding_allocs)

	var cdstArrayElement_allocs *cgoAllocMap
	ref3cec3f3f.dstArrayElement, cdstArrayElement_allocs = (C.uint32_t)(x.DstArrayElement), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdstArrayElement_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	ref3cec3f3f.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdescriptorCount_allocs)

	var cdescriptorType_allocs *cgoAllocMap
	ref3cec3f3f.descriptorType, cdescriptorType_allocs = (C.VkDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdescriptorType_allocs)

	var cpImageInfo_allocs *cgoAllocMap
	ref3cec3f3f.pImageInfo, cpImageInfo_allocs = unpackSDescriptorImageInfo(x.PImageInfo)
	allocs3cec3f3f.Borrow(cpImageInfo_allocs)

	var cpBufferInfo_allocs *cgoAllocMap
	ref3cec3f3f.pBufferInfo, cpBufferInfo_allocs = unpackSDescriptorBufferInfo(x.PBufferInfo)
	allocs3cec3f3f.Borrow(cpBufferInfo_allocs)

	var cpTexelBufferView_allocs *cgoAllocMap
	ref3cec3f3f.pTexelBufferView, cpTexelBufferView_allocs = (*C.VkBufferView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PTexelBufferView)).Data)), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cpTexelBufferView_allocs)

	x.ref3cec3f3f = ref3cec3f3f
	x.allocs3cec3f3f = allocs3cec3f3f
	return ref3cec3f3f, allocs3cec3f3f

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x WriteDescriptorSet) PassValue() (C.VkWriteDescriptorSet, *cgoAllocMap) {
	if x.ref3cec3f3f != nil {
		return *x.ref3cec3f3f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *WriteDescriptorSet) Deref() {
	if x.ref3cec3f3f == nil {
		return
	}
	x.SType = (StructureType)(x.ref3cec3f3f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3cec3f3f.pNext))
	x.DstSet = *(*DescriptorSet)(unsafe.Pointer(&x.ref3cec3f3f.dstSet))
	x.DstBinding = (uint32)(x.ref3cec3f3f.dstBinding)
	x.DstArrayElement = (uint32)(x.ref3cec3f3f.dstArrayElement)
	x.DescriptorCount = (uint32)(x.ref3cec3f3f.descriptorCount)
	x.DescriptorType = (DescriptorType)(x.ref3cec3f3f.descriptorType)
	packSDescriptorImageInfo(x.PImageInfo, x.ref3cec3f3f.pImageInfo)
	packSDescriptorBufferInfo(x.PBufferInfo, x.ref3cec3f3f.pBufferInfo)
	hxff6bc57 := (*sliceHeader)(unsafe.Pointer(&x.PTexelBufferView))
	hxff6bc57.Data = uintptr(unsafe.Pointer(x.ref3cec3f3f.pTexelBufferView))
	hxff6bc57.Cap = 0x7fffffff
	// hxff6bc57.Len = ?

}

// allocCopyDescriptorSetMemory allocates memory for type C.VkCopyDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyDescriptorSetValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCopyDescriptorSetValue = unsafe.Sizeof([1]C.VkCopyDescriptorSet{})

// Ref returns a reference.
func (x *CopyDescriptorSet) Ref() *C.VkCopyDescriptorSet {
	if x == nil {
		return nil
	}
	return x.reffe237a3a
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *CopyDescriptorSet) Free() {
	if x != nil && x.allocsfe237a3a != nil {
		x.allocsfe237a3a.(*cgoAllocMap).Free()
		x.reffe237a3a = nil
	}
}

// NewCopyDescriptorSetRef initialises a new struct holding the reference to the originaitng C struct.
func NewCopyDescriptorSetRef(ref interface{}) *CopyDescriptorSet {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(CopyDescriptorSet)
	obj.reffe237a3a = (*C.VkCopyDescriptorSet)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *CopyDescriptorSet) PassRef() (*C.VkCopyDescriptorSet, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe237a3a != nil {
		return x.reffe237a3a, nil
	}
	memfe237a3a := allocCopyDescriptorSetMemory(1)
	reffe237a3a := (*C.VkCopyDescriptorSet)(memfe237a3a)
	allocsfe237a3a := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	reffe237a3a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe237a3a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cpNext_allocs)

	var csrcSet_allocs *cgoAllocMap
	reffe237a3a.srcSet, csrcSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.SrcSet)), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csrcSet_allocs)

	var csrcBinding_allocs *cgoAllocMap
	reffe237a3a.srcBinding, csrcBinding_allocs = (C.uint32_t)(x.SrcBinding), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csrcBinding_allocs)

	var csrcArrayElement_allocs *cgoAllocMap
	reffe237a3a.srcArrayElement, csrcArrayElement_allocs = (C.uint32_t)(x.SrcArrayElement), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csrcArrayElement_allocs)

	var cdstSet_allocs *cgoAllocMap
	reffe237a3a.dstSet, cdstSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.DstSet)), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdstSet_allocs)

	var cdstBinding_allocs *cgoAllocMap
	reffe237a3a.dstBinding, cdstBinding_allocs = (C.uint32_t)(x.DstBinding), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdstBinding_allocs)

	var cdstArrayElement_allocs *cgoAllocMap
	reffe237a3a.dstArrayElement, cdstArrayElement_allocs = (C.uint32_t)(x.DstArrayElement), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdstArrayElement_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	reffe237a3a.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdescriptorCount_allocs)

	x.reffe237a3a = reffe237a3a
	x.allocsfe237a3a = allocsfe237a3a
	return reffe237a3a, allocsfe237a3a

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x CopyDescriptorSet) PassValue() (C.VkCopyDescriptorSet, *cgoAllocMap) {
	if x.reffe237a3a != nil {
		return *x.reffe237a3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *CopyDescriptorSet) Deref() {
	if x.reffe237a3a == nil {
		return
	}
	x.SType = (StructureType)(x.reffe237a3a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe237a3a.pNext))
	x.SrcSet = *(*DescriptorSet)(unsafe.Pointer(&x.reffe237a3a.srcSet))
	x.SrcBinding = (uint32)(x.reffe237a3a.srcBinding)
	x.SrcArrayElement = (uint32)(x.reffe237a3a.srcArrayElement)
	x.DstSet = *(*DescriptorSet)(unsafe.Pointer(&x.reffe237a3a.dstSet))
	x.DstBinding = (uint32)(x.reffe237a3a.dstBinding)
	x.DstArrayElement = (uint32)(x.reffe237a3a.dstArrayElement)
	x.DescriptorCount = (uint32)(x.reffe237a3a.descriptorCount)
}

// allocFramebufferCreateInfoMemory allocates memory for type C.VkFramebufferCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFramebufferCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFramebufferCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFramebufferCreateInfoValue = unsafe.Sizeof([1]C.VkFramebufferCreateInfo{})

// Ref returns a reference.
func (x *FramebufferCreateInfo) Ref() *C.VkFramebufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.refa3ad85cc
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *FramebufferCreateInfo) Free() {
	if x != nil && x.allocsa3ad85cc != nil {
		x.allocsa3ad85cc.(*cgoAllocMap).Free()
		x.refa3ad85cc = nil
	}
}

// NewFramebufferCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewFramebufferCreateInfoRef(ref interface{}) *FramebufferCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(FramebufferCreateInfo)
	obj.refa3ad85cc = (*C.VkFramebufferCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *FramebufferCreateInfo) PassRef() (*C.VkFramebufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa3ad85cc != nil {
		return x.refa3ad85cc, nil
	}
	mema3ad85cc := allocFramebufferCreateInfoMemory(1)
	refa3ad85cc := (*C.VkFramebufferCreateInfo)(mema3ad85cc)
	allocsa3ad85cc := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refa3ad85cc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa3ad85cc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refa3ad85cc.flags, cflags_allocs = (C.VkFramebufferCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cflags_allocs)

	var crenderPass_allocs *cgoAllocMap
	refa3ad85cc.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(crenderPass_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	refa3ad85cc.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	refa3ad85cc.pAttachments, cpAttachments_allocs = (*C.VkImageView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PAttachments)).Data)), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cpAttachments_allocs)

	var cwidth_allocs *cgoAllocMap
	refa3ad85cc.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refa3ad85cc.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cheight_allocs)

	var clayers_allocs *cgoAllocMap
	refa3ad85cc.layers, clayers_allocs = (C.uint32_t)(x.Layers), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(clayers_allocs)

	x.refa3ad85cc = refa3ad85cc
	x.allocsa3ad85cc = allocsa3ad85cc
	return refa3ad85cc, allocsa3ad85cc

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x FramebufferCreateInfo) PassValue() (C.VkFramebufferCreateInfo, *cgoAllocMap) {
	if x.refa3ad85cc != nil {
		return *x.refa3ad85cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *FramebufferCreateInfo) Deref() {
	if x.refa3ad85cc == nil {
		return
	}
	x.SType = (StructureType)(x.refa3ad85cc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa3ad85cc.pNext))
	x.Flags = (FramebufferCreateFlags)(x.refa3ad85cc.flags)
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.refa3ad85cc.renderPass))
	x.AttachmentCount = (uint32)(x.refa3ad85cc.attachmentCount)
	hxf5fa529 := (*sliceHeader)(unsafe.Pointer(&x.PAttachments))
	hxf5fa529.Data = uintptr(unsafe.Pointer(x.refa3ad85cc.pAttachments))
	hxf5fa529.Cap = 0x7fffffff
	// hxf5fa529.Len = ?

	x.Width = (uint32)(x.refa3ad85cc.width)
	x.Height = (uint32)(x.refa3ad85cc.height)
	x.Layers = (uint32)(x.refa3ad85cc.layers)
}

// allocAttachmentDescriptionMemory allocates memory for type C.VkAttachmentDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAttachmentDescriptionValue = unsafe.Sizeof([1]C.VkAttachmentDescription{})

// Ref returns a reference.
func (x *AttachmentDescription) Ref() *C.VkAttachmentDescription {
	if x == nil {
		return nil
	}
	return x.refa5d685fc
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *AttachmentDescription) Free() {
	if x != nil && x.allocsa5d685fc != nil {
		x.allocsa5d685fc.(*cgoAllocMap).Free()
		x.refa5d685fc = nil
	}
}

// NewAttachmentDescriptionRef initialises a new struct holding the reference to the originaitng C struct.
func NewAttachmentDescriptionRef(ref interface{}) *AttachmentDescription {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(AttachmentDescription)
	obj.refa5d685fc = (*C.VkAttachmentDescription)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *AttachmentDescription) PassRef() (*C.VkAttachmentDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5d685fc != nil {
		return x.refa5d685fc, nil
	}
	mema5d685fc := allocAttachmentDescriptionMemory(1)
	refa5d685fc := (*C.VkAttachmentDescription)(mema5d685fc)
	allocsa5d685fc := new(cgoAllocMap)
	var cflags_allocs *cgoAllocMap
	refa5d685fc.flags, cflags_allocs = (C.VkAttachmentDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cflags_allocs)

	var cformat_allocs *cgoAllocMap
	refa5d685fc.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cformat_allocs)

	var csamples_allocs *cgoAllocMap
	refa5d685fc.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocsa5d685fc.Borrow(csamples_allocs)

	var cloadOp_allocs *cgoAllocMap
	refa5d685fc.loadOp, cloadOp_allocs = (C.VkAttachmentLoadOp)(x.LoadOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cloadOp_allocs)

	var cstoreOp_allocs *cgoAllocMap
	refa5d685fc.storeOp, cstoreOp_allocs = (C.VkAttachmentStoreOp)(x.StoreOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cstoreOp_allocs)

	var cstencilLoadOp_allocs *cgoAllocMap
	refa5d685fc.stencilLoadOp, cstencilLoadOp_allocs = (C.VkAttachmentLoadOp)(x.StencilLoadOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cstencilLoadOp_allocs)

	var cstencilStoreOp_allocs *cgoAllocMap
	refa5d685fc.stencilStoreOp, cstencilStoreOp_allocs = (C.VkAttachmentStoreOp)(x.StencilStoreOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cstencilStoreOp_allocs)

	var cinitialLayout_allocs *cgoAllocMap
	refa5d685fc.initialLayout, cinitialLayout_allocs = (C.VkImageLayout)(x.InitialLayout), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cinitialLayout_allocs)

	var cfinalLayout_allocs *cgoAllocMap
	refa5d685fc.finalLayout, cfinalLayout_allocs = (C.VkImageLayout)(x.FinalLayout), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cfinalLayout_allocs)

	x.refa5d685fc = refa5d685fc
	x.allocsa5d685fc = allocsa5d685fc
	return refa5d685fc, allocsa5d685fc

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x AttachmentDescription) PassValue() (C.VkAttachmentDescription, *cgoAllocMap) {
	if x.refa5d685fc != nil {
		return *x.refa5d685fc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *AttachmentDescription) Deref() {
	if x.refa5d685fc == nil {
		return
	}
	x.Flags = (AttachmentDescriptionFlags)(x.refa5d685fc.flags)
	x.Format = (Format)(x.refa5d685fc.format)
	x.Samples = (SampleCountFlagBits)(x.refa5d685fc.samples)
	x.LoadOp = (AttachmentLoadOp)(x.refa5d685fc.loadOp)
	x.StoreOp = (AttachmentStoreOp)(x.refa5d685fc.storeOp)
	x.StencilLoadOp = (AttachmentLoadOp)(x.refa5d685fc.stencilLoadOp)
	x.StencilStoreOp = (AttachmentStoreOp)(x.refa5d685fc.stencilStoreOp)
	x.InitialLayout = (ImageLayout)(x.refa5d685fc.initialLayout)
	x.FinalLayout = (ImageLayout)(x.refa5d685fc.finalLayout)
}

// allocAttachmentReferenceMemory allocates memory for type C.VkAttachmentReference in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentReferenceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentReferenceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAttachmentReferenceValue = unsafe.Sizeof([1]C.VkAttachmentReference{})

// Ref returns a reference.
func (x *AttachmentReference) Ref() *C.VkAttachmentReference {
	if x == nil {
		return nil
	}
	return x.refef4776de
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *AttachmentReference) Free() {
	if x != nil && x.allocsef4776de != nil {
		x.allocsef4776de.(*cgoAllocMap).Free()
		x.refef4776de = nil
	}
}

// NewAttachmentReferenceRef initialises a new struct holding the reference to the originaitng C struct.
func NewAttachmentReferenceRef(ref interface{}) *AttachmentReference {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(AttachmentReference)
	obj.refef4776de = (*C.VkAttachmentReference)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *AttachmentReference) PassRef() (*C.VkAttachmentReference, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refef4776de != nil {
		return x.refef4776de, nil
	}
	memef4776de := allocAttachmentReferenceMemory(1)
	refef4776de := (*C.VkAttachmentReference)(memef4776de)
	allocsef4776de := new(cgoAllocMap)
	var cattachment_allocs *cgoAllocMap
	refef4776de.attachment, cattachment_allocs = (C.uint32_t)(x.Attachment), cgoAllocsUnknown
	allocsef4776de.Borrow(cattachment_allocs)

	var clayout_allocs *cgoAllocMap
	refef4776de.layout, clayout_allocs = (C.VkImageLayout)(x.Layout), cgoAllocsUnknown
	allocsef4776de.Borrow(clayout_allocs)

	x.refef4776de = refef4776de
	x.allocsef4776de = allocsef4776de
	return refef4776de, allocsef4776de

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x AttachmentReference) PassValue() (C.VkAttachmentReference, *cgoAllocMap) {
	if x.refef4776de != nil {
		return *x.refef4776de, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *AttachmentReference) Deref() {
	if x.refef4776de == nil {
		return
	}
	x.Attachment = (uint32)(x.refef4776de.attachment)
	x.Layout = (ImageLayout)(x.refef4776de.layout)
}

// allocSubpassDescriptionMemory allocates memory for type C.VkSubpassDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassDescriptionValue = unsafe.Sizeof([1]C.VkSubpassDescription{})

// unpackSAttachmentReference transforms a sliced Go data structure into plain C format.
func unpackSAttachmentReference(x []AttachmentReference) (unpacked *C.VkAttachmentReference, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAttachmentReference) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentReferenceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentReference)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentReference)(unsafe.Pointer(h.Data))
	return
}

// packSAttachmentReference reads sliced Go data structure out from plain C format.
func packSAttachmentReference(v []AttachmentReference, ptr0 *C.VkAttachmentReference) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentReferenceValue]C.VkAttachmentReference)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentReferenceRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *SubpassDescription) Ref() *C.VkSubpassDescription {
	if x == nil {
		return nil
	}
	return x.refc7bfeda
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SubpassDescription) Free() {
	if x != nil && x.allocsc7bfeda != nil {
		x.allocsc7bfeda.(*cgoAllocMap).Free()
		x.refc7bfeda = nil
	}
}

// NewSubpassDescriptionRef initialises a new struct holding the reference to the originaitng C struct.
func NewSubpassDescriptionRef(ref interface{}) *SubpassDescription {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SubpassDescription)
	obj.refc7bfeda = (*C.VkSubpassDescription)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SubpassDescription) PassRef() (*C.VkSubpassDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc7bfeda != nil {
		return x.refc7bfeda, nil
	}
	memc7bfeda := allocSubpassDescriptionMemory(1)
	refc7bfeda := (*C.VkSubpassDescription)(memc7bfeda)
	allocsc7bfeda := new(cgoAllocMap)
	var cflags_allocs *cgoAllocMap
	refc7bfeda.flags, cflags_allocs = (C.VkSubpassDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cflags_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	refc7bfeda.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cpipelineBindPoint_allocs)

	var cinputAttachmentCount_allocs *cgoAllocMap
	refc7bfeda.inputAttachmentCount, cinputAttachmentCount_allocs = (C.uint32_t)(x.InputAttachmentCount), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cinputAttachmentCount_allocs)

	var cpInputAttachments_allocs *cgoAllocMap
	refc7bfeda.pInputAttachments, cpInputAttachments_allocs = unpackSAttachmentReference(x.PInputAttachments)
	allocsc7bfeda.Borrow(cpInputAttachments_allocs)

	var ccolorAttachmentCount_allocs *cgoAllocMap
	refc7bfeda.colorAttachmentCount, ccolorAttachmentCount_allocs = (C.uint32_t)(x.ColorAttachmentCount), cgoAllocsUnknown
	allocsc7bfeda.Borrow(ccolorAttachmentCount_allocs)

	var cpColorAttachments_allocs *cgoAllocMap
	refc7bfeda.pColorAttachments, cpColorAttachments_allocs = unpackSAttachmentReference(x.PColorAttachments)
	allocsc7bfeda.Borrow(cpColorAttachments_allocs)

	var cpResolveAttachments_allocs *cgoAllocMap
	refc7bfeda.pResolveAttachments, cpResolveAttachments_allocs = unpackSAttachmentReference(x.PResolveAttachments)
	allocsc7bfeda.Borrow(cpResolveAttachments_allocs)

	var cpDepthStencilAttachment_allocs *cgoAllocMap
	refc7bfeda.pDepthStencilAttachment, cpDepthStencilAttachment_allocs = unpackSAttachmentReference(x.PDepthStencilAttachment)
	allocsc7bfeda.Borrow(cpDepthStencilAttachment_allocs)

	var cpreserveAttachmentCount_allocs *cgoAllocMap
	refc7bfeda.preserveAttachmentCount, cpreserveAttachmentCount_allocs = (C.uint32_t)(x.PreserveAttachmentCount), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cpreserveAttachmentCount_allocs)

	var cpPreserveAttachments_allocs *cgoAllocMap
	refc7bfeda.pPreserveAttachments, cpPreserveAttachments_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments)).Data)), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cpPreserveAttachments_allocs)

	x.refc7bfeda = refc7bfeda
	x.allocsc7bfeda = allocsc7bfeda
	return refc7bfeda, allocsc7bfeda

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SubpassDescription) PassValue() (C.VkSubpassDescription, *cgoAllocMap) {
	if x.refc7bfeda != nil {
		return *x.refc7bfeda, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SubpassDescription) Deref() {
	if x.refc7bfeda == nil {
		return
	}
	x.Flags = (SubpassDescriptionFlags)(x.refc7bfeda.flags)
	x.PipelineBindPoint = (PipelineBindPoint)(x.refc7bfeda.pipelineBindPoint)
	x.InputAttachmentCount = (uint32)(x.refc7bfeda.inputAttachmentCount)
	packSAttachmentReference(x.PInputAttachments, x.refc7bfeda.pInputAttachments)
	x.ColorAttachmentCount = (uint32)(x.refc7bfeda.colorAttachmentCount)
	packSAttachmentReference(x.PColorAttachments, x.refc7bfeda.pColorAttachments)
	packSAttachmentReference(x.PResolveAttachments, x.refc7bfeda.pResolveAttachments)
	packSAttachmentReference(x.PDepthStencilAttachment, x.refc7bfeda.pDepthStencilAttachment)
	x.PreserveAttachmentCount = (uint32)(x.refc7bfeda.preserveAttachmentCount)
	hxf21690b := (*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments))
	hxf21690b.Data = uintptr(unsafe.Pointer(x.refc7bfeda.pPreserveAttachments))
	hxf21690b.Cap = 0x7fffffff
	// hxf21690b.Len = ?

}

// allocSubpassDependencyMemory allocates memory for type C.VkSubpassDependency in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDependencyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDependencyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassDependencyValue = unsafe.Sizeof([1]C.VkSubpassDependency{})

// Ref returns a reference.
func (x *SubpassDependency) Ref() *C.VkSubpassDependency {
	if x == nil {
		return nil
	}
	return x.refdb197adb
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SubpassDependency) Free() {
	if x != nil && x.allocsdb197adb != nil {
		x.allocsdb197adb.(*cgoAllocMap).Free()
		x.refdb197adb = nil
	}
}

// NewSubpassDependencyRef initialises a new struct holding the reference to the originaitng C struct.
func NewSubpassDependencyRef(ref interface{}) *SubpassDependency {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SubpassDependency)
	obj.refdb197adb = (*C.VkSubpassDependency)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SubpassDependency) PassRef() (*C.VkSubpassDependency, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb197adb != nil {
		return x.refdb197adb, nil
	}
	memdb197adb := allocSubpassDependencyMemory(1)
	refdb197adb := (*C.VkSubpassDependency)(memdb197adb)
	allocsdb197adb := new(cgoAllocMap)
	var csrcSubpass_allocs *cgoAllocMap
	refdb197adb.srcSubpass, csrcSubpass_allocs = (C.uint32_t)(x.SrcSubpass), cgoAllocsUnknown
	allocsdb197adb.Borrow(csrcSubpass_allocs)

	var cdstSubpass_allocs *cgoAllocMap
	refdb197adb.dstSubpass, cdstSubpass_allocs = (C.uint32_t)(x.DstSubpass), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdstSubpass_allocs)

	var csrcStageMask_allocs *cgoAllocMap
	refdb197adb.srcStageMask, csrcStageMask_allocs = (C.VkPipelineStageFlags)(x.SrcStageMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(csrcStageMask_allocs)

	var cdstStageMask_allocs *cgoAllocMap
	refdb197adb.dstStageMask, cdstStageMask_allocs = (C.VkPipelineStageFlags)(x.DstStageMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdstStageMask_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refdb197adb.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refdb197adb.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdstAccessMask_allocs)

	var cdependencyFlags_allocs *cgoAllocMap
	refdb197adb.dependencyFlags, cdependencyFlags_allocs = (C.VkDependencyFlags)(x.DependencyFlags), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdependencyFlags_allocs)

	x.refdb197adb = refdb197adb
	x.allocsdb197adb = allocsdb197adb
	return refdb197adb, allocsdb197adb

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SubpassDependency) PassValue() (C.VkSubpassDependency, *cgoAllocMap) {
	if x.refdb197adb != nil {
		return *x.refdb197adb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SubpassDependency) Deref() {
	if x.refdb197adb == nil {
		return
	}
	x.SrcSubpass = (uint32)(x.refdb197adb.srcSubpass)
	x.DstSubpass = (uint32)(x.refdb197adb.dstSubpass)
	x.SrcStageMask = (PipelineStageFlags)(x.refdb197adb.srcStageMask)
	x.DstStageMask = (PipelineStageFlags)(x.refdb197adb.dstStageMask)
	x.SrcAccessMask = (AccessFlags)(x.refdb197adb.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refdb197adb.dstAccessMask)
	x.DependencyFlags = (DependencyFlags)(x.refdb197adb.dependencyFlags)
}

// allocRenderPassCreateInfoMemory allocates memory for type C.VkRenderPassCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassCreateInfoValue = unsafe.Sizeof([1]C.VkRenderPassCreateInfo{})

// unpackSAttachmentDescription transforms a sliced Go data structure into plain C format.
func unpackSAttachmentDescription(x []AttachmentDescription) (unpacked *C.VkAttachmentDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAttachmentDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentDescription)(unsafe.Pointer(h.Data))
	return
}

// unpackSSubpassDescription transforms a sliced Go data structure into plain C format.
func unpackSSubpassDescription(x []SubpassDescription) (unpacked *C.VkSubpassDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDescription)(unsafe.Pointer(h.Data))
	return
}

// unpackSSubpassDependency transforms a sliced Go data structure into plain C format.
func unpackSSubpassDependency(x []SubpassDependency) (unpacked *C.VkSubpassDependency, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassDependency) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDependencyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDependency)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDependency)(unsafe.Pointer(h.Data))
	return
}

// packSAttachmentDescription reads sliced Go data structure out from plain C format.
func packSAttachmentDescription(v []AttachmentDescription, ptr0 *C.VkAttachmentDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentDescriptionValue]C.VkAttachmentDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassDescription reads sliced Go data structure out from plain C format.
func packSSubpassDescription(v []SubpassDescription, ptr0 *C.VkSubpassDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDescriptionValue]C.VkSubpassDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassDependency reads sliced Go data structure out from plain C format.
func packSSubpassDependency(v []SubpassDependency, ptr0 *C.VkSubpassDependency) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDependencyValue]C.VkSubpassDependency)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDependencyRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *RenderPassCreateInfo) Ref() *C.VkRenderPassCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref886d7d86
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *RenderPassCreateInfo) Free() {
	if x != nil && x.allocs886d7d86 != nil {
		x.allocs886d7d86.(*cgoAllocMap).Free()
		x.ref886d7d86 = nil
	}
}

// NewRenderPassCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewRenderPassCreateInfoRef(ref interface{}) *RenderPassCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(RenderPassCreateInfo)
	obj.ref886d7d86 = (*C.VkRenderPassCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *RenderPassCreateInfo) PassRef() (*C.VkRenderPassCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref886d7d86 != nil {
		return x.ref886d7d86, nil
	}
	mem886d7d86 := allocRenderPassCreateInfoMemory(1)
	ref886d7d86 := (*C.VkRenderPassCreateInfo)(mem886d7d86)
	allocs886d7d86 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref886d7d86.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs886d7d86.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref886d7d86.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs886d7d86.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref886d7d86.flags, cflags_allocs = (C.VkRenderPassCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs886d7d86.Borrow(cflags_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	ref886d7d86.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocs886d7d86.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	ref886d7d86.pAttachments, cpAttachments_allocs = unpackSAttachmentDescription(x.PAttachments)
	allocs886d7d86.Borrow(cpAttachments_allocs)

	var csubpassCount_allocs *cgoAllocMap
	ref886d7d86.subpassCount, csubpassCount_allocs = (C.uint32_t)(x.SubpassCount), cgoAllocsUnknown
	allocs886d7d86.Borrow(csubpassCount_allocs)

	var cpSubpasses_allocs *cgoAllocMap
	ref886d7d86.pSubpasses, cpSubpasses_allocs = unpackSSubpassDescription(x.PSubpasses)
	allocs886d7d86.Borrow(cpSubpasses_allocs)

	var cdependencyCount_allocs *cgoAllocMap
	ref886d7d86.dependencyCount, cdependencyCount_allocs = (C.uint32_t)(x.DependencyCount), cgoAllocsUnknown
	allocs886d7d86.Borrow(cdependencyCount_allocs)

	var cpDependencies_allocs *cgoAllocMap
	ref886d7d86.pDependencies, cpDependencies_allocs = unpackSSubpassDependency(x.PDependencies)
	allocs886d7d86.Borrow(cpDependencies_allocs)

	x.ref886d7d86 = ref886d7d86
	x.allocs886d7d86 = allocs886d7d86
	return ref886d7d86, allocs886d7d86

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x RenderPassCreateInfo) PassValue() (C.VkRenderPassCreateInfo, *cgoAllocMap) {
	if x.ref886d7d86 != nil {
		return *x.ref886d7d86, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *RenderPassCreateInfo) Deref() {
	if x.ref886d7d86 == nil {
		return
	}
	x.SType = (StructureType)(x.ref886d7d86.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref886d7d86.pNext))
	x.Flags = (RenderPassCreateFlags)(x.ref886d7d86.flags)
	x.AttachmentCount = (uint32)(x.ref886d7d86.attachmentCount)
	packSAttachmentDescription(x.PAttachments, x.ref886d7d86.pAttachments)
	x.SubpassCount = (uint32)(x.ref886d7d86.subpassCount)
	packSSubpassDescription(x.PSubpasses, x.ref886d7d86.pSubpasses)
	x.DependencyCount = (uint32)(x.ref886d7d86.dependencyCount)
	packSSubpassDependency(x.PDependencies, x.ref886d7d86.pDependencies)
}

// allocCommandPoolCreateInfoMemory allocates memory for type C.VkCommandPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandPoolCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandPoolCreateInfoValue = unsafe.Sizeof([1]C.VkCommandPoolCreateInfo{})

// Ref returns a reference.
func (x *CommandPoolCreateInfo) Ref() *C.VkCommandPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref73550de0
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *CommandPoolCreateInfo) Free() {
	if x != nil && x.allocs73550de0 != nil {
		x.allocs73550de0.(*cgoAllocMap).Free()
		x.ref73550de0 = nil
	}
}

// NewCommandPoolCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewCommandPoolCreateInfoRef(ref interface{}) *CommandPoolCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(CommandPoolCreateInfo)
	obj.ref73550de0 = (*C.VkCommandPoolCreateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *CommandPoolCreateInfo) PassRef() (*C.VkCommandPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref73550de0 != nil {
		return x.ref73550de0, nil
	}
	mem73550de0 := allocCommandPoolCreateInfoMemory(1)
	ref73550de0 := (*C.VkCommandPoolCreateInfo)(mem73550de0)
	allocs73550de0 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref73550de0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs73550de0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref73550de0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs73550de0.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref73550de0.flags, cflags_allocs = (C.VkCommandPoolCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs73550de0.Borrow(cflags_allocs)

	var cqueueFamilyIndex_allocs *cgoAllocMap
	ref73550de0.queueFamilyIndex, cqueueFamilyIndex_allocs = (C.uint32_t)(x.QueueFamilyIndex), cgoAllocsUnknown
	allocs73550de0.Borrow(cqueueFamilyIndex_allocs)

	x.ref73550de0 = ref73550de0
	x.allocs73550de0 = allocs73550de0
	return ref73550de0, allocs73550de0

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x CommandPoolCreateInfo) PassValue() (C.VkCommandPoolCreateInfo, *cgoAllocMap) {
	if x.ref73550de0 != nil {
		return *x.ref73550de0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *CommandPoolCreateInfo) Deref() {
	if x.ref73550de0 == nil {
		return
	}
	x.SType = (StructureType)(x.ref73550de0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref73550de0.pNext))
	x.Flags = (CommandPoolCreateFlags)(x.ref73550de0.flags)
	x.QueueFamilyIndex = (uint32)(x.ref73550de0.queueFamilyIndex)
}

// allocCommandBufferAllocateInfoMemory allocates memory for type C.VkCommandBufferAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandBufferAllocateInfoValue = unsafe.Sizeof([1]C.VkCommandBufferAllocateInfo{})

// Ref returns a reference.
func (x *CommandBufferAllocateInfo) Ref() *C.VkCommandBufferAllocateInfo {
	if x == nil {
		return nil
	}
	return x.refd1a0a7c8
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *CommandBufferAllocateInfo) Free() {
	if x != nil && x.allocsd1a0a7c8 != nil {
		x.allocsd1a0a7c8.(*cgoAllocMap).Free()
		x.refd1a0a7c8 = nil
	}
}

// NewCommandBufferAllocateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewCommandBufferAllocateInfoRef(ref interface{}) *CommandBufferAllocateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(CommandBufferAllocateInfo)
	obj.refd1a0a7c8 = (*C.VkCommandBufferAllocateInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *CommandBufferAllocateInfo) PassRef() (*C.VkCommandBufferAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd1a0a7c8 != nil {
		return x.refd1a0a7c8, nil
	}
	memd1a0a7c8 := allocCommandBufferAllocateInfoMemory(1)
	refd1a0a7c8 := (*C.VkCommandBufferAllocateInfo)(memd1a0a7c8)
	allocsd1a0a7c8 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refd1a0a7c8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd1a0a7c8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(cpNext_allocs)

	var ccommandPool_allocs *cgoAllocMap
	refd1a0a7c8.commandPool, ccommandPool_allocs = *(*C.VkCommandPool)(unsafe.Pointer(&x.CommandPool)), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(ccommandPool_allocs)

	var clevel_allocs *cgoAllocMap
	refd1a0a7c8.level, clevel_allocs = (C.VkCommandBufferLevel)(x.Level), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(clevel_allocs)

	var ccommandBufferCount_allocs *cgoAllocMap
	refd1a0a7c8.commandBufferCount, ccommandBufferCount_allocs = (C.uint32_t)(x.CommandBufferCount), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(ccommandBufferCount_allocs)

	x.refd1a0a7c8 = refd1a0a7c8
	x.allocsd1a0a7c8 = allocsd1a0a7c8
	return refd1a0a7c8, allocsd1a0a7c8

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x CommandBufferAllocateInfo) PassValue() (C.VkCommandBufferAllocateInfo, *cgoAllocMap) {
	if x.refd1a0a7c8 != nil {
		return *x.refd1a0a7c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *CommandBufferAllocateInfo) Deref() {
	if x.refd1a0a7c8 == nil {
		return
	}
	x.SType = (StructureType)(x.refd1a0a7c8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd1a0a7c8.pNext))
	x.CommandPool = *(*CommandPool)(unsafe.Pointer(&x.refd1a0a7c8.commandPool))
	x.Level = (CommandBufferLevel)(x.refd1a0a7c8.level)
	x.CommandBufferCount = (uint32)(x.refd1a0a7c8.commandBufferCount)
}

// allocCommandBufferInheritanceInfoMemory allocates memory for type C.VkCommandBufferInheritanceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferInheritanceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferInheritanceInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandBufferInheritanceInfoValue = unsafe.Sizeof([1]C.VkCommandBufferInheritanceInfo{})

// Ref returns a reference.
func (x *CommandBufferInheritanceInfo) Ref() *C.VkCommandBufferInheritanceInfo {
	if x == nil {
		return nil
	}
	return x.ref737f8019
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *CommandBufferInheritanceInfo) Free() {
	if x != nil && x.allocs737f8019 != nil {
		x.allocs737f8019.(*cgoAllocMap).Free()
		x.ref737f8019 = nil
	}
}

// NewCommandBufferInheritanceInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewCommandBufferInheritanceInfoRef(ref interface{}) *CommandBufferInheritanceInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(CommandBufferInheritanceInfo)
	obj.ref737f8019 = (*C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *CommandBufferInheritanceInfo) PassRef() (*C.VkCommandBufferInheritanceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref737f8019 != nil {
		return x.ref737f8019, nil
	}
	mem737f8019 := allocCommandBufferInheritanceInfoMemory(1)
	ref737f8019 := (*C.VkCommandBufferInheritanceInfo)(mem737f8019)
	allocs737f8019 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref737f8019.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs737f8019.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref737f8019.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs737f8019.Borrow(cpNext_allocs)

	var crenderPass_allocs *cgoAllocMap
	ref737f8019.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocs737f8019.Borrow(crenderPass_allocs)

	var csubpass_allocs *cgoAllocMap
	ref737f8019.subpass, csubpass_allocs = (C.uint32_t)(x.Subpass), cgoAllocsUnknown
	allocs737f8019.Borrow(csubpass_allocs)

	var cframebuffer_allocs *cgoAllocMap
	ref737f8019.framebuffer, cframebuffer_allocs = *(*C.VkFramebuffer)(unsafe.Pointer(&x.Framebuffer)), cgoAllocsUnknown
	allocs737f8019.Borrow(cframebuffer_allocs)

	var cocclusionQueryEnable_allocs *cgoAllocMap
	ref737f8019.occlusionQueryEnable, cocclusionQueryEnable_allocs = (C.VkBool32)(x.OcclusionQueryEnable), cgoAllocsUnknown
	allocs737f8019.Borrow(cocclusionQueryEnable_allocs)

	var cqueryFlags_allocs *cgoAllocMap
	ref737f8019.queryFlags, cqueryFlags_allocs = (C.VkQueryControlFlags)(x.QueryFlags), cgoAllocsUnknown
	allocs737f8019.Borrow(cqueryFlags_allocs)

	var cpipelineStatistics_allocs *cgoAllocMap
	ref737f8019.pipelineStatistics, cpipelineStatistics_allocs = (C.VkQueryPipelineStatisticFlags)(x.PipelineStatistics), cgoAllocsUnknown
	allocs737f8019.Borrow(cpipelineStatistics_allocs)

	x.ref737f8019 = ref737f8019
	x.allocs737f8019 = allocs737f8019
	return ref737f8019, allocs737f8019

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x CommandBufferInheritanceInfo) PassValue() (C.VkCommandBufferInheritanceInfo, *cgoAllocMap) {
	if x.ref737f8019 != nil {
		return *x.ref737f8019, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *CommandBufferInheritanceInfo) Deref() {
	if x.ref737f8019 == nil {
		return
	}
	x.SType = (StructureType)(x.ref737f8019.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref737f8019.pNext))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref737f8019.renderPass))
	x.Subpass = (uint32)(x.ref737f8019.subpass)
	x.Framebuffer = *(*Framebuffer)(unsafe.Pointer(&x.ref737f8019.framebuffer))
	x.OcclusionQueryEnable = (Bool32)(x.ref737f8019.occlusionQueryEnable)
	x.QueryFlags = (QueryControlFlags)(x.ref737f8019.queryFlags)
	x.PipelineStatistics = (QueryPipelineStatisticFlags)(x.ref737f8019.pipelineStatistics)
}

// allocCommandBufferBeginInfoMemory allocates memory for type C.VkCommandBufferBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferBeginInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandBufferBeginInfoValue = unsafe.Sizeof([1]C.VkCommandBufferBeginInfo{})

// unpackSCommandBufferInheritanceInfo transforms a sliced Go data structure into plain C format.
func unpackSCommandBufferInheritanceInfo(x []CommandBufferInheritanceInfo) (unpacked *C.VkCommandBufferInheritanceInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkCommandBufferInheritanceInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCommandBufferInheritanceInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(h.Data))
	return
}

// packSCommandBufferInheritanceInfo reads sliced Go data structure out from plain C format.
func packSCommandBufferInheritanceInfo(v []CommandBufferInheritanceInfo, ptr0 *C.VkCommandBufferInheritanceInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCommandBufferInheritanceInfoValue]C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandBufferInheritanceInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *CommandBufferBeginInfo) Ref() *C.VkCommandBufferBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref266762df
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *CommandBufferBeginInfo) Free() {
	if x != nil && x.allocs266762df != nil {
		x.allocs266762df.(*cgoAllocMap).Free()
		x.ref266762df = nil
	}
}

// NewCommandBufferBeginInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewCommandBufferBeginInfoRef(ref interface{}) *CommandBufferBeginInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(CommandBufferBeginInfo)
	obj.ref266762df = (*C.VkCommandBufferBeginInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *CommandBufferBeginInfo) PassRef() (*C.VkCommandBufferBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref266762df != nil {
		return x.ref266762df, nil
	}
	mem266762df := allocCommandBufferBeginInfoMemory(1)
	ref266762df := (*C.VkCommandBufferBeginInfo)(mem266762df)
	allocs266762df := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref266762df.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs266762df.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref266762df.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs266762df.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref266762df.flags, cflags_allocs = (C.VkCommandBufferUsageFlags)(x.Flags), cgoAllocsUnknown
	allocs266762df.Borrow(cflags_allocs)

	var cpInheritanceInfo_allocs *cgoAllocMap
	ref266762df.pInheritanceInfo, cpInheritanceInfo_allocs = unpackSCommandBufferInheritanceInfo(x.PInheritanceInfo)
	allocs266762df.Borrow(cpInheritanceInfo_allocs)

	x.ref266762df = ref266762df
	x.allocs266762df = allocs266762df
	return ref266762df, allocs266762df

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x CommandBufferBeginInfo) PassValue() (C.VkCommandBufferBeginInfo, *cgoAllocMap) {
	if x.ref266762df != nil {
		return *x.ref266762df, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *CommandBufferBeginInfo) Deref() {
	if x.ref266762df == nil {
		return
	}
	x.SType = (StructureType)(x.ref266762df.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref266762df.pNext))
	x.Flags = (CommandBufferUsageFlags)(x.ref266762df.flags)
	packSCommandBufferInheritanceInfo(x.PInheritanceInfo, x.ref266762df.pInheritanceInfo)
}

// allocBufferCopyMemory allocates memory for type C.VkBufferCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferCopyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferCopyValue = unsafe.Sizeof([1]C.VkBufferCopy{})

// Ref returns a reference.
func (x *BufferCopy) Ref() *C.VkBufferCopy {
	if x == nil {
		return nil
	}
	return x.ref12184ffd
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *BufferCopy) Free() {
	if x != nil && x.allocs12184ffd != nil {
		x.allocs12184ffd.(*cgoAllocMap).Free()
		x.ref12184ffd = nil
	}
}

// NewBufferCopyRef initialises a new struct holding the reference to the originaitng C struct.
func NewBufferCopyRef(ref interface{}) *BufferCopy {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(BufferCopy)
	obj.ref12184ffd = (*C.VkBufferCopy)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *BufferCopy) PassRef() (*C.VkBufferCopy, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref12184ffd != nil {
		return x.ref12184ffd, nil
	}
	mem12184ffd := allocBufferCopyMemory(1)
	ref12184ffd := (*C.VkBufferCopy)(mem12184ffd)
	allocs12184ffd := new(cgoAllocMap)
	var csrcOffset_allocs *cgoAllocMap
	ref12184ffd.srcOffset, csrcOffset_allocs = (C.VkDeviceSize)(x.SrcOffset), cgoAllocsUnknown
	allocs12184ffd.Borrow(csrcOffset_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref12184ffd.dstOffset, cdstOffset_allocs = (C.VkDeviceSize)(x.DstOffset), cgoAllocsUnknown
	allocs12184ffd.Borrow(cdstOffset_allocs)

	var csize_allocs *cgoAllocMap
	ref12184ffd.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs12184ffd.Borrow(csize_allocs)

	x.ref12184ffd = ref12184ffd
	x.allocs12184ffd = allocs12184ffd
	return ref12184ffd, allocs12184ffd

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x BufferCopy) PassValue() (C.VkBufferCopy, *cgoAllocMap) {
	if x.ref12184ffd != nil {
		return *x.ref12184ffd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *BufferCopy) Deref() {
	if x.ref12184ffd == nil {
		return
	}
	x.SrcOffset = (DeviceSize)(x.ref12184ffd.srcOffset)
	x.DstOffset = (DeviceSize)(x.ref12184ffd.dstOffset)
	x.Size = (DeviceSize)(x.ref12184ffd.size)
}

// allocImageSubresourceLayersMemory allocates memory for type C.VkImageSubresourceLayers in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceLayersMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceLayersValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSubresourceLayersValue = unsafe.Sizeof([1]C.VkImageSubresourceLayers{})

// Ref returns a reference.
func (x *ImageSubresourceLayers) Ref() *C.VkImageSubresourceLayers {
	if x == nil {
		return nil
	}
	return x.ref3b13bcd2
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageSubresourceLayers) Free() {
	if x != nil && x.allocs3b13bcd2 != nil {
		x.allocs3b13bcd2.(*cgoAllocMap).Free()
		x.ref3b13bcd2 = nil
	}
}

// NewImageSubresourceLayersRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageSubresourceLayersRef(ref interface{}) *ImageSubresourceLayers {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ImageSubresourceLayers)
	obj.ref3b13bcd2 = (*C.VkImageSubresourceLayers)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageSubresourceLayers) PassRef() (*C.VkImageSubresourceLayers, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3b13bcd2 != nil {
		return x.ref3b13bcd2, nil
	}
	mem3b13bcd2 := allocImageSubresourceLayersMemory(1)
	ref3b13bcd2 := (*C.VkImageSubresourceLayers)(mem3b13bcd2)
	allocs3b13bcd2 := new(cgoAllocMap)
	var caspectMask_allocs *cgoAllocMap
	ref3b13bcd2.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(caspectMask_allocs)

	var cmipLevel_allocs *cgoAllocMap
	ref3b13bcd2.mipLevel, cmipLevel_allocs = (C.uint32_t)(x.MipLevel), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(cmipLevel_allocs)

	var cbaseArrayLayer_allocs *cgoAllocMap
	ref3b13bcd2.baseArrayLayer, cbaseArrayLayer_allocs = (C.uint32_t)(x.BaseArrayLayer), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(cbaseArrayLayer_allocs)

	var clayerCount_allocs *cgoAllocMap
	ref3b13bcd2.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(clayerCount_allocs)

	x.ref3b13bcd2 = ref3b13bcd2
	x.allocs3b13bcd2 = allocs3b13bcd2
	return ref3b13bcd2, allocs3b13bcd2

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ImageSubresourceLayers) PassValue() (C.VkImageSubresourceLayers, *cgoAllocMap) {
	if x.ref3b13bcd2 != nil {
		return *x.ref3b13bcd2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageSubresourceLayers) Deref() {
	if x.ref3b13bcd2 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.ref3b13bcd2.aspectMask)
	x.MipLevel = (uint32)(x.ref3b13bcd2.mipLevel)
	x.BaseArrayLayer = (uint32)(x.ref3b13bcd2.baseArrayLayer)
	x.LayerCount = (uint32)(x.ref3b13bcd2.layerCount)
}

// allocImageCopyMemory allocates memory for type C.VkImageCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCopyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageCopyValue = unsafe.Sizeof([1]C.VkImageCopy{})

// Ref returns a reference.
func (x *ImageCopy) Ref() *C.VkImageCopy {
	if x == nil {
		return nil
	}
	return x.ref4e7a1214
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageCopy) Free() {
	if x != nil && x.allocs4e7a1214 != nil {
		x.allocs4e7a1214.(*cgoAllocMap).Free()
		x.ref4e7a1214 = nil
	}
}

// NewImageCopyRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageCopyRef(ref interface{}) *ImageCopy {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ImageCopy)
	obj.ref4e7a1214 = (*C.VkImageCopy)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageCopy) PassRef() (*C.VkImageCopy, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4e7a1214 != nil {
		return x.ref4e7a1214, nil
	}
	mem4e7a1214 := allocImageCopyMemory(1)
	ref4e7a1214 := (*C.VkImageCopy)(mem4e7a1214)
	allocs4e7a1214 := new(cgoAllocMap)
	var csrcSubresource_allocs *cgoAllocMap
	ref4e7a1214.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs4e7a1214.Borrow(csrcSubresource_allocs)

	var csrcOffset_allocs *cgoAllocMap
	ref4e7a1214.srcOffset, csrcOffset_allocs = x.SrcOffset.PassValue()
	allocs4e7a1214.Borrow(csrcOffset_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref4e7a1214.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs4e7a1214.Borrow(cdstSubresource_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref4e7a1214.dstOffset, cdstOffset_allocs = x.DstOffset.PassValue()
	allocs4e7a1214.Borrow(cdstOffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref4e7a1214.extent, cextent_allocs = x.Extent.PassValue()
	allocs4e7a1214.Borrow(cextent_allocs)

	x.ref4e7a1214 = ref4e7a1214
	x.allocs4e7a1214 = allocs4e7a1214
	return ref4e7a1214, allocs4e7a1214

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ImageCopy) PassValue() (C.VkImageCopy, *cgoAllocMap) {
	if x.ref4e7a1214 != nil {
		return *x.ref4e7a1214, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageCopy) Deref() {
	if x.ref4e7a1214 == nil {
		return
	}
	x.SrcSubresource = *NewImageSubresourceLayersRef(&x.ref4e7a1214.srcSubresource)
	x.SrcOffset = *NewOffset3DRef(&x.ref4e7a1214.srcOffset)
	x.DstSubresource = *NewImageSubresourceLayersRef(&x.ref4e7a1214.dstSubresource)
	x.DstOffset = *NewOffset3DRef(&x.ref4e7a1214.dstOffset)
	x.Extent = *NewExtent3DRef(&x.ref4e7a1214.extent)
}

// allocImageBlitMemory allocates memory for type C.VkImageBlit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageBlitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageBlitValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageBlitValue = unsafe.Sizeof([1]C.VkImageBlit{})

// allocA2Offset3DMemory allocates memory for type [2]C.VkOffset3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA2Offset3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA2Offset3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA2Offset3DValue = unsafe.Sizeof([1][2]C.VkOffset3D{})

// unpackA2Offset3D transforms a sliced Go data structure into plain C format.
func unpackA2Offset3D(x [2]Offset3D) (unpacked [2]C.VkOffset3D, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkOffset3D) {
		go allocs.Free()
	})

	mem0 := allocA2Offset3DMemory(1)
	allocs.Add(mem0)
	v0 := (*[2]C.VkOffset3D)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	unpacked = *(*[2]C.VkOffset3D)(mem0)
	return
}

// packA2Offset3D reads sliced Go data structure out from plain C format.
func packA2Offset3D(v *[2]Offset3D, ptr0 *[2]C.VkOffset3D) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewOffset3DRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference.
func (x *ImageBlit) Ref() *C.VkImageBlit {
	if x == nil {
		return nil
	}
	return x.ref11311e8d
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageBlit) Free() {
	if x != nil && x.allocs11311e8d != nil {
		x.allocs11311e8d.(*cgoAllocMap).Free()
		x.ref11311e8d = nil
	}
}

// NewImageBlitRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageBlitRef(ref interface{}) *ImageBlit {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ImageBlit)
	obj.ref11311e8d = (*C.VkImageBlit)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageBlit) PassRef() (*C.VkImageBlit, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11311e8d != nil {
		return x.ref11311e8d, nil
	}
	mem11311e8d := allocImageBlitMemory(1)
	ref11311e8d := (*C.VkImageBlit)(mem11311e8d)
	allocs11311e8d := new(cgoAllocMap)
	var csrcSubresource_allocs *cgoAllocMap
	ref11311e8d.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs11311e8d.Borrow(csrcSubresource_allocs)

	var csrcOffsets_allocs *cgoAllocMap
	ref11311e8d.srcOffsets, csrcOffsets_allocs = unpackA2Offset3D(x.SrcOffsets)
	allocs11311e8d.Borrow(csrcOffsets_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref11311e8d.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs11311e8d.Borrow(cdstSubresource_allocs)

	var cdstOffsets_allocs *cgoAllocMap
	ref11311e8d.dstOffsets, cdstOffsets_allocs = unpackA2Offset3D(x.DstOffsets)
	allocs11311e8d.Borrow(cdstOffsets_allocs)

	x.ref11311e8d = ref11311e8d
	x.allocs11311e8d = allocs11311e8d
	return ref11311e8d, allocs11311e8d

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ImageBlit) PassValue() (C.VkImageBlit, *cgoAllocMap) {
	if x.ref11311e8d != nil {
		return *x.ref11311e8d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageBlit) Deref() {
	if x.ref11311e8d == nil {
		return
	}
	x.SrcSubresource = *NewImageSubresourceLayersRef(&x.ref11311e8d.srcSubresource)
	packA2Offset3D(&x.SrcOffsets, (*[2]C.VkOffset3D)(unsafe.Pointer(&x.ref11311e8d.srcOffsets)))
	x.DstSubresource = *NewImageSubresourceLayersRef(&x.ref11311e8d.dstSubresource)
	packA2Offset3D(&x.DstOffsets, (*[2]C.VkOffset3D)(unsafe.Pointer(&x.ref11311e8d.dstOffsets)))
}

// allocBufferImageCopyMemory allocates memory for type C.VkBufferImageCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferImageCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferImageCopyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferImageCopyValue = unsafe.Sizeof([1]C.VkBufferImageCopy{})

// Ref returns a reference.
func (x *BufferImageCopy) Ref() *C.VkBufferImageCopy {
	if x == nil {
		return nil
	}
	return x.ref6d50e36e
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *BufferImageCopy) Free() {
	if x != nil && x.allocs6d50e36e != nil {
		x.allocs6d50e36e.(*cgoAllocMap).Free()
		x.ref6d50e36e = nil
	}
}

// NewBufferImageCopyRef initialises a new struct holding the reference to the originaitng C struct.
func NewBufferImageCopyRef(ref interface{}) *BufferImageCopy {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(BufferImageCopy)
	obj.ref6d50e36e = (*C.VkBufferImageCopy)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *BufferImageCopy) PassRef() (*C.VkBufferImageCopy, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6d50e36e != nil {
		return x.ref6d50e36e, nil
	}
	mem6d50e36e := allocBufferImageCopyMemory(1)
	ref6d50e36e := (*C.VkBufferImageCopy)(mem6d50e36e)
	allocs6d50e36e := new(cgoAllocMap)
	var cbufferOffset_allocs *cgoAllocMap
	ref6d50e36e.bufferOffset, cbufferOffset_allocs = (C.VkDeviceSize)(x.BufferOffset), cgoAllocsUnknown
	allocs6d50e36e.Borrow(cbufferOffset_allocs)

	var cbufferRowLength_allocs *cgoAllocMap
	ref6d50e36e.bufferRowLength, cbufferRowLength_allocs = (C.uint32_t)(x.BufferRowLength), cgoAllocsUnknown
	allocs6d50e36e.Borrow(cbufferRowLength_allocs)

	var cbufferImageHeight_allocs *cgoAllocMap
	ref6d50e36e.bufferImageHeight, cbufferImageHeight_allocs = (C.uint32_t)(x.BufferImageHeight), cgoAllocsUnknown
	allocs6d50e36e.Borrow(cbufferImageHeight_allocs)

	var cimageSubresource_allocs *cgoAllocMap
	ref6d50e36e.imageSubresource, cimageSubresource_allocs = x.ImageSubresource.PassValue()
	allocs6d50e36e.Borrow(cimageSubresource_allocs)

	var cimageOffset_allocs *cgoAllocMap
	ref6d50e36e.imageOffset, cimageOffset_allocs = x.ImageOffset.PassValue()
	allocs6d50e36e.Borrow(cimageOffset_allocs)

	var cimageExtent_allocs *cgoAllocMap
	ref6d50e36e.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocs6d50e36e.Borrow(cimageExtent_allocs)

	x.ref6d50e36e = ref6d50e36e
	x.allocs6d50e36e = allocs6d50e36e
	return ref6d50e36e, allocs6d50e36e

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x BufferImageCopy) PassValue() (C.VkBufferImageCopy, *cgoAllocMap) {
	if x.ref6d50e36e != nil {
		return *x.ref6d50e36e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *BufferImageCopy) Deref() {
	if x.ref6d50e36e == nil {
		return
	}
	x.BufferOffset = (DeviceSize)(x.ref6d50e36e.bufferOffset)
	x.BufferRowLength = (uint32)(x.ref6d50e36e.bufferRowLength)
	x.BufferImageHeight = (uint32)(x.ref6d50e36e.bufferImageHeight)
	x.ImageSubresource = *NewImageSubresourceLayersRef(&x.ref6d50e36e.imageSubresource)
	x.ImageOffset = *NewOffset3DRef(&x.ref6d50e36e.imageOffset)
	x.ImageExtent = *NewExtent3DRef(&x.ref6d50e36e.imageExtent)
}

// allocClearDepthStencilValueMemory allocates memory for type C.VkClearDepthStencilValue in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearDepthStencilValueMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearDepthStencilValueValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfClearDepthStencilValueValue = unsafe.Sizeof([1]C.VkClearDepthStencilValue{})

// Ref returns a reference.
func (x *ClearDepthStencilValue) Ref() *C.VkClearDepthStencilValue {
	if x == nil {
		return nil
	}
	return x.refa7d07c03
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ClearDepthStencilValue) Free() {
	if x != nil && x.allocsa7d07c03 != nil {
		x.allocsa7d07c03.(*cgoAllocMap).Free()
		x.refa7d07c03 = nil
	}
}

// NewClearDepthStencilValueRef initialises a new struct holding the reference to the originaitng C struct.
func NewClearDepthStencilValueRef(ref interface{}) *ClearDepthStencilValue {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ClearDepthStencilValue)
	obj.refa7d07c03 = (*C.VkClearDepthStencilValue)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ClearDepthStencilValue) PassRef() (*C.VkClearDepthStencilValue, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa7d07c03 != nil {
		return x.refa7d07c03, nil
	}
	mema7d07c03 := allocClearDepthStencilValueMemory(1)
	refa7d07c03 := (*C.VkClearDepthStencilValue)(mema7d07c03)
	allocsa7d07c03 := new(cgoAllocMap)
	var cdepth_allocs *cgoAllocMap
	refa7d07c03.depth, cdepth_allocs = (C.float)(x.Depth), cgoAllocsUnknown
	allocsa7d07c03.Borrow(cdepth_allocs)

	var cstencil_allocs *cgoAllocMap
	refa7d07c03.stencil, cstencil_allocs = (C.uint32_t)(x.Stencil), cgoAllocsUnknown
	allocsa7d07c03.Borrow(cstencil_allocs)

	x.refa7d07c03 = refa7d07c03
	x.allocsa7d07c03 = allocsa7d07c03
	return refa7d07c03, allocsa7d07c03

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ClearDepthStencilValue) PassValue() (C.VkClearDepthStencilValue, *cgoAllocMap) {
	if x.refa7d07c03 != nil {
		return *x.refa7d07c03, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ClearDepthStencilValue) Deref() {
	if x.refa7d07c03 == nil {
		return
	}
	x.Depth = (float32)(x.refa7d07c03.depth)
	x.Stencil = (uint32)(x.refa7d07c03.stencil)
}

// allocClearAttachmentMemory allocates memory for type C.VkClearAttachment in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearAttachmentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearAttachmentValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfClearAttachmentValue = unsafe.Sizeof([1]C.VkClearAttachment{})

// Ref returns a reference.
func (x *ClearAttachment) Ref() *C.VkClearAttachment {
	if x == nil {
		return nil
	}
	return x.refe9150303
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ClearAttachment) Free() {
	if x != nil && x.allocse9150303 != nil {
		x.allocse9150303.(*cgoAllocMap).Free()
		x.refe9150303 = nil
	}
}

// NewClearAttachmentRef initialises a new struct holding the reference to the originaitng C struct.
func NewClearAttachmentRef(ref interface{}) *ClearAttachment {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ClearAttachment)
	obj.refe9150303 = (*C.VkClearAttachment)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ClearAttachment) PassRef() (*C.VkClearAttachment, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe9150303 != nil {
		return x.refe9150303, nil
	}
	meme9150303 := allocClearAttachmentMemory(1)
	refe9150303 := (*C.VkClearAttachment)(meme9150303)
	allocse9150303 := new(cgoAllocMap)
	var caspectMask_allocs *cgoAllocMap
	refe9150303.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocse9150303.Borrow(caspectMask_allocs)

	var ccolorAttachment_allocs *cgoAllocMap
	refe9150303.colorAttachment, ccolorAttachment_allocs = (C.uint32_t)(x.ColorAttachment), cgoAllocsUnknown
	allocse9150303.Borrow(ccolorAttachment_allocs)

	var cclearValue_allocs *cgoAllocMap
	refe9150303.clearValue, cclearValue_allocs = *(*C.VkClearValue)(unsafe.Pointer(&x.ClearValue)), cgoAllocsUnknown
	allocse9150303.Borrow(cclearValue_allocs)

	x.refe9150303 = refe9150303
	x.allocse9150303 = allocse9150303
	return refe9150303, allocse9150303

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ClearAttachment) PassValue() (C.VkClearAttachment, *cgoAllocMap) {
	if x.refe9150303 != nil {
		return *x.refe9150303, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ClearAttachment) Deref() {
	if x.refe9150303 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.refe9150303.aspectMask)
	x.ColorAttachment = (uint32)(x.refe9150303.colorAttachment)
	x.ClearValue = *(*ClearValue)(unsafe.Pointer(&x.refe9150303.clearValue))
}

// allocClearRectMemory allocates memory for type C.VkClearRect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearRectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfClearRectValue = unsafe.Sizeof([1]C.VkClearRect{})

// Ref returns a reference.
func (x *ClearRect) Ref() *C.VkClearRect {
	if x == nil {
		return nil
	}
	return x.ref1d449c8b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ClearRect) Free() {
	if x != nil && x.allocs1d449c8b != nil {
		x.allocs1d449c8b.(*cgoAllocMap).Free()
		x.ref1d449c8b = nil
	}
}

// NewClearRectRef initialises a new struct holding the reference to the originaitng C struct.
func NewClearRectRef(ref interface{}) *ClearRect {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ClearRect)
	obj.ref1d449c8b = (*C.VkClearRect)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ClearRect) PassRef() (*C.VkClearRect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d449c8b != nil {
		return x.ref1d449c8b, nil
	}
	mem1d449c8b := allocClearRectMemory(1)
	ref1d449c8b := (*C.VkClearRect)(mem1d449c8b)
	allocs1d449c8b := new(cgoAllocMap)
	var crect_allocs *cgoAllocMap
	ref1d449c8b.rect, crect_allocs = x.Rect.PassValue()
	allocs1d449c8b.Borrow(crect_allocs)

	var cbaseArrayLayer_allocs *cgoAllocMap
	ref1d449c8b.baseArrayLayer, cbaseArrayLayer_allocs = (C.uint32_t)(x.BaseArrayLayer), cgoAllocsUnknown
	allocs1d449c8b.Borrow(cbaseArrayLayer_allocs)

	var clayerCount_allocs *cgoAllocMap
	ref1d449c8b.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocs1d449c8b.Borrow(clayerCount_allocs)

	x.ref1d449c8b = ref1d449c8b
	x.allocs1d449c8b = allocs1d449c8b
	return ref1d449c8b, allocs1d449c8b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ClearRect) PassValue() (C.VkClearRect, *cgoAllocMap) {
	if x.ref1d449c8b != nil {
		return *x.ref1d449c8b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ClearRect) Deref() {
	if x.ref1d449c8b == nil {
		return
	}
	x.Rect = *NewRect2DRef(&x.ref1d449c8b.rect)
	x.BaseArrayLayer = (uint32)(x.ref1d449c8b.baseArrayLayer)
	x.LayerCount = (uint32)(x.ref1d449c8b.layerCount)
}

// allocImageResolveMemory allocates memory for type C.VkImageResolve in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageResolveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageResolveValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageResolveValue = unsafe.Sizeof([1]C.VkImageResolve{})

// Ref returns a reference.
func (x *ImageResolve) Ref() *C.VkImageResolve {
	if x == nil {
		return nil
	}
	return x.ref7bda856d
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageResolve) Free() {
	if x != nil && x.allocs7bda856d != nil {
		x.allocs7bda856d.(*cgoAllocMap).Free()
		x.ref7bda856d = nil
	}
}

// NewImageResolveRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageResolveRef(ref interface{}) *ImageResolve {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ImageResolve)
	obj.ref7bda856d = (*C.VkImageResolve)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageResolve) PassRef() (*C.VkImageResolve, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7bda856d != nil {
		return x.ref7bda856d, nil
	}
	mem7bda856d := allocImageResolveMemory(1)
	ref7bda856d := (*C.VkImageResolve)(mem7bda856d)
	allocs7bda856d := new(cgoAllocMap)
	var csrcSubresource_allocs *cgoAllocMap
	ref7bda856d.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs7bda856d.Borrow(csrcSubresource_allocs)

	var csrcOffset_allocs *cgoAllocMap
	ref7bda856d.srcOffset, csrcOffset_allocs = x.SrcOffset.PassValue()
	allocs7bda856d.Borrow(csrcOffset_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref7bda856d.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs7bda856d.Borrow(cdstSubresource_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref7bda856d.dstOffset, cdstOffset_allocs = x.DstOffset.PassValue()
	allocs7bda856d.Borrow(cdstOffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref7bda856d.extent, cextent_allocs = x.Extent.PassValue()
	allocs7bda856d.Borrow(cextent_allocs)

	x.ref7bda856d = ref7bda856d
	x.allocs7bda856d = allocs7bda856d
	return ref7bda856d, allocs7bda856d

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ImageResolve) PassValue() (C.VkImageResolve, *cgoAllocMap) {
	if x.ref7bda856d != nil {
		return *x.ref7bda856d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageResolve) Deref() {
	if x.ref7bda856d == nil {
		return
	}
	x.SrcSubresource = *NewImageSubresourceLayersRef(&x.ref7bda856d.srcSubresource)
	x.SrcOffset = *NewOffset3DRef(&x.ref7bda856d.srcOffset)
	x.DstSubresource = *NewImageSubresourceLayersRef(&x.ref7bda856d.dstSubresource)
	x.DstOffset = *NewOffset3DRef(&x.ref7bda856d.dstOffset)
	x.Extent = *NewExtent3DRef(&x.ref7bda856d.extent)
}

// allocMemoryBarrierMemory allocates memory for type C.VkMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryBarrierValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryBarrierValue = unsafe.Sizeof([1]C.VkMemoryBarrier{})

// Ref returns a reference.
func (x *MemoryBarrier) Ref() *C.VkMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.ref977c944e
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *MemoryBarrier) Free() {
	if x != nil && x.allocs977c944e != nil {
		x.allocs977c944e.(*cgoAllocMap).Free()
		x.ref977c944e = nil
	}
}

// NewMemoryBarrierRef initialises a new struct holding the reference to the originaitng C struct.
func NewMemoryBarrierRef(ref interface{}) *MemoryBarrier {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(MemoryBarrier)
	obj.ref977c944e = (*C.VkMemoryBarrier)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *MemoryBarrier) PassRef() (*C.VkMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref977c944e != nil {
		return x.ref977c944e, nil
	}
	mem977c944e := allocMemoryBarrierMemory(1)
	ref977c944e := (*C.VkMemoryBarrier)(mem977c944e)
	allocs977c944e := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref977c944e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs977c944e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref977c944e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs977c944e.Borrow(cpNext_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	ref977c944e.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocs977c944e.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	ref977c944e.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocs977c944e.Borrow(cdstAccessMask_allocs)

	x.ref977c944e = ref977c944e
	x.allocs977c944e = allocs977c944e
	return ref977c944e, allocs977c944e

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x MemoryBarrier) PassValue() (C.VkMemoryBarrier, *cgoAllocMap) {
	if x.ref977c944e != nil {
		return *x.ref977c944e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *MemoryBarrier) Deref() {
	if x.ref977c944e == nil {
		return
	}
	x.SType = (StructureType)(x.ref977c944e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref977c944e.pNext))
	x.SrcAccessMask = (AccessFlags)(x.ref977c944e.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.ref977c944e.dstAccessMask)
}

// allocBufferMemoryBarrierMemory allocates memory for type C.VkBufferMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferMemoryBarrierValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferMemoryBarrierValue = unsafe.Sizeof([1]C.VkBufferMemoryBarrier{})

// Ref returns a reference.
func (x *BufferMemoryBarrier) Ref() *C.VkBufferMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.refeaf4700b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *BufferMemoryBarrier) Free() {
	if x != nil && x.allocseaf4700b != nil {
		x.allocseaf4700b.(*cgoAllocMap).Free()
		x.refeaf4700b = nil
	}
}

// NewBufferMemoryBarrierRef initialises a new struct holding the reference to the originaitng C struct.
func NewBufferMemoryBarrierRef(ref interface{}) *BufferMemoryBarrier {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(BufferMemoryBarrier)
	obj.refeaf4700b = (*C.VkBufferMemoryBarrier)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *BufferMemoryBarrier) PassRef() (*C.VkBufferMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeaf4700b != nil {
		return x.refeaf4700b, nil
	}
	memeaf4700b := allocBufferMemoryBarrierMemory(1)
	refeaf4700b := (*C.VkBufferMemoryBarrier)(memeaf4700b)
	allocseaf4700b := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refeaf4700b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseaf4700b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeaf4700b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseaf4700b.Borrow(cpNext_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refeaf4700b.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocseaf4700b.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refeaf4700b.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocseaf4700b.Borrow(cdstAccessMask_allocs)

	var csrcQueueFamilyIndex_allocs *cgoAllocMap
	refeaf4700b.srcQueueFamilyIndex, csrcQueueFamilyIndex_allocs = (C.uint32_t)(x.SrcQueueFamilyIndex), cgoAllocsUnknown
	allocseaf4700b.Borrow(csrcQueueFamilyIndex_allocs)

	var cdstQueueFamilyIndex_allocs *cgoAllocMap
	refeaf4700b.dstQueueFamilyIndex, cdstQueueFamilyIndex_allocs = (C.uint32_t)(x.DstQueueFamilyIndex), cgoAllocsUnknown
	allocseaf4700b.Borrow(cdstQueueFamilyIndex_allocs)

	var cbuffer_allocs *cgoAllocMap
	refeaf4700b.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocseaf4700b.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	refeaf4700b.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocseaf4700b.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	refeaf4700b.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocseaf4700b.Borrow(csize_allocs)

	x.refeaf4700b = refeaf4700b
	x.allocseaf4700b = allocseaf4700b
	return refeaf4700b, allocseaf4700b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x BufferMemoryBarrier) PassValue() (C.VkBufferMemoryBarrier, *cgoAllocMap) {
	if x.refeaf4700b != nil {
		return *x.refeaf4700b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *BufferMemoryBarrier) Deref() {
	if x.refeaf4700b == nil {
		return
	}
	x.SType = (StructureType)(x.refeaf4700b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeaf4700b.pNext))
	x.SrcAccessMask = (AccessFlags)(x.refeaf4700b.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refeaf4700b.dstAccessMask)
	x.SrcQueueFamilyIndex = (uint32)(x.refeaf4700b.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.refeaf4700b.dstQueueFamilyIndex)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refeaf4700b.buffer))
	x.Offset = (DeviceSize)(x.refeaf4700b.offset)
	x.Size = (DeviceSize)(x.refeaf4700b.size)
}

// allocImageMemoryBarrierMemory allocates memory for type C.VkImageMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageMemoryBarrierValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageMemoryBarrierValue = unsafe.Sizeof([1]C.VkImageMemoryBarrier{})

// Ref returns a reference.
func (x *ImageMemoryBarrier) Ref() *C.VkImageMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.refd52734ec
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageMemoryBarrier) Free() {
	if x != nil && x.allocsd52734ec != nil {
		x.allocsd52734ec.(*cgoAllocMap).Free()
		x.refd52734ec = nil
	}
}

// NewImageMemoryBarrierRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageMemoryBarrierRef(ref interface{}) *ImageMemoryBarrier {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(ImageMemoryBarrier)
	obj.refd52734ec = (*C.VkImageMemoryBarrier)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageMemoryBarrier) PassRef() (*C.VkImageMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd52734ec != nil {
		return x.refd52734ec, nil
	}
	memd52734ec := allocImageMemoryBarrierMemory(1)
	refd52734ec := (*C.VkImageMemoryBarrier)(memd52734ec)
	allocsd52734ec := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refd52734ec.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd52734ec.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd52734ec.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd52734ec.Borrow(cpNext_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refd52734ec.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocsd52734ec.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refd52734ec.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocsd52734ec.Borrow(cdstAccessMask_allocs)

	var coldLayout_allocs *cgoAllocMap
	refd52734ec.oldLayout, coldLayout_allocs = (C.VkImageLayout)(x.OldLayout), cgoAllocsUnknown
	allocsd52734ec.Borrow(coldLayout_allocs)

	var cnewLayout_allocs *cgoAllocMap
	refd52734ec.newLayout, cnewLayout_allocs = (C.VkImageLayout)(x.NewLayout), cgoAllocsUnknown
	allocsd52734ec.Borrow(cnewLayout_allocs)

	var csrcQueueFamilyIndex_allocs *cgoAllocMap
	refd52734ec.srcQueueFamilyIndex, csrcQueueFamilyIndex_allocs = (C.uint32_t)(x.SrcQueueFamilyIndex), cgoAllocsUnknown
	allocsd52734ec.Borrow(csrcQueueFamilyIndex_allocs)

	var cdstQueueFamilyIndex_allocs *cgoAllocMap
	refd52734ec.dstQueueFamilyIndex, cdstQueueFamilyIndex_allocs = (C.uint32_t)(x.DstQueueFamilyIndex), cgoAllocsUnknown
	allocsd52734ec.Borrow(cdstQueueFamilyIndex_allocs)

	var cimage_allocs *cgoAllocMap
	refd52734ec.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocsd52734ec.Borrow(cimage_allocs)

	var csubresourceRange_allocs *cgoAllocMap
	refd52734ec.subresourceRange, csubresourceRange_allocs = x.SubresourceRange.PassValue()
	allocsd52734ec.Borrow(csubresourceRange_allocs)

	x.refd52734ec = refd52734ec
	x.allocsd52734ec = allocsd52734ec
	return refd52734ec, allocsd52734ec

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x ImageMemoryBarrier) PassValue() (C.VkImageMemoryBarrier, *cgoAllocMap) {
	if x.refd52734ec != nil {
		return *x.refd52734ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageMemoryBarrier) Deref() {
	if x.refd52734ec == nil {
		return
	}
	x.SType = (StructureType)(x.refd52734ec.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd52734ec.pNext))
	x.SrcAccessMask = (AccessFlags)(x.refd52734ec.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refd52734ec.dstAccessMask)
	x.OldLayout = (ImageLayout)(x.refd52734ec.oldLayout)
	x.NewLayout = (ImageLayout)(x.refd52734ec.newLayout)
	x.SrcQueueFamilyIndex = (uint32)(x.refd52734ec.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.refd52734ec.dstQueueFamilyIndex)
	x.Image = *(*Image)(unsafe.Pointer(&x.refd52734ec.image))
	x.SubresourceRange = *NewImageSubresourceRangeRef(&x.refd52734ec.subresourceRange)
}

// allocRenderPassBeginInfoMemory allocates memory for type C.VkRenderPassBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassBeginInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassBeginInfoValue = unsafe.Sizeof([1]C.VkRenderPassBeginInfo{})

// Ref returns a reference.
func (x *RenderPassBeginInfo) Ref() *C.VkRenderPassBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref3c3752c8
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *RenderPassBeginInfo) Free() {
	if x != nil && x.allocs3c3752c8 != nil {
		x.allocs3c3752c8.(*cgoAllocMap).Free()
		x.ref3c3752c8 = nil
	}
}

// NewRenderPassBeginInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewRenderPassBeginInfoRef(ref interface{}) *RenderPassBeginInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(RenderPassBeginInfo)
	obj.ref3c3752c8 = (*C.VkRenderPassBeginInfo)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *RenderPassBeginInfo) PassRef() (*C.VkRenderPassBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c3752c8 != nil {
		return x.ref3c3752c8, nil
	}
	mem3c3752c8 := allocRenderPassBeginInfoMemory(1)
	ref3c3752c8 := (*C.VkRenderPassBeginInfo)(mem3c3752c8)
	allocs3c3752c8 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref3c3752c8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3c3752c8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3c3752c8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cpNext_allocs)

	var crenderPass_allocs *cgoAllocMap
	ref3c3752c8.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(crenderPass_allocs)

	var cframebuffer_allocs *cgoAllocMap
	ref3c3752c8.framebuffer, cframebuffer_allocs = *(*C.VkFramebuffer)(unsafe.Pointer(&x.Framebuffer)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cframebuffer_allocs)

	var crenderArea_allocs *cgoAllocMap
	ref3c3752c8.renderArea, crenderArea_allocs = x.RenderArea.PassValue()
	allocs3c3752c8.Borrow(crenderArea_allocs)

	var cclearValueCount_allocs *cgoAllocMap
	ref3c3752c8.clearValueCount, cclearValueCount_allocs = (C.uint32_t)(x.ClearValueCount), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cclearValueCount_allocs)

	var cpClearValues_allocs *cgoAllocMap
	ref3c3752c8.pClearValues, cpClearValues_allocs = (*C.VkClearValue)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PClearValues)).Data)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cpClearValues_allocs)

	x.ref3c3752c8 = ref3c3752c8
	x.allocs3c3752c8 = allocs3c3752c8
	return ref3c3752c8, allocs3c3752c8

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x RenderPassBeginInfo) PassValue() (C.VkRenderPassBeginInfo, *cgoAllocMap) {
	if x.ref3c3752c8 != nil {
		return *x.ref3c3752c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *RenderPassBeginInfo) Deref() {
	if x.ref3c3752c8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3c3752c8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3c3752c8.pNext))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref3c3752c8.renderPass))
	x.Framebuffer = *(*Framebuffer)(unsafe.Pointer(&x.ref3c3752c8.framebuffer))
	x.RenderArea = *NewRect2DRef(&x.ref3c3752c8.renderArea)
	x.ClearValueCount = (uint32)(x.ref3c3752c8.clearValueCount)
	hxf1231c9 := (*sliceHeader)(unsafe.Pointer(&x.PClearValues))
	hxf1231c9.Data = uintptr(unsafe.Pointer(x.ref3c3752c8.pClearValues))
	hxf1231c9.Cap = 0x7fffffff
	// hxf1231c9.Len = ?

}

// allocDispatchIndirectCommandMemory allocates memory for type C.VkDispatchIndirectCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDispatchIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDispatchIndirectCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDispatchIndirectCommandValue = unsafe.Sizeof([1]C.VkDispatchIndirectCommand{})

// Ref returns a reference.
func (x *DispatchIndirectCommand) Ref() *C.VkDispatchIndirectCommand {
	if x == nil {
		return nil
	}
	return x.refd298ba27
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DispatchIndirectCommand) Free() {
	if x != nil && x.allocsd298ba27 != nil {
		x.allocsd298ba27.(*cgoAllocMap).Free()
		x.refd298ba27 = nil
	}
}

// NewDispatchIndirectCommandRef initialises a new struct holding the reference to the originaitng C struct.
func NewDispatchIndirectCommandRef(ref interface{}) *DispatchIndirectCommand {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DispatchIndirectCommand)
	obj.refd298ba27 = (*C.VkDispatchIndirectCommand)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DispatchIndirectCommand) PassRef() (*C.VkDispatchIndirectCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd298ba27 != nil {
		return x.refd298ba27, nil
	}
	memd298ba27 := allocDispatchIndirectCommandMemory(1)
	refd298ba27 := (*C.VkDispatchIndirectCommand)(memd298ba27)
	allocsd298ba27 := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	refd298ba27.x, cx_allocs = (C.uint32_t)(x.X), cgoAllocsUnknown
	allocsd298ba27.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refd298ba27.y, cy_allocs = (C.uint32_t)(x.Y), cgoAllocsUnknown
	allocsd298ba27.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	refd298ba27.z, cz_allocs = (C.uint32_t)(x.Z), cgoAllocsUnknown
	allocsd298ba27.Borrow(cz_allocs)

	x.refd298ba27 = refd298ba27
	x.allocsd298ba27 = allocsd298ba27
	return refd298ba27, allocsd298ba27

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DispatchIndirectCommand) PassValue() (C.VkDispatchIndirectCommand, *cgoAllocMap) {
	if x.refd298ba27 != nil {
		return *x.refd298ba27, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DispatchIndirectCommand) Deref() {
	if x.refd298ba27 == nil {
		return
	}
	x.X = (uint32)(x.refd298ba27.x)
	x.Y = (uint32)(x.refd298ba27.y)
	x.Z = (uint32)(x.refd298ba27.z)
}

// allocDrawIndexedIndirectCommandMemory allocates memory for type C.VkDrawIndexedIndirectCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrawIndexedIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrawIndexedIndirectCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDrawIndexedIndirectCommandValue = unsafe.Sizeof([1]C.VkDrawIndexedIndirectCommand{})

// Ref returns a reference.
func (x *DrawIndexedIndirectCommand) Ref() *C.VkDrawIndexedIndirectCommand {
	if x == nil {
		return nil
	}
	return x.ref4c78b5c3
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DrawIndexedIndirectCommand) Free() {
	if x != nil && x.allocs4c78b5c3 != nil {
		x.allocs4c78b5c3.(*cgoAllocMap).Free()
		x.ref4c78b5c3 = nil
	}
}

// NewDrawIndexedIndirectCommandRef initialises a new struct holding the reference to the originaitng C struct.
func NewDrawIndexedIndirectCommandRef(ref interface{}) *DrawIndexedIndirectCommand {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DrawIndexedIndirectCommand)
	obj.ref4c78b5c3 = (*C.VkDrawIndexedIndirectCommand)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DrawIndexedIndirectCommand) PassRef() (*C.VkDrawIndexedIndirectCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4c78b5c3 != nil {
		return x.ref4c78b5c3, nil
	}
	mem4c78b5c3 := allocDrawIndexedIndirectCommandMemory(1)
	ref4c78b5c3 := (*C.VkDrawIndexedIndirectCommand)(mem4c78b5c3)
	allocs4c78b5c3 := new(cgoAllocMap)
	var cindexCount_allocs *cgoAllocMap
	ref4c78b5c3.indexCount, cindexCount_allocs = (C.uint32_t)(x.IndexCount), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cindexCount_allocs)

	var cinstanceCount_allocs *cgoAllocMap
	ref4c78b5c3.instanceCount, cinstanceCount_allocs = (C.uint32_t)(x.InstanceCount), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cinstanceCount_allocs)

	var cfirstIndex_allocs *cgoAllocMap
	ref4c78b5c3.firstIndex, cfirstIndex_allocs = (C.uint32_t)(x.FirstIndex), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cfirstIndex_allocs)

	var cvertexOffset_allocs *cgoAllocMap
	ref4c78b5c3.vertexOffset, cvertexOffset_allocs = (C.int32_t)(x.VertexOffset), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cvertexOffset_allocs)

	var cfirstInstance_allocs *cgoAllocMap
	ref4c78b5c3.firstInstance, cfirstInstance_allocs = (C.uint32_t)(x.FirstInstance), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cfirstInstance_allocs)

	x.ref4c78b5c3 = ref4c78b5c3
	x.allocs4c78b5c3 = allocs4c78b5c3
	return ref4c78b5c3, allocs4c78b5c3

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DrawIndexedIndirectCommand) PassValue() (C.VkDrawIndexedIndirectCommand, *cgoAllocMap) {
	if x.ref4c78b5c3 != nil {
		return *x.ref4c78b5c3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DrawIndexedIndirectCommand) Deref() {
	if x.ref4c78b5c3 == nil {
		return
	}
	x.IndexCount = (uint32)(x.ref4c78b5c3.indexCount)
	x.InstanceCount = (uint32)(x.ref4c78b5c3.instanceCount)
	x.FirstIndex = (uint32)(x.ref4c78b5c3.firstIndex)
	x.VertexOffset = (int32)(x.ref4c78b5c3.vertexOffset)
	x.FirstInstance = (uint32)(x.ref4c78b5c3.firstInstance)
}

// allocDrawIndirectCommandMemory allocates memory for type C.VkDrawIndirectCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrawIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrawIndirectCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDrawIndirectCommandValue = unsafe.Sizeof([1]C.VkDrawIndirectCommand{})

// Ref returns a reference.
func (x *DrawIndirectCommand) Ref() *C.VkDrawIndirectCommand {
	if x == nil {
		return nil
	}
	return x.ref2b5b67c4
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DrawIndirectCommand) Free() {
	if x != nil && x.allocs2b5b67c4 != nil {
		x.allocs2b5b67c4.(*cgoAllocMap).Free()
		x.ref2b5b67c4 = nil
	}
}

// NewDrawIndirectCommandRef initialises a new struct holding the reference to the originaitng C struct.
func NewDrawIndirectCommandRef(ref interface{}) *DrawIndirectCommand {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DrawIndirectCommand)
	obj.ref2b5b67c4 = (*C.VkDrawIndirectCommand)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DrawIndirectCommand) PassRef() (*C.VkDrawIndirectCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2b5b67c4 != nil {
		return x.ref2b5b67c4, nil
	}
	mem2b5b67c4 := allocDrawIndirectCommandMemory(1)
	ref2b5b67c4 := (*C.VkDrawIndirectCommand)(mem2b5b67c4)
	allocs2b5b67c4 := new(cgoAllocMap)
	var cvertexCount_allocs *cgoAllocMap
	ref2b5b67c4.vertexCount, cvertexCount_allocs = (C.uint32_t)(x.VertexCount), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cvertexCount_allocs)

	var cinstanceCount_allocs *cgoAllocMap
	ref2b5b67c4.instanceCount, cinstanceCount_allocs = (C.uint32_t)(x.InstanceCount), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cinstanceCount_allocs)

	var cfirstVertex_allocs *cgoAllocMap
	ref2b5b67c4.firstVertex, cfirstVertex_allocs = (C.uint32_t)(x.FirstVertex), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cfirstVertex_allocs)

	var cfirstInstance_allocs *cgoAllocMap
	ref2b5b67c4.firstInstance, cfirstInstance_allocs = (C.uint32_t)(x.FirstInstance), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cfirstInstance_allocs)

	x.ref2b5b67c4 = ref2b5b67c4
	x.allocs2b5b67c4 = allocs2b5b67c4
	return ref2b5b67c4, allocs2b5b67c4

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DrawIndirectCommand) PassValue() (C.VkDrawIndirectCommand, *cgoAllocMap) {
	if x.ref2b5b67c4 != nil {
		return *x.ref2b5b67c4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DrawIndirectCommand) Deref() {
	if x.ref2b5b67c4 == nil {
		return
	}
	x.VertexCount = (uint32)(x.ref2b5b67c4.vertexCount)
	x.InstanceCount = (uint32)(x.ref2b5b67c4.instanceCount)
	x.FirstVertex = (uint32)(x.ref2b5b67c4.firstVertex)
	x.FirstInstance = (uint32)(x.ref2b5b67c4.firstInstance)
}

// allocSurfaceCapabilitiesMemory allocates memory for type C.VkSurfaceCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceCapabilitiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSurfaceCapabilitiesValue = unsafe.Sizeof([1]C.VkSurfaceCapabilitiesKHR{})

// Ref returns a reference.
func (x *SurfaceCapabilities) Ref() *C.VkSurfaceCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.ref11d5f596
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SurfaceCapabilities) Free() {
	if x != nil && x.allocs11d5f596 != nil {
		x.allocs11d5f596.(*cgoAllocMap).Free()
		x.ref11d5f596 = nil
	}
}

// NewSurfaceCapabilitiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewSurfaceCapabilitiesRef(ref interface{}) *SurfaceCapabilities {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SurfaceCapabilities)
	obj.ref11d5f596 = (*C.VkSurfaceCapabilitiesKHR)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SurfaceCapabilities) PassRef() (*C.VkSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11d5f596 != nil {
		return x.ref11d5f596, nil
	}
	mem11d5f596 := allocSurfaceCapabilitiesMemory(1)
	ref11d5f596 := (*C.VkSurfaceCapabilitiesKHR)(mem11d5f596)
	allocs11d5f596 := new(cgoAllocMap)
	var cminImageCount_allocs *cgoAllocMap
	ref11d5f596.minImageCount, cminImageCount_allocs = (C.uint32_t)(x.MinImageCount), cgoAllocsUnknown
	allocs11d5f596.Borrow(cminImageCount_allocs)

	var cmaxImageCount_allocs *cgoAllocMap
	ref11d5f596.maxImageCount, cmaxImageCount_allocs = (C.uint32_t)(x.MaxImageCount), cgoAllocsUnknown
	allocs11d5f596.Borrow(cmaxImageCount_allocs)

	var ccurrentExtent_allocs *cgoAllocMap
	ref11d5f596.currentExtent, ccurrentExtent_allocs = x.CurrentExtent.PassValue()
	allocs11d5f596.Borrow(ccurrentExtent_allocs)

	var cminImageExtent_allocs *cgoAllocMap
	ref11d5f596.minImageExtent, cminImageExtent_allocs = x.MinImageExtent.PassValue()
	allocs11d5f596.Borrow(cminImageExtent_allocs)

	var cmaxImageExtent_allocs *cgoAllocMap
	ref11d5f596.maxImageExtent, cmaxImageExtent_allocs = x.MaxImageExtent.PassValue()
	allocs11d5f596.Borrow(cmaxImageExtent_allocs)

	var cmaxImageArrayLayers_allocs *cgoAllocMap
	ref11d5f596.maxImageArrayLayers, cmaxImageArrayLayers_allocs = (C.uint32_t)(x.MaxImageArrayLayers), cgoAllocsUnknown
	allocs11d5f596.Borrow(cmaxImageArrayLayers_allocs)

	var csupportedTransforms_allocs *cgoAllocMap
	ref11d5f596.supportedTransforms, csupportedTransforms_allocs = (C.VkSurfaceTransformFlagsKHR)(x.SupportedTransforms), cgoAllocsUnknown
	allocs11d5f596.Borrow(csupportedTransforms_allocs)

	var ccurrentTransform_allocs *cgoAllocMap
	ref11d5f596.currentTransform, ccurrentTransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.CurrentTransform), cgoAllocsUnknown
	allocs11d5f596.Borrow(ccurrentTransform_allocs)

	var csupportedCompositeAlpha_allocs *cgoAllocMap
	ref11d5f596.supportedCompositeAlpha, csupportedCompositeAlpha_allocs = (C.VkCompositeAlphaFlagsKHR)(x.SupportedCompositeAlpha), cgoAllocsUnknown
	allocs11d5f596.Borrow(csupportedCompositeAlpha_allocs)

	var csupportedUsageFlags_allocs *cgoAllocMap
	ref11d5f596.supportedUsageFlags, csupportedUsageFlags_allocs = (C.VkImageUsageFlags)(x.SupportedUsageFlags), cgoAllocsUnknown
	allocs11d5f596.Borrow(csupportedUsageFlags_allocs)

	x.ref11d5f596 = ref11d5f596
	x.allocs11d5f596 = allocs11d5f596
	return ref11d5f596, allocs11d5f596

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SurfaceCapabilities) PassValue() (C.VkSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x.ref11d5f596 != nil {
		return *x.ref11d5f596, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SurfaceCapabilities) Deref() {
	if x.ref11d5f596 == nil {
		return
	}
	x.MinImageCount = (uint32)(x.ref11d5f596.minImageCount)
	x.MaxImageCount = (uint32)(x.ref11d5f596.maxImageCount)
	x.CurrentExtent = *NewExtent2DRef(&x.ref11d5f596.currentExtent)
	x.MinImageExtent = *NewExtent2DRef(&x.ref11d5f596.minImageExtent)
	x.MaxImageExtent = *NewExtent2DRef(&x.ref11d5f596.maxImageExtent)
	x.MaxImageArrayLayers = (uint32)(x.ref11d5f596.maxImageArrayLayers)
	x.SupportedTransforms = (SurfaceTransformFlags)(x.ref11d5f596.supportedTransforms)
	x.CurrentTransform = (SurfaceTransformFlagBits)(x.ref11d5f596.currentTransform)
	x.SupportedCompositeAlpha = (CompositeAlphaFlags)(x.ref11d5f596.supportedCompositeAlpha)
	x.SupportedUsageFlags = (ImageUsageFlags)(x.ref11d5f596.supportedUsageFlags)
}

// allocSurfaceFormatMemory allocates memory for type C.VkSurfaceFormatKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceFormatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceFormatValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSurfaceFormatValue = unsafe.Sizeof([1]C.VkSurfaceFormatKHR{})

// Ref returns a reference.
func (x *SurfaceFormat) Ref() *C.VkSurfaceFormatKHR {
	if x == nil {
		return nil
	}
	return x.refedaf82ca
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SurfaceFormat) Free() {
	if x != nil && x.allocsedaf82ca != nil {
		x.allocsedaf82ca.(*cgoAllocMap).Free()
		x.refedaf82ca = nil
	}
}

// NewSurfaceFormatRef initialises a new struct holding the reference to the originaitng C struct.
func NewSurfaceFormatRef(ref interface{}) *SurfaceFormat {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SurfaceFormat)
	obj.refedaf82ca = (*C.VkSurfaceFormatKHR)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SurfaceFormat) PassRef() (*C.VkSurfaceFormatKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refedaf82ca != nil {
		return x.refedaf82ca, nil
	}
	memedaf82ca := allocSurfaceFormatMemory(1)
	refedaf82ca := (*C.VkSurfaceFormatKHR)(memedaf82ca)
	allocsedaf82ca := new(cgoAllocMap)
	var cformat_allocs *cgoAllocMap
	refedaf82ca.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsedaf82ca.Borrow(cformat_allocs)

	var ccolorSpace_allocs *cgoAllocMap
	refedaf82ca.colorSpace, ccolorSpace_allocs = (C.VkColorSpaceKHR)(x.ColorSpace), cgoAllocsUnknown
	allocsedaf82ca.Borrow(ccolorSpace_allocs)

	x.refedaf82ca = refedaf82ca
	x.allocsedaf82ca = allocsedaf82ca
	return refedaf82ca, allocsedaf82ca

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SurfaceFormat) PassValue() (C.VkSurfaceFormatKHR, *cgoAllocMap) {
	if x.refedaf82ca != nil {
		return *x.refedaf82ca, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SurfaceFormat) Deref() {
	if x.refedaf82ca == nil {
		return
	}
	x.Format = (Format)(x.refedaf82ca.format)
	x.ColorSpace = (ColorSpace)(x.refedaf82ca.colorSpace)
}

// allocSwapchainCreateInfoMemory allocates memory for type C.VkSwapchainCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSwapchainCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSwapchainCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSwapchainCreateInfoValue = unsafe.Sizeof([1]C.VkSwapchainCreateInfoKHR{})

// Ref returns a reference.
func (x *SwapchainCreateInfo) Ref() *C.VkSwapchainCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.refdb619e1c
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SwapchainCreateInfo) Free() {
	if x != nil && x.allocsdb619e1c != nil {
		x.allocsdb619e1c.(*cgoAllocMap).Free()
		x.refdb619e1c = nil
	}
}

// NewSwapchainCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewSwapchainCreateInfoRef(ref interface{}) *SwapchainCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(SwapchainCreateInfo)
	obj.refdb619e1c = (*C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SwapchainCreateInfo) PassRef() (*C.VkSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb619e1c != nil {
		return x.refdb619e1c, nil
	}
	memdb619e1c := allocSwapchainCreateInfoMemory(1)
	refdb619e1c := (*C.VkSwapchainCreateInfoKHR)(memdb619e1c)
	allocsdb619e1c := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refdb619e1c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdb619e1c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdb619e1c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refdb619e1c.flags, cflags_allocs = (C.VkSwapchainCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cflags_allocs)

	var csurface_allocs *cgoAllocMap
	refdb619e1c.surface, csurface_allocs = *(*C.VkSurfaceKHR)(unsafe.Pointer(&x.Surface)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(csurface_allocs)

	var cminImageCount_allocs *cgoAllocMap
	refdb619e1c.minImageCount, cminImageCount_allocs = (C.uint32_t)(x.MinImageCount), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cminImageCount_allocs)

	var cimageFormat_allocs *cgoAllocMap
	refdb619e1c.imageFormat, cimageFormat_allocs = (C.VkFormat)(x.ImageFormat), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageFormat_allocs)

	var cimageColorSpace_allocs *cgoAllocMap
	refdb619e1c.imageColorSpace, cimageColorSpace_allocs = (C.VkColorSpaceKHR)(x.ImageColorSpace), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageColorSpace_allocs)

	var cimageExtent_allocs *cgoAllocMap
	refdb619e1c.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocsdb619e1c.Borrow(cimageExtent_allocs)

	var cimageArrayLayers_allocs *cgoAllocMap
	refdb619e1c.imageArrayLayers, cimageArrayLayers_allocs = (C.uint32_t)(x.ImageArrayLayers), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageArrayLayers_allocs)

	var cimageUsage_allocs *cgoAllocMap
	refdb619e1c.imageUsage, cimageUsage_allocs = (C.VkImageUsageFlags)(x.ImageUsage), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageUsage_allocs)

	var cimageSharingMode_allocs *cgoAllocMap
	refdb619e1c.imageSharingMode, cimageSharingMode_allocs = (C.VkSharingMode)(x.ImageSharingMode), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageSharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	refdb619e1c.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	refdb619e1c.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)).Data)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpQueueFamilyIndices_allocs)

	var cpreTransform_allocs *cgoAllocMap
	refdb619e1c.preTransform, cpreTransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.PreTransform), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpreTransform_allocs)

	var ccompositeAlpha_allocs *cgoAllocMap
	refdb619e1c.compositeAlpha, ccompositeAlpha_allocs = (C.VkCompositeAlphaFlagBitsKHR)(x.CompositeAlpha), cgoAllocsUnknown
	allocsdb619e1c.Borrow(ccompositeAlpha_allocs)

	var cpresentMode_allocs *cgoAllocMap
	refdb619e1c.presentMode, cpresentMode_allocs = (C.VkPresentModeKHR)(x.PresentMode), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpresentMode_allocs)

	var cclipped_allocs *cgoAllocMap
	refdb619e1c.clipped, cclipped_allocs = (C.VkBool32)(x.Clipped), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cclipped_allocs)

	var coldSwapchain_allocs *cgoAllocMap
	refdb619e1c.oldSwapchain, coldSwapchain_allocs = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.OldSwapchain)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(coldSwapchain_allocs)

	x.refdb619e1c = refdb619e1c
	x.allocsdb619e1c = allocsdb619e1c
	return refdb619e1c, allocsdb619e1c

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x SwapchainCreateInfo) PassValue() (C.VkSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x.refdb619e1c != nil {
		return *x.refdb619e1c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SwapchainCreateInfo) Deref() {
	if x.refdb619e1c == nil {
		return
	}
	x.SType = (StructureType)(x.refdb619e1c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdb619e1c.pNext))
	x.Flags = (SwapchainCreateFlags)(x.refdb619e1c.flags)
	x.Surface = *(*Surface)(unsafe.Pointer(&x.refdb619e1c.surface))
	x.MinImageCount = (uint32)(x.refdb619e1c.minImageCount)
	x.ImageFormat = (Format)(x.refdb619e1c.imageFormat)
	x.ImageColorSpace = (ColorSpace)(x.refdb619e1c.imageColorSpace)
	x.ImageExtent = *NewExtent2DRef(&x.refdb619e1c.imageExtent)
	x.ImageArrayLayers = (uint32)(x.refdb619e1c.imageArrayLayers)
	x.ImageUsage = (ImageUsageFlags)(x.refdb619e1c.imageUsage)
	x.ImageSharingMode = (SharingMode)(x.refdb619e1c.imageSharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.refdb619e1c.queueFamilyIndexCount)
	hxf04b15b := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf04b15b.Data = uintptr(unsafe.Pointer(x.refdb619e1c.pQueueFamilyIndices))
	hxf04b15b.Cap = 0x7fffffff
	// hxf04b15b.Len = ?

	x.PreTransform = (SurfaceTransformFlagBits)(x.refdb619e1c.preTransform)
	x.CompositeAlpha = (CompositeAlphaFlagBits)(x.refdb619e1c.compositeAlpha)
	x.PresentMode = (PresentMode)(x.refdb619e1c.presentMode)
	x.Clipped = (Bool32)(x.refdb619e1c.clipped)
	x.OldSwapchain = *(*Swapchain)(unsafe.Pointer(&x.refdb619e1c.oldSwapchain))
}

// allocPresentInfoMemory allocates memory for type C.VkPresentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPresentInfoValue = unsafe.Sizeof([1]C.VkPresentInfoKHR{})

// Ref returns a reference.
func (x *PresentInfo) Ref() *C.VkPresentInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref1d0e82d4
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PresentInfo) Free() {
	if x != nil && x.allocs1d0e82d4 != nil {
		x.allocs1d0e82d4.(*cgoAllocMap).Free()
		x.ref1d0e82d4 = nil
	}
}

// NewPresentInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewPresentInfoRef(ref interface{}) *PresentInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PresentInfo)
	obj.ref1d0e82d4 = (*C.VkPresentInfoKHR)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PresentInfo) PassRef() (*C.VkPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d0e82d4 != nil {
		return x.ref1d0e82d4, nil
	}
	mem1d0e82d4 := allocPresentInfoMemory(1)
	ref1d0e82d4 := (*C.VkPresentInfoKHR)(mem1d0e82d4)
	allocs1d0e82d4 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref1d0e82d4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1d0e82d4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	ref1d0e82d4.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphores_allocs *cgoAllocMap
	ref1d0e82d4.pWaitSemaphores, cpWaitSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpWaitSemaphores_allocs)

	var cswapchainCount_allocs *cgoAllocMap
	ref1d0e82d4.swapchainCount, cswapchainCount_allocs = (C.uint32_t)(x.SwapchainCount), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cswapchainCount_allocs)

	var cpSwapchains_allocs *cgoAllocMap
	ref1d0e82d4.pSwapchains, cpSwapchains_allocs = (*C.VkSwapchainKHR)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSwapchains)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpSwapchains_allocs)

	var cpImageIndices_allocs *cgoAllocMap
	ref1d0e82d4.pImageIndices, cpImageIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PImageIndices)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpImageIndices_allocs)

	var cpResults_allocs *cgoAllocMap
	ref1d0e82d4.pResults, cpResults_allocs = (*C.VkResult)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PResults)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpResults_allocs)

	x.ref1d0e82d4 = ref1d0e82d4
	x.allocs1d0e82d4 = allocs1d0e82d4
	return ref1d0e82d4, allocs1d0e82d4

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PresentInfo) PassValue() (C.VkPresentInfoKHR, *cgoAllocMap) {
	if x.ref1d0e82d4 != nil {
		return *x.ref1d0e82d4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PresentInfo) Deref() {
	if x.ref1d0e82d4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1d0e82d4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1d0e82d4.pNext))
	x.WaitSemaphoreCount = (uint32)(x.ref1d0e82d4.waitSemaphoreCount)
	hxf2f888b := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxf2f888b.Data = uintptr(unsafe.Pointer(x.ref1d0e82d4.pWaitSemaphores))
	hxf2f888b.Cap = 0x7fffffff
	// hxf2f888b.Len = ?

	x.SwapchainCount = (uint32)(x.ref1d0e82d4.swapchainCount)
	hxf5d1de2 := (*sliceHeader)(unsafe.Pointer(&x.PSwapchains))
	hxf5d1de2.Data = uintptr(unsafe.Pointer(x.ref1d0e82d4.pSwapchains))
	hxf5d1de2.Cap = 0x7fffffff
	// hxf5d1de2.Len = ?

	hxfe53d34 := (*sliceHeader)(unsafe.Pointer(&x.PImageIndices))
	hxfe53d34.Data = uintptr(unsafe.Pointer(x.ref1d0e82d4.pImageIndices))
	hxfe53d34.Cap = 0x7fffffff
	// hxfe53d34.Len = ?

	hxf547023 := (*sliceHeader)(unsafe.Pointer(&x.PResults))
	hxf547023.Data = uintptr(unsafe.Pointer(x.ref1d0e82d4.pResults))
	hxf547023.Cap = 0x7fffffff
	// hxf547023.Len = ?

}

// allocDisplayPropertiesMemory allocates memory for type C.VkDisplayPropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPropertiesValue = unsafe.Sizeof([1]C.VkDisplayPropertiesKHR{})

// Ref returns a reference.
func (x *DisplayProperties) Ref() *C.VkDisplayPropertiesKHR {
	if x == nil {
		return nil
	}
	return x.reffe2a7187
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplayProperties) Free() {
	if x != nil && x.allocsfe2a7187 != nil {
		x.allocsfe2a7187.(*cgoAllocMap).Free()
		x.reffe2a7187 = nil
	}
}

// NewDisplayPropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplayPropertiesRef(ref interface{}) *DisplayProperties {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DisplayProperties)
	obj.reffe2a7187 = (*C.VkDisplayPropertiesKHR)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplayProperties) PassRef() (*C.VkDisplayPropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe2a7187 != nil {
		return x.reffe2a7187, nil
	}
	memfe2a7187 := allocDisplayPropertiesMemory(1)
	reffe2a7187 := (*C.VkDisplayPropertiesKHR)(memfe2a7187)
	allocsfe2a7187 := new(cgoAllocMap)
	var cdisplay_allocs *cgoAllocMap
	reffe2a7187.display, cdisplay_allocs = *(*C.VkDisplayKHR)(unsafe.Pointer(&x.Display)), cgoAllocsUnknown
	allocsfe2a7187.Borrow(cdisplay_allocs)

	var cdisplayName_allocs *cgoAllocMap
	reffe2a7187.displayName, cdisplayName_allocs = unpackPCharString(x.DisplayName)
	allocsfe2a7187.Borrow(cdisplayName_allocs)

	var cphysicalDimensions_allocs *cgoAllocMap
	reffe2a7187.physicalDimensions, cphysicalDimensions_allocs = x.PhysicalDimensions.PassValue()
	allocsfe2a7187.Borrow(cphysicalDimensions_allocs)

	var cphysicalResolution_allocs *cgoAllocMap
	reffe2a7187.physicalResolution, cphysicalResolution_allocs = x.PhysicalResolution.PassValue()
	allocsfe2a7187.Borrow(cphysicalResolution_allocs)

	var csupportedTransforms_allocs *cgoAllocMap
	reffe2a7187.supportedTransforms, csupportedTransforms_allocs = (C.VkSurfaceTransformFlagsKHR)(x.SupportedTransforms), cgoAllocsUnknown
	allocsfe2a7187.Borrow(csupportedTransforms_allocs)

	var cplaneReorderPossible_allocs *cgoAllocMap
	reffe2a7187.planeReorderPossible, cplaneReorderPossible_allocs = (C.VkBool32)(x.PlaneReorderPossible), cgoAllocsUnknown
	allocsfe2a7187.Borrow(cplaneReorderPossible_allocs)

	var cpersistentContent_allocs *cgoAllocMap
	reffe2a7187.persistentContent, cpersistentContent_allocs = (C.VkBool32)(x.PersistentContent), cgoAllocsUnknown
	allocsfe2a7187.Borrow(cpersistentContent_allocs)

	x.reffe2a7187 = reffe2a7187
	x.allocsfe2a7187 = allocsfe2a7187
	return reffe2a7187, allocsfe2a7187

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DisplayProperties) PassValue() (C.VkDisplayPropertiesKHR, *cgoAllocMap) {
	if x.reffe2a7187 != nil {
		return *x.reffe2a7187, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplayProperties) Deref() {
	if x.reffe2a7187 == nil {
		return
	}
	x.Display = *(*Display)(unsafe.Pointer(&x.reffe2a7187.display))
	x.DisplayName = packPCharString(x.reffe2a7187.displayName)
	x.PhysicalDimensions = *NewExtent2DRef(&x.reffe2a7187.physicalDimensions)
	x.PhysicalResolution = *NewExtent2DRef(&x.reffe2a7187.physicalResolution)
	x.SupportedTransforms = (SurfaceTransformFlags)(x.reffe2a7187.supportedTransforms)
	x.PlaneReorderPossible = (Bool32)(x.reffe2a7187.planeReorderPossible)
	x.PersistentContent = (Bool32)(x.reffe2a7187.persistentContent)
}

// allocDisplayModeParametersMemory allocates memory for type C.VkDisplayModeParametersKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModeParametersMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModeParametersValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayModeParametersValue = unsafe.Sizeof([1]C.VkDisplayModeParametersKHR{})

// Ref returns a reference.
func (x *DisplayModeParameters) Ref() *C.VkDisplayModeParametersKHR {
	if x == nil {
		return nil
	}
	return x.refe016f77f
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplayModeParameters) Free() {
	if x != nil && x.allocse016f77f != nil {
		x.allocse016f77f.(*cgoAllocMap).Free()
		x.refe016f77f = nil
	}
}

// NewDisplayModeParametersRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplayModeParametersRef(ref interface{}) *DisplayModeParameters {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DisplayModeParameters)
	obj.refe016f77f = (*C.VkDisplayModeParametersKHR)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplayModeParameters) PassRef() (*C.VkDisplayModeParametersKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe016f77f != nil {
		return x.refe016f77f, nil
	}
	meme016f77f := allocDisplayModeParametersMemory(1)
	refe016f77f := (*C.VkDisplayModeParametersKHR)(meme016f77f)
	allocse016f77f := new(cgoAllocMap)
	var cvisibleRegion_allocs *cgoAllocMap
	refe016f77f.visibleRegion, cvisibleRegion_allocs = x.VisibleRegion.PassValue()
	allocse016f77f.Borrow(cvisibleRegion_allocs)

	var crefreshRate_allocs *cgoAllocMap
	refe016f77f.refreshRate, crefreshRate_allocs = (C.uint32_t)(x.RefreshRate), cgoAllocsUnknown
	allocse016f77f.Borrow(crefreshRate_allocs)

	x.refe016f77f = refe016f77f
	x.allocse016f77f = allocse016f77f
	return refe016f77f, allocse016f77f

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DisplayModeParameters) PassValue() (C.VkDisplayModeParametersKHR, *cgoAllocMap) {
	if x.refe016f77f != nil {
		return *x.refe016f77f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplayModeParameters) Deref() {
	if x.refe016f77f == nil {
		return
	}
	x.VisibleRegion = *NewExtent2DRef(&x.refe016f77f.visibleRegion)
	x.RefreshRate = (uint32)(x.refe016f77f.refreshRate)
}

// allocDisplayModePropertiesMemory allocates memory for type C.VkDisplayModePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayModePropertiesValue = unsafe.Sizeof([1]C.VkDisplayModePropertiesKHR{})

// Ref returns a reference.
func (x *DisplayModeProperties) Ref() *C.VkDisplayModePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref5e3abaaa
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplayModeProperties) Free() {
	if x != nil && x.allocs5e3abaaa != nil {
		x.allocs5e3abaaa.(*cgoAllocMap).Free()
		x.ref5e3abaaa = nil
	}
}

// NewDisplayModePropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplayModePropertiesRef(ref interface{}) *DisplayModeProperties {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DisplayModeProperties)
	obj.ref5e3abaaa = (*C.VkDisplayModePropertiesKHR)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplayModeProperties) PassRef() (*C.VkDisplayModePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e3abaaa != nil {
		return x.ref5e3abaaa, nil
	}
	mem5e3abaaa := allocDisplayModePropertiesMemory(1)
	ref5e3abaaa := (*C.VkDisplayModePropertiesKHR)(mem5e3abaaa)
	allocs5e3abaaa := new(cgoAllocMap)
	var cdisplayMode_allocs *cgoAllocMap
	ref5e3abaaa.displayMode, cdisplayMode_allocs = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.DisplayMode)), cgoAllocsUnknown
	allocs5e3abaaa.Borrow(cdisplayMode_allocs)

	var cparameters_allocs *cgoAllocMap
	ref5e3abaaa.parameters, cparameters_allocs = x.Parameters.PassValue()
	allocs5e3abaaa.Borrow(cparameters_allocs)

	x.ref5e3abaaa = ref5e3abaaa
	x.allocs5e3abaaa = allocs5e3abaaa
	return ref5e3abaaa, allocs5e3abaaa

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DisplayModeProperties) PassValue() (C.VkDisplayModePropertiesKHR, *cgoAllocMap) {
	if x.ref5e3abaaa != nil {
		return *x.ref5e3abaaa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplayModeProperties) Deref() {
	if x.ref5e3abaaa == nil {
		return
	}
	x.DisplayMode = *(*DisplayMode)(unsafe.Pointer(&x.ref5e3abaaa.displayMode))
	x.Parameters = *NewDisplayModeParametersRef(&x.ref5e3abaaa.parameters)
}

// allocDisplayModeCreateInfoMemory allocates memory for type C.VkDisplayModeCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModeCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModeCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayModeCreateInfoValue = unsafe.Sizeof([1]C.VkDisplayModeCreateInfoKHR{})

// Ref returns a reference.
func (x *DisplayModeCreateInfo) Ref() *C.VkDisplayModeCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref392fca31
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplayModeCreateInfo) Free() {
	if x != nil && x.allocs392fca31 != nil {
		x.allocs392fca31.(*cgoAllocMap).Free()
		x.ref392fca31 = nil
	}
}

// NewDisplayModeCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplayModeCreateInfoRef(ref interface{}) *DisplayModeCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DisplayModeCreateInfo)
	obj.ref392fca31 = (*C.VkDisplayModeCreateInfoKHR)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplayModeCreateInfo) PassRef() (*C.VkDisplayModeCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref392fca31 != nil {
		return x.ref392fca31, nil
	}
	mem392fca31 := allocDisplayModeCreateInfoMemory(1)
	ref392fca31 := (*C.VkDisplayModeCreateInfoKHR)(mem392fca31)
	allocs392fca31 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref392fca31.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs392fca31.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref392fca31.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs392fca31.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref392fca31.flags, cflags_allocs = (C.VkDisplayModeCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs392fca31.Borrow(cflags_allocs)

	var cparameters_allocs *cgoAllocMap
	ref392fca31.parameters, cparameters_allocs = x.Parameters.PassValue()
	allocs392fca31.Borrow(cparameters_allocs)

	x.ref392fca31 = ref392fca31
	x.allocs392fca31 = allocs392fca31
	return ref392fca31, allocs392fca31

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DisplayModeCreateInfo) PassValue() (C.VkDisplayModeCreateInfoKHR, *cgoAllocMap) {
	if x.ref392fca31 != nil {
		return *x.ref392fca31, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplayModeCreateInfo) Deref() {
	if x.ref392fca31 == nil {
		return
	}
	x.SType = (StructureType)(x.ref392fca31.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref392fca31.pNext))
	x.Flags = (DisplayModeCreateFlags)(x.ref392fca31.flags)
	x.Parameters = *NewDisplayModeParametersRef(&x.ref392fca31.parameters)
}

// allocDisplayPlaneCapabilitiesMemory allocates memory for type C.VkDisplayPlaneCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneCapabilitiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPlaneCapabilitiesValue = unsafe.Sizeof([1]C.VkDisplayPlaneCapabilitiesKHR{})

// Ref returns a reference.
func (x *DisplayPlaneCapabilities) Ref() *C.VkDisplayPlaneCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.ref6f31fcaf
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplayPlaneCapabilities) Free() {
	if x != nil && x.allocs6f31fcaf != nil {
		x.allocs6f31fcaf.(*cgoAllocMap).Free()
		x.ref6f31fcaf = nil
	}
}

// NewDisplayPlaneCapabilitiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplayPlaneCapabilitiesRef(ref interface{}) *DisplayPlaneCapabilities {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DisplayPlaneCapabilities)
	obj.ref6f31fcaf = (*C.VkDisplayPlaneCapabilitiesKHR)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplayPlaneCapabilities) PassRef() (*C.VkDisplayPlaneCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6f31fcaf != nil {
		return x.ref6f31fcaf, nil
	}
	mem6f31fcaf := allocDisplayPlaneCapabilitiesMemory(1)
	ref6f31fcaf := (*C.VkDisplayPlaneCapabilitiesKHR)(mem6f31fcaf)
	allocs6f31fcaf := new(cgoAllocMap)
	var csupportedAlpha_allocs *cgoAllocMap
	ref6f31fcaf.supportedAlpha, csupportedAlpha_allocs = (C.VkDisplayPlaneAlphaFlagsKHR)(x.SupportedAlpha), cgoAllocsUnknown
	allocs6f31fcaf.Borrow(csupportedAlpha_allocs)

	var cminSrcPosition_allocs *cgoAllocMap
	ref6f31fcaf.minSrcPosition, cminSrcPosition_allocs = x.MinSrcPosition.PassValue()
	allocs6f31fcaf.Borrow(cminSrcPosition_allocs)

	var cmaxSrcPosition_allocs *cgoAllocMap
	ref6f31fcaf.maxSrcPosition, cmaxSrcPosition_allocs = x.MaxSrcPosition.PassValue()
	allocs6f31fcaf.Borrow(cmaxSrcPosition_allocs)

	var cminSrcExtent_allocs *cgoAllocMap
	ref6f31fcaf.minSrcExtent, cminSrcExtent_allocs = x.MinSrcExtent.PassValue()
	allocs6f31fcaf.Borrow(cminSrcExtent_allocs)

	var cmaxSrcExtent_allocs *cgoAllocMap
	ref6f31fcaf.maxSrcExtent, cmaxSrcExtent_allocs = x.MaxSrcExtent.PassValue()
	allocs6f31fcaf.Borrow(cmaxSrcExtent_allocs)

	var cminDstPosition_allocs *cgoAllocMap
	ref6f31fcaf.minDstPosition, cminDstPosition_allocs = x.MinDstPosition.PassValue()
	allocs6f31fcaf.Borrow(cminDstPosition_allocs)

	var cmaxDstPosition_allocs *cgoAllocMap
	ref6f31fcaf.maxDstPosition, cmaxDstPosition_allocs = x.MaxDstPosition.PassValue()
	allocs6f31fcaf.Borrow(cmaxDstPosition_allocs)

	var cminDstExtent_allocs *cgoAllocMap
	ref6f31fcaf.minDstExtent, cminDstExtent_allocs = x.MinDstExtent.PassValue()
	allocs6f31fcaf.Borrow(cminDstExtent_allocs)

	var cmaxDstExtent_allocs *cgoAllocMap
	ref6f31fcaf.maxDstExtent, cmaxDstExtent_allocs = x.MaxDstExtent.PassValue()
	allocs6f31fcaf.Borrow(cmaxDstExtent_allocs)

	x.ref6f31fcaf = ref6f31fcaf
	x.allocs6f31fcaf = allocs6f31fcaf
	return ref6f31fcaf, allocs6f31fcaf

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DisplayPlaneCapabilities) PassValue() (C.VkDisplayPlaneCapabilitiesKHR, *cgoAllocMap) {
	if x.ref6f31fcaf != nil {
		return *x.ref6f31fcaf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplayPlaneCapabilities) Deref() {
	if x.ref6f31fcaf == nil {
		return
	}
	x.SupportedAlpha = (DisplayPlaneAlphaFlags)(x.ref6f31fcaf.supportedAlpha)
	x.MinSrcPosition = *NewOffset2DRef(&x.ref6f31fcaf.minSrcPosition)
	x.MaxSrcPosition = *NewOffset2DRef(&x.ref6f31fcaf.maxSrcPosition)
	x.MinSrcExtent = *NewExtent2DRef(&x.ref6f31fcaf.minSrcExtent)
	x.MaxSrcExtent = *NewExtent2DRef(&x.ref6f31fcaf.maxSrcExtent)
	x.MinDstPosition = *NewOffset2DRef(&x.ref6f31fcaf.minDstPosition)
	x.MaxDstPosition = *NewOffset2DRef(&x.ref6f31fcaf.maxDstPosition)
	x.MinDstExtent = *NewExtent2DRef(&x.ref6f31fcaf.minDstExtent)
	x.MaxDstExtent = *NewExtent2DRef(&x.ref6f31fcaf.maxDstExtent)
}

// allocDisplayPlanePropertiesMemory allocates memory for type C.VkDisplayPlanePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlanePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlanePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPlanePropertiesValue = unsafe.Sizeof([1]C.VkDisplayPlanePropertiesKHR{})

// Ref returns a reference.
func (x *DisplayPlaneProperties) Ref() *C.VkDisplayPlanePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.refce3db3f6
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplayPlaneProperties) Free() {
	if x != nil && x.allocsce3db3f6 != nil {
		x.allocsce3db3f6.(*cgoAllocMap).Free()
		x.refce3db3f6 = nil
	}
}

// NewDisplayPlanePropertiesRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplayPlanePropertiesRef(ref interface{}) *DisplayPlaneProperties {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DisplayPlaneProperties)
	obj.refce3db3f6 = (*C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplayPlaneProperties) PassRef() (*C.VkDisplayPlanePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refce3db3f6 != nil {
		return x.refce3db3f6, nil
	}
	memce3db3f6 := allocDisplayPlanePropertiesMemory(1)
	refce3db3f6 := (*C.VkDisplayPlanePropertiesKHR)(memce3db3f6)
	allocsce3db3f6 := new(cgoAllocMap)
	var ccurrentDisplay_allocs *cgoAllocMap
	refce3db3f6.currentDisplay, ccurrentDisplay_allocs = *(*C.VkDisplayKHR)(unsafe.Pointer(&x.CurrentDisplay)), cgoAllocsUnknown
	allocsce3db3f6.Borrow(ccurrentDisplay_allocs)

	var ccurrentStackIndex_allocs *cgoAllocMap
	refce3db3f6.currentStackIndex, ccurrentStackIndex_allocs = (C.uint32_t)(x.CurrentStackIndex), cgoAllocsUnknown
	allocsce3db3f6.Borrow(ccurrentStackIndex_allocs)

	x.refce3db3f6 = refce3db3f6
	x.allocsce3db3f6 = allocsce3db3f6
	return refce3db3f6, allocsce3db3f6

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DisplayPlaneProperties) PassValue() (C.VkDisplayPlanePropertiesKHR, *cgoAllocMap) {
	if x.refce3db3f6 != nil {
		return *x.refce3db3f6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplayPlaneProperties) Deref() {
	if x.refce3db3f6 == nil {
		return
	}
	x.CurrentDisplay = *(*Display)(unsafe.Pointer(&x.refce3db3f6.currentDisplay))
	x.CurrentStackIndex = (uint32)(x.refce3db3f6.currentStackIndex)
}

// allocDisplaySurfaceCreateInfoMemory allocates memory for type C.VkDisplaySurfaceCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplaySurfaceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplaySurfaceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplaySurfaceCreateInfoValue = unsafe.Sizeof([1]C.VkDisplaySurfaceCreateInfoKHR{})

// Ref returns a reference.
func (x *DisplaySurfaceCreateInfo) Ref() *C.VkDisplaySurfaceCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref58445c35
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplaySurfaceCreateInfo) Free() {
	if x != nil && x.allocs58445c35 != nil {
		x.allocs58445c35.(*cgoAllocMap).Free()
		x.ref58445c35 = nil
	}
}

// NewDisplaySurfaceCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplaySurfaceCreateInfoRef(ref interface{}) *DisplaySurfaceCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DisplaySurfaceCreateInfo)
	obj.ref58445c35 = (*C.VkDisplaySurfaceCreateInfoKHR)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplaySurfaceCreateInfo) PassRef() (*C.VkDisplaySurfaceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58445c35 != nil {
		return x.ref58445c35, nil
	}
	mem58445c35 := allocDisplaySurfaceCreateInfoMemory(1)
	ref58445c35 := (*C.VkDisplaySurfaceCreateInfoKHR)(mem58445c35)
	allocs58445c35 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref58445c35.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs58445c35.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref58445c35.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs58445c35.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref58445c35.flags, cflags_allocs = (C.VkDisplaySurfaceCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs58445c35.Borrow(cflags_allocs)

	var cdisplayMode_allocs *cgoAllocMap
	ref58445c35.displayMode, cdisplayMode_allocs = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.DisplayMode)), cgoAllocsUnknown
	allocs58445c35.Borrow(cdisplayMode_allocs)

	var cplaneIndex_allocs *cgoAllocMap
	ref58445c35.planeIndex, cplaneIndex_allocs = (C.uint32_t)(x.PlaneIndex), cgoAllocsUnknown
	allocs58445c35.Borrow(cplaneIndex_allocs)

	var cplaneStackIndex_allocs *cgoAllocMap
	ref58445c35.planeStackIndex, cplaneStackIndex_allocs = (C.uint32_t)(x.PlaneStackIndex), cgoAllocsUnknown
	allocs58445c35.Borrow(cplaneStackIndex_allocs)

	var ctransform_allocs *cgoAllocMap
	ref58445c35.transform, ctransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.Transform), cgoAllocsUnknown
	allocs58445c35.Borrow(ctransform_allocs)

	var cglobalAlpha_allocs *cgoAllocMap
	ref58445c35.globalAlpha, cglobalAlpha_allocs = (C.float)(x.GlobalAlpha), cgoAllocsUnknown
	allocs58445c35.Borrow(cglobalAlpha_allocs)

	var calphaMode_allocs *cgoAllocMap
	ref58445c35.alphaMode, calphaMode_allocs = (C.VkDisplayPlaneAlphaFlagBitsKHR)(x.AlphaMode), cgoAllocsUnknown
	allocs58445c35.Borrow(calphaMode_allocs)

	var cimageExtent_allocs *cgoAllocMap
	ref58445c35.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocs58445c35.Borrow(cimageExtent_allocs)

	x.ref58445c35 = ref58445c35
	x.allocs58445c35 = allocs58445c35
	return ref58445c35, allocs58445c35

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DisplaySurfaceCreateInfo) PassValue() (C.VkDisplaySurfaceCreateInfoKHR, *cgoAllocMap) {
	if x.ref58445c35 != nil {
		return *x.ref58445c35, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplaySurfaceCreateInfo) Deref() {
	if x.ref58445c35 == nil {
		return
	}
	x.SType = (StructureType)(x.ref58445c35.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref58445c35.pNext))
	x.Flags = (DisplaySurfaceCreateFlags)(x.ref58445c35.flags)
	x.DisplayMode = *(*DisplayMode)(unsafe.Pointer(&x.ref58445c35.displayMode))
	x.PlaneIndex = (uint32)(x.ref58445c35.planeIndex)
	x.PlaneStackIndex = (uint32)(x.ref58445c35.planeStackIndex)
	x.Transform = (SurfaceTransformFlagBits)(x.ref58445c35.transform)
	x.GlobalAlpha = (float32)(x.ref58445c35.globalAlpha)
	x.AlphaMode = (DisplayPlaneAlphaFlagBits)(x.ref58445c35.alphaMode)
	x.ImageExtent = *NewExtent2DRef(&x.ref58445c35.imageExtent)
}

// allocDisplayPresentInfoMemory allocates memory for type C.VkDisplayPresentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPresentInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPresentInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPresentInfoValue = unsafe.Sizeof([1]C.VkDisplayPresentInfoKHR{})

// Ref returns a reference.
func (x *DisplayPresentInfo) Ref() *C.VkDisplayPresentInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref8d2571e4
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DisplayPresentInfo) Free() {
	if x != nil && x.allocs8d2571e4 != nil {
		x.allocs8d2571e4.(*cgoAllocMap).Free()
		x.ref8d2571e4 = nil
	}
}

// NewDisplayPresentInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDisplayPresentInfoRef(ref interface{}) *DisplayPresentInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DisplayPresentInfo)
	obj.ref8d2571e4 = (*C.VkDisplayPresentInfoKHR)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DisplayPresentInfo) PassRef() (*C.VkDisplayPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8d2571e4 != nil {
		return x.ref8d2571e4, nil
	}
	mem8d2571e4 := allocDisplayPresentInfoMemory(1)
	ref8d2571e4 := (*C.VkDisplayPresentInfoKHR)(mem8d2571e4)
	allocs8d2571e4 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref8d2571e4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8d2571e4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8d2571e4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8d2571e4.Borrow(cpNext_allocs)

	var csrcRect_allocs *cgoAllocMap
	ref8d2571e4.srcRect, csrcRect_allocs = x.SrcRect.PassValue()
	allocs8d2571e4.Borrow(csrcRect_allocs)

	var cdstRect_allocs *cgoAllocMap
	ref8d2571e4.dstRect, cdstRect_allocs = x.DstRect.PassValue()
	allocs8d2571e4.Borrow(cdstRect_allocs)

	var cpersistent_allocs *cgoAllocMap
	ref8d2571e4.persistent, cpersistent_allocs = (C.VkBool32)(x.Persistent), cgoAllocsUnknown
	allocs8d2571e4.Borrow(cpersistent_allocs)

	x.ref8d2571e4 = ref8d2571e4
	x.allocs8d2571e4 = allocs8d2571e4
	return ref8d2571e4, allocs8d2571e4

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DisplayPresentInfo) PassValue() (C.VkDisplayPresentInfoKHR, *cgoAllocMap) {
	if x.ref8d2571e4 != nil {
		return *x.ref8d2571e4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DisplayPresentInfo) Deref() {
	if x.ref8d2571e4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8d2571e4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8d2571e4.pNext))
	x.SrcRect = *NewRect2DRef(&x.ref8d2571e4.srcRect)
	x.DstRect = *NewRect2DRef(&x.ref8d2571e4.dstRect)
	x.Persistent = (Bool32)(x.ref8d2571e4.persistent)
}

// allocAndroidSurfaceCreateInfoMemory allocates memory for type C.VkAndroidSurfaceCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAndroidSurfaceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAndroidSurfaceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAndroidSurfaceCreateInfoValue = unsafe.Sizeof([1]C.VkAndroidSurfaceCreateInfoKHR{})

// Ref returns a reference.
func (x *AndroidSurfaceCreateInfo) Ref() *C.VkAndroidSurfaceCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.refeca5c35c
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *AndroidSurfaceCreateInfo) Free() {
	if x != nil && x.allocseca5c35c != nil {
		x.allocseca5c35c.(*cgoAllocMap).Free()
		x.refeca5c35c = nil
	}
}

// NewAndroidSurfaceCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewAndroidSurfaceCreateInfoRef(ref interface{}) *AndroidSurfaceCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(AndroidSurfaceCreateInfo)
	obj.refeca5c35c = (*C.VkAndroidSurfaceCreateInfoKHR)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *AndroidSurfaceCreateInfo) PassRef() (*C.VkAndroidSurfaceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeca5c35c != nil {
		return x.refeca5c35c, nil
	}
	memeca5c35c := allocAndroidSurfaceCreateInfoMemory(1)
	refeca5c35c := (*C.VkAndroidSurfaceCreateInfoKHR)(memeca5c35c)
	allocseca5c35c := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refeca5c35c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseca5c35c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeca5c35c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseca5c35c.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refeca5c35c.flags, cflags_allocs = (C.VkAndroidSurfaceCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocseca5c35c.Borrow(cflags_allocs)

	var cwindow_allocs *cgoAllocMap
	refeca5c35c.window, cwindow_allocs = *(**C.ANativeWindow)(unsafe.Pointer(&x.Window)), cgoAllocsUnknown
	allocseca5c35c.Borrow(cwindow_allocs)

	x.refeca5c35c = refeca5c35c
	x.allocseca5c35c = allocseca5c35c
	return refeca5c35c, allocseca5c35c

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x AndroidSurfaceCreateInfo) PassValue() (C.VkAndroidSurfaceCreateInfoKHR, *cgoAllocMap) {
	if x.refeca5c35c != nil {
		return *x.refeca5c35c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *AndroidSurfaceCreateInfo) Deref() {
	if x.refeca5c35c == nil {
		return
	}
	x.SType = (StructureType)(x.refeca5c35c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeca5c35c.pNext))
	x.Flags = (AndroidSurfaceCreateFlags)(x.refeca5c35c.flags)
	x.Window = (*ANativeWindow)(unsafe.Pointer(x.refeca5c35c.window))
}

// PassRef returns a reference.
func (x DebugReportCallbackFunc) PassRef() (ref *C.PFN_vkDebugReportCallbackEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if debugReportCallbackFuncC918AAC4Func == nil {
		debugReportCallbackFuncC918AAC4Func = x
	}
	return (*C.PFN_vkDebugReportCallbackEXT)(C.PFN_vkDebugReportCallbackEXT_c918aac4), nil
}

// PassValue returns a value.
func (x DebugReportCallbackFunc) PassValue() (ref C.PFN_vkDebugReportCallbackEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if debugReportCallbackFuncC918AAC4Func == nil {
		debugReportCallbackFuncC918AAC4Func = x
	}
	return (C.PFN_vkDebugReportCallbackEXT)(C.PFN_vkDebugReportCallbackEXT_c918aac4), nil
}

//export debugReportCallbackFuncC918AAC4
func debugReportCallbackFuncC918AAC4(cflags C.VkDebugReportFlagsEXT, cobjectType C.VkDebugReportObjectTypeEXT, cobject C.uint64_t, clocation C.size_t, cmessageCode C.int32_t, cpLayerPrefix *C.char, cpMessage *C.char, cpUserData unsafe.Pointer) C.VkBool32 {
	if debugReportCallbackFuncC918AAC4Func != nil {
		flagsc918aac4 := (DebugReportFlags)(cflags)
		objectTypec918aac4 := (DebugReportObjectType)(cobjectType)
		objectc918aac4 := (uint64)(cobject)
		locationc918aac4 := (uint)(clocation)
		messageCodec918aac4 := (int32)(cmessageCode)
		pLayerPrefixc918aac4 := packPCharString(cpLayerPrefix)
		pMessagec918aac4 := packPCharString(cpMessage)
		pUserDatac918aac4 := (unsafe.Pointer)(unsafe.Pointer(cpUserData))
		retc918aac4 := debugReportCallbackFuncC918AAC4Func(flagsc918aac4, objectTypec918aac4, objectc918aac4, locationc918aac4, messageCodec918aac4, pLayerPrefixc918aac4, pMessagec918aac4, pUserDatac918aac4)
		ret, _ := (C.VkBool32)(retc918aac4), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var debugReportCallbackFuncC918AAC4Func DebugReportCallbackFunc

// allocDebugReportCallbackCreateInfoMemory allocates memory for type C.VkDebugReportCallbackCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugReportCallbackCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugReportCallbackCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugReportCallbackCreateInfoValue = unsafe.Sizeof([1]C.VkDebugReportCallbackCreateInfoEXT{})

// Ref returns a reference.
func (x *DebugReportCallbackCreateInfo) Ref() *C.VkDebugReportCallbackCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refc8238563
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DebugReportCallbackCreateInfo) Free() {
	if x != nil && x.allocsc8238563 != nil {
		x.allocsc8238563.(*cgoAllocMap).Free()
		x.refc8238563 = nil
	}
}

// NewDebugReportCallbackCreateInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDebugReportCallbackCreateInfoRef(ref interface{}) *DebugReportCallbackCreateInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DebugReportCallbackCreateInfo)
	obj.refc8238563 = (*C.VkDebugReportCallbackCreateInfoEXT)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DebugReportCallbackCreateInfo) PassRef() (*C.VkDebugReportCallbackCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc8238563 != nil {
		return x.refc8238563, nil
	}
	memc8238563 := allocDebugReportCallbackCreateInfoMemory(1)
	refc8238563 := (*C.VkDebugReportCallbackCreateInfoEXT)(memc8238563)
	allocsc8238563 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refc8238563.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc8238563.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc8238563.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc8238563.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc8238563.flags, cflags_allocs = (C.VkDebugReportFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocsc8238563.Borrow(cflags_allocs)

	var cpfnCallback_allocs *cgoAllocMap
	refc8238563.pfnCallback, cpfnCallback_allocs = x.PfnCallback.PassValue()
	allocsc8238563.Borrow(cpfnCallback_allocs)

	var cpUserData_allocs *cgoAllocMap
	refc8238563.pUserData, cpUserData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PUserData)), cgoAllocsUnknown
	allocsc8238563.Borrow(cpUserData_allocs)

	x.refc8238563 = refc8238563
	x.allocsc8238563 = allocsc8238563
	return refc8238563, allocsc8238563

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DebugReportCallbackCreateInfo) PassValue() (C.VkDebugReportCallbackCreateInfoEXT, *cgoAllocMap) {
	if x.refc8238563 != nil {
		return *x.refc8238563, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DebugReportCallbackCreateInfo) Deref() {
	if x.refc8238563 == nil {
		return
	}
	x.SType = (StructureType)(x.refc8238563.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc8238563.pNext))
	x.Flags = (DebugReportFlags)(x.refc8238563.flags)
	// x.PfnCallback is a callback func
	x.PUserData = (unsafe.Pointer)(unsafe.Pointer(x.refc8238563.pUserData))
}

// allocPipelineRasterizationStateRasterizationOrderAMDMemory allocates memory for type C.VkPipelineRasterizationStateRasterizationOrderAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationStateRasterizationOrderAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationStateRasterizationOrderAMDValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineRasterizationStateRasterizationOrderAMDValue = unsafe.Sizeof([1]C.VkPipelineRasterizationStateRasterizationOrderAMD{})

// Ref returns a reference.
func (x *PipelineRasterizationStateRasterizationOrderAMD) Ref() *C.VkPipelineRasterizationStateRasterizationOrderAMD {
	if x == nil {
		return nil
	}
	return x.ref5098cf82
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *PipelineRasterizationStateRasterizationOrderAMD) Free() {
	if x != nil && x.allocs5098cf82 != nil {
		x.allocs5098cf82.(*cgoAllocMap).Free()
		x.ref5098cf82 = nil
	}
}

// NewPipelineRasterizationStateRasterizationOrderAMDRef initialises a new struct holding the reference to the originaitng C struct.
func NewPipelineRasterizationStateRasterizationOrderAMDRef(ref interface{}) *PipelineRasterizationStateRasterizationOrderAMD {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(PipelineRasterizationStateRasterizationOrderAMD)
	obj.ref5098cf82 = (*C.VkPipelineRasterizationStateRasterizationOrderAMD)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *PipelineRasterizationStateRasterizationOrderAMD) PassRef() (*C.VkPipelineRasterizationStateRasterizationOrderAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5098cf82 != nil {
		return x.ref5098cf82, nil
	}
	mem5098cf82 := allocPipelineRasterizationStateRasterizationOrderAMDMemory(1)
	ref5098cf82 := (*C.VkPipelineRasterizationStateRasterizationOrderAMD)(mem5098cf82)
	allocs5098cf82 := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref5098cf82.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5098cf82.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5098cf82.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5098cf82.Borrow(cpNext_allocs)

	var crasterizationOrder_allocs *cgoAllocMap
	ref5098cf82.rasterizationOrder, crasterizationOrder_allocs = (C.VkRasterizationOrderAMD)(x.RasterizationOrder), cgoAllocsUnknown
	allocs5098cf82.Borrow(crasterizationOrder_allocs)

	x.ref5098cf82 = ref5098cf82
	x.allocs5098cf82 = allocs5098cf82
	return ref5098cf82, allocs5098cf82

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x PipelineRasterizationStateRasterizationOrderAMD) PassValue() (C.VkPipelineRasterizationStateRasterizationOrderAMD, *cgoAllocMap) {
	if x.ref5098cf82 != nil {
		return *x.ref5098cf82, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *PipelineRasterizationStateRasterizationOrderAMD) Deref() {
	if x.ref5098cf82 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5098cf82.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5098cf82.pNext))
	x.RasterizationOrder = (RasterizationOrderAMD)(x.ref5098cf82.rasterizationOrder)
}

// allocDebugMarkerObjectNameInfoMemory allocates memory for type C.VkDebugMarkerObjectNameInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerObjectNameInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerObjectNameInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugMarkerObjectNameInfoValue = unsafe.Sizeof([1]C.VkDebugMarkerObjectNameInfoEXT{})

// Ref returns a reference.
func (x *DebugMarkerObjectNameInfo) Ref() *C.VkDebugMarkerObjectNameInfoEXT {
	if x == nil {
		return nil
	}
	return x.refe4983fab
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DebugMarkerObjectNameInfo) Free() {
	if x != nil && x.allocse4983fab != nil {
		x.allocse4983fab.(*cgoAllocMap).Free()
		x.refe4983fab = nil
	}
}

// NewDebugMarkerObjectNameInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDebugMarkerObjectNameInfoRef(ref interface{}) *DebugMarkerObjectNameInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DebugMarkerObjectNameInfo)
	obj.refe4983fab = (*C.VkDebugMarkerObjectNameInfoEXT)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DebugMarkerObjectNameInfo) PassRef() (*C.VkDebugMarkerObjectNameInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe4983fab != nil {
		return x.refe4983fab, nil
	}
	meme4983fab := allocDebugMarkerObjectNameInfoMemory(1)
	refe4983fab := (*C.VkDebugMarkerObjectNameInfoEXT)(meme4983fab)
	allocse4983fab := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refe4983fab.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse4983fab.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe4983fab.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse4983fab.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	refe4983fab.objectType, cobjectType_allocs = (C.VkDebugReportObjectTypeEXT)(x.ObjectType), cgoAllocsUnknown
	allocse4983fab.Borrow(cobjectType_allocs)

	var cobject_allocs *cgoAllocMap
	refe4983fab.object, cobject_allocs = (C.uint64_t)(x.Object), cgoAllocsUnknown
	allocse4983fab.Borrow(cobject_allocs)

	var cpObjectName_allocs *cgoAllocMap
	refe4983fab.pObjectName, cpObjectName_allocs = unpackPCharString(x.PObjectName)
	allocse4983fab.Borrow(cpObjectName_allocs)

	x.refe4983fab = refe4983fab
	x.allocse4983fab = allocse4983fab
	return refe4983fab, allocse4983fab

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DebugMarkerObjectNameInfo) PassValue() (C.VkDebugMarkerObjectNameInfoEXT, *cgoAllocMap) {
	if x.refe4983fab != nil {
		return *x.refe4983fab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DebugMarkerObjectNameInfo) Deref() {
	if x.refe4983fab == nil {
		return
	}
	x.SType = (StructureType)(x.refe4983fab.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe4983fab.pNext))
	x.ObjectType = (DebugReportObjectType)(x.refe4983fab.objectType)
	x.Object = (uint64)(x.refe4983fab.object)
	x.PObjectName = packPCharString(x.refe4983fab.pObjectName)
}

// allocDebugMarkerObjectTagInfoMemory allocates memory for type C.VkDebugMarkerObjectTagInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerObjectTagInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerObjectTagInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugMarkerObjectTagInfoValue = unsafe.Sizeof([1]C.VkDebugMarkerObjectTagInfoEXT{})

// Ref returns a reference.
func (x *DebugMarkerObjectTagInfo) Ref() *C.VkDebugMarkerObjectTagInfoEXT {
	if x == nil {
		return nil
	}
	return x.refa41a5c3b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DebugMarkerObjectTagInfo) Free() {
	if x != nil && x.allocsa41a5c3b != nil {
		x.allocsa41a5c3b.(*cgoAllocMap).Free()
		x.refa41a5c3b = nil
	}
}

// NewDebugMarkerObjectTagInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDebugMarkerObjectTagInfoRef(ref interface{}) *DebugMarkerObjectTagInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DebugMarkerObjectTagInfo)
	obj.refa41a5c3b = (*C.VkDebugMarkerObjectTagInfoEXT)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DebugMarkerObjectTagInfo) PassRef() (*C.VkDebugMarkerObjectTagInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa41a5c3b != nil {
		return x.refa41a5c3b, nil
	}
	mema41a5c3b := allocDebugMarkerObjectTagInfoMemory(1)
	refa41a5c3b := (*C.VkDebugMarkerObjectTagInfoEXT)(mema41a5c3b)
	allocsa41a5c3b := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	refa41a5c3b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa41a5c3b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	refa41a5c3b.objectType, cobjectType_allocs = (C.VkDebugReportObjectTypeEXT)(x.ObjectType), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cobjectType_allocs)

	var cobject_allocs *cgoAllocMap
	refa41a5c3b.object, cobject_allocs = (C.uint64_t)(x.Object), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cobject_allocs)

	var ctagName_allocs *cgoAllocMap
	refa41a5c3b.tagName, ctagName_allocs = (C.uint64_t)(x.TagName), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(ctagName_allocs)

	var ctagSize_allocs *cgoAllocMap
	refa41a5c3b.tagSize, ctagSize_allocs = (C.size_t)(x.TagSize), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(ctagSize_allocs)

	var cpTag_allocs *cgoAllocMap
	refa41a5c3b.pTag, cpTag_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PTag)), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cpTag_allocs)

	x.refa41a5c3b = refa41a5c3b
	x.allocsa41a5c3b = allocsa41a5c3b
	return refa41a5c3b, allocsa41a5c3b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DebugMarkerObjectTagInfo) PassValue() (C.VkDebugMarkerObjectTagInfoEXT, *cgoAllocMap) {
	if x.refa41a5c3b != nil {
		return *x.refa41a5c3b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DebugMarkerObjectTagInfo) Deref() {
	if x.refa41a5c3b == nil {
		return
	}
	x.SType = (StructureType)(x.refa41a5c3b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa41a5c3b.pNext))
	x.ObjectType = (DebugReportObjectType)(x.refa41a5c3b.objectType)
	x.Object = (uint64)(x.refa41a5c3b.object)
	x.TagName = (uint64)(x.refa41a5c3b.tagName)
	x.TagSize = (uint)(x.refa41a5c3b.tagSize)
	x.PTag = (unsafe.Pointer)(unsafe.Pointer(x.refa41a5c3b.pTag))
}

// allocDebugMarkerMarkerInfoMemory allocates memory for type C.VkDebugMarkerMarkerInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerMarkerInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerMarkerInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugMarkerMarkerInfoValue = unsafe.Sizeof([1]C.VkDebugMarkerMarkerInfoEXT{})

// Ref returns a reference.
func (x *DebugMarkerMarkerInfo) Ref() *C.VkDebugMarkerMarkerInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref234b91fd
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DebugMarkerMarkerInfo) Free() {
	if x != nil && x.allocs234b91fd != nil {
		x.allocs234b91fd.(*cgoAllocMap).Free()
		x.ref234b91fd = nil
	}
}

// NewDebugMarkerMarkerInfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewDebugMarkerMarkerInfoRef(ref interface{}) *DebugMarkerMarkerInfo {
	if ref == nil {
		return nil
	}
	type ifaceHeader struct {
		_   uintptr
		Ref uintptr
	}
	hdr := (*(*ifaceHeader)(unsafe.Pointer(&ref)))
	obj := new(DebugMarkerMarkerInfo)
	obj.ref234b91fd = (*C.VkDebugMarkerMarkerInfoEXT)(unsafe.Pointer(hdr.Ref))
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DebugMarkerMarkerInfo) PassRef() (*C.VkDebugMarkerMarkerInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref234b91fd != nil {
		return x.ref234b91fd, nil
	}
	mem234b91fd := allocDebugMarkerMarkerInfoMemory(1)
	ref234b91fd := (*C.VkDebugMarkerMarkerInfoEXT)(mem234b91fd)
	allocs234b91fd := new(cgoAllocMap)
	var csType_allocs *cgoAllocMap
	ref234b91fd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs234b91fd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref234b91fd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs234b91fd.Borrow(cpNext_allocs)

	var cpMarkerName_allocs *cgoAllocMap
	ref234b91fd.pMarkerName, cpMarkerName_allocs = unpackPCharString(x.PMarkerName)
	allocs234b91fd.Borrow(cpMarkerName_allocs)

	var ccolor_allocs *cgoAllocMap
	ref234b91fd.color, ccolor_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Color)), cgoAllocsUnknown
	allocs234b91fd.Borrow(ccolor_allocs)

	x.ref234b91fd = ref234b91fd
	x.allocs234b91fd = allocs234b91fd
	return ref234b91fd, allocs234b91fd

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x DebugMarkerMarkerInfo) PassValue() (C.VkDebugMarkerMarkerInfoEXT, *cgoAllocMap) {
	if x.ref234b91fd != nil {
		return *x.ref234b91fd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DebugMarkerMarkerInfo) Deref() {
	if x.ref234b91fd == nil {
		return
	}
	x.SType = (StructureType)(x.ref234b91fd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref234b91fd.pNext))
	x.PMarkerName = packPCharString(x.ref234b91fd.pMarkerName)
	x.Color = *(*[4]float32)(unsafe.Pointer(&x.ref234b91fd.color))
}

// Ref returns a reference.
func (x *ANativeWindow) Ref() *C.ANativeWindow {
	if x == nil {
		return nil
	}
	return (*C.ANativeWindow)(unsafe.Pointer(x))
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ANativeWindow) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewANativeWindowRef initialises a new struct.
func NewANativeWindowRef(ref *C.ANativeWindow) *ANativeWindow {
	return (*ANativeWindow)(unsafe.Pointer(ref))
}

// PassRef returns a reference and creates new object if no refernce yet.
func (x *ANativeWindow) PassRef() *C.ANativeWindow {
	if x == nil {
		x = new(ANativeWindow)
	}
	return (*C.ANativeWindow)(unsafe.Pointer(x))
}

// unpackArgSQueueFamilyProperties transforms a sliced Go data structure into plain C format.
func unpackArgSQueueFamilyProperties(x []QueueFamilyProperties) (unpacked *C.VkQueueFamilyProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkQueueFamilyProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocQueueFamilyPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkQueueFamilyProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkQueueFamilyProperties)(unsafe.Pointer(h.Data))
	return
}

// packSQueueFamilyProperties reads sliced Go data structure out from plain C format.
func packSQueueFamilyProperties(v []QueueFamilyProperties, ptr0 *C.VkQueueFamilyProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfQueueFamilyPropertiesValue]C.VkQueueFamilyProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewQueueFamilyPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSExtensionProperties transforms a sliced Go data structure into plain C format.
func unpackArgSExtensionProperties(x []ExtensionProperties) (unpacked *C.VkExtensionProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkExtensionProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocExtensionPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkExtensionProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkExtensionProperties)(unsafe.Pointer(h.Data))
	return
}

// packSExtensionProperties reads sliced Go data structure out from plain C format.
func packSExtensionProperties(v []ExtensionProperties, ptr0 *C.VkExtensionProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfExtensionPropertiesValue]C.VkExtensionProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewExtensionPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSLayerProperties transforms a sliced Go data structure into plain C format.
func unpackArgSLayerProperties(x []LayerProperties) (unpacked *C.VkLayerProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkLayerProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocLayerPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkLayerProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkLayerProperties)(unsafe.Pointer(h.Data))
	return
}

// packSLayerProperties reads sliced Go data structure out from plain C format.
func packSLayerProperties(v []LayerProperties, ptr0 *C.VkLayerProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfLayerPropertiesValue]C.VkLayerProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewLayerPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSubmitInfo transforms a sliced Go data structure into plain C format.
func unpackArgSSubmitInfo(x []SubmitInfo) (unpacked *C.VkSubmitInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubmitInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubmitInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubmitInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubmitInfo)(unsafe.Pointer(h.Data))
	return
}

// packSSubmitInfo reads sliced Go data structure out from plain C format.
func packSSubmitInfo(v []SubmitInfo, ptr0 *C.VkSubmitInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubmitInfoValue]C.VkSubmitInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubmitInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMappedMemoryRange transforms a sliced Go data structure into plain C format.
func unpackArgSMappedMemoryRange(x []MappedMemoryRange) (unpacked *C.VkMappedMemoryRange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkMappedMemoryRange) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMappedMemoryRangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMappedMemoryRange)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMappedMemoryRange)(unsafe.Pointer(h.Data))
	return
}

// packSMappedMemoryRange reads sliced Go data structure out from plain C format.
func packSMappedMemoryRange(v []MappedMemoryRange, ptr0 *C.VkMappedMemoryRange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMappedMemoryRangeValue]C.VkMappedMemoryRange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMappedMemoryRangeRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSparseImageMemoryRequirements transforms a sliced Go data structure into plain C format.
func unpackArgSSparseImageMemoryRequirements(x []SparseImageMemoryRequirements) (unpacked *C.VkSparseImageMemoryRequirements, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageMemoryRequirements) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryRequirementsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryRequirements)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryRequirements)(unsafe.Pointer(h.Data))
	return
}

// packSSparseImageMemoryRequirements reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryRequirements(v []SparseImageMemoryRequirements, ptr0 *C.VkSparseImageMemoryRequirements) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryRequirementsValue]C.VkSparseImageMemoryRequirements)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryRequirementsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSparseImageFormatProperties transforms a sliced Go data structure into plain C format.
func unpackArgSSparseImageFormatProperties(x []SparseImageFormatProperties) (unpacked *C.VkSparseImageFormatProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageFormatProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageFormatPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageFormatProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageFormatProperties)(unsafe.Pointer(h.Data))
	return
}

// packSSparseImageFormatProperties reads sliced Go data structure out from plain C format.
func packSSparseImageFormatProperties(v []SparseImageFormatProperties, ptr0 *C.VkSparseImageFormatProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageFormatPropertiesValue]C.VkSparseImageFormatProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageFormatPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBindSparseInfo transforms a sliced Go data structure into plain C format.
func unpackArgSBindSparseInfo(x []BindSparseInfo) (unpacked *C.VkBindSparseInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBindSparseInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBindSparseInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBindSparseInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBindSparseInfo)(unsafe.Pointer(h.Data))
	return
}

// packSBindSparseInfo reads sliced Go data structure out from plain C format.
func packSBindSparseInfo(v []BindSparseInfo, ptr0 *C.VkBindSparseInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBindSparseInfoValue]C.VkBindSparseInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBindSparseInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSGraphicsPipelineCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSGraphicsPipelineCreateInfo(x []GraphicsPipelineCreateInfo) (unpacked *C.VkGraphicsPipelineCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkGraphicsPipelineCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocGraphicsPipelineCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// packSGraphicsPipelineCreateInfo reads sliced Go data structure out from plain C format.
func packSGraphicsPipelineCreateInfo(v []GraphicsPipelineCreateInfo, ptr0 *C.VkGraphicsPipelineCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfGraphicsPipelineCreateInfoValue]C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewGraphicsPipelineCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSComputePipelineCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSComputePipelineCreateInfo(x []ComputePipelineCreateInfo) (unpacked *C.VkComputePipelineCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkComputePipelineCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocComputePipelineCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkComputePipelineCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkComputePipelineCreateInfo)(unsafe.Pointer(h.Data))
	return
}

// packSComputePipelineCreateInfo reads sliced Go data structure out from plain C format.
func packSComputePipelineCreateInfo(v []ComputePipelineCreateInfo, ptr0 *C.VkComputePipelineCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfComputePipelineCreateInfoValue]C.VkComputePipelineCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewComputePipelineCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSWriteDescriptorSet transforms a sliced Go data structure into plain C format.
func unpackArgSWriteDescriptorSet(x []WriteDescriptorSet) (unpacked *C.VkWriteDescriptorSet, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkWriteDescriptorSet) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocWriteDescriptorSetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkWriteDescriptorSet)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkWriteDescriptorSet)(unsafe.Pointer(h.Data))
	return
}

// packSWriteDescriptorSet reads sliced Go data structure out from plain C format.
func packSWriteDescriptorSet(v []WriteDescriptorSet, ptr0 *C.VkWriteDescriptorSet) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfWriteDescriptorSetValue]C.VkWriteDescriptorSet)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewWriteDescriptorSetRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCopyDescriptorSet transforms a sliced Go data structure into plain C format.
func unpackArgSCopyDescriptorSet(x []CopyDescriptorSet) (unpacked *C.VkCopyDescriptorSet, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkCopyDescriptorSet) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCopyDescriptorSetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCopyDescriptorSet)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCopyDescriptorSet)(unsafe.Pointer(h.Data))
	return
}

// packSCopyDescriptorSet reads sliced Go data structure out from plain C format.
func packSCopyDescriptorSet(v []CopyDescriptorSet, ptr0 *C.VkCopyDescriptorSet) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCopyDescriptorSetValue]C.VkCopyDescriptorSet)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCopyDescriptorSetRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSViewport transforms a sliced Go data structure into plain C format.
func unpackArgSViewport(x []Viewport) (unpacked *C.VkViewport, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkViewport) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocViewportMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewport)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewport)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSRect2D transforms a sliced Go data structure into plain C format.
func unpackArgSRect2D(x []Rect2D) (unpacked *C.VkRect2D, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkRect2D) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRect2DMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRect2D)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRect2D)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSBufferCopy transforms a sliced Go data structure into plain C format.
func unpackArgSBufferCopy(x []BufferCopy) (unpacked *C.VkBufferCopy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBufferCopy) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBufferCopyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferCopy)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferCopy)(unsafe.Pointer(h.Data))
	return
}

// packSBufferCopy reads sliced Go data structure out from plain C format.
func packSBufferCopy(v []BufferCopy, ptr0 *C.VkBufferCopy) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferCopyValue]C.VkBufferCopy)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferCopyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageCopy transforms a sliced Go data structure into plain C format.
func unpackArgSImageCopy(x []ImageCopy) (unpacked *C.VkImageCopy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageCopy) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageCopyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageCopy)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageCopy)(unsafe.Pointer(h.Data))
	return
}

// packSImageCopy reads sliced Go data structure out from plain C format.
func packSImageCopy(v []ImageCopy, ptr0 *C.VkImageCopy) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageCopyValue]C.VkImageCopy)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageCopyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageBlit transforms a sliced Go data structure into plain C format.
func unpackArgSImageBlit(x []ImageBlit) (unpacked *C.VkImageBlit, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageBlit) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageBlitMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageBlit)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageBlit)(unsafe.Pointer(h.Data))
	return
}

// packSImageBlit reads sliced Go data structure out from plain C format.
func packSImageBlit(v []ImageBlit, ptr0 *C.VkImageBlit) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageBlitValue]C.VkImageBlit)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageBlitRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBufferImageCopy transforms a sliced Go data structure into plain C format.
func unpackArgSBufferImageCopy(x []BufferImageCopy) (unpacked *C.VkBufferImageCopy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBufferImageCopy) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBufferImageCopyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferImageCopy)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferImageCopy)(unsafe.Pointer(h.Data))
	return
}

// packSBufferImageCopy reads sliced Go data structure out from plain C format.
func packSBufferImageCopy(v []BufferImageCopy, ptr0 *C.VkBufferImageCopy) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferImageCopyValue]C.VkBufferImageCopy)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferImageCopyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageSubresourceRange transforms a sliced Go data structure into plain C format.
func unpackArgSImageSubresourceRange(x []ImageSubresourceRange) (unpacked *C.VkImageSubresourceRange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageSubresourceRange) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageSubresourceRangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageSubresourceRange)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageSubresourceRange)(unsafe.Pointer(h.Data))
	return
}

// packSImageSubresourceRange reads sliced Go data structure out from plain C format.
func packSImageSubresourceRange(v []ImageSubresourceRange, ptr0 *C.VkImageSubresourceRange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageSubresourceRangeValue]C.VkImageSubresourceRange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageSubresourceRangeRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSClearAttachment transforms a sliced Go data structure into plain C format.
func unpackArgSClearAttachment(x []ClearAttachment) (unpacked *C.VkClearAttachment, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkClearAttachment) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocClearAttachmentMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkClearAttachment)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkClearAttachment)(unsafe.Pointer(h.Data))
	return
}

// packSClearAttachment reads sliced Go data structure out from plain C format.
func packSClearAttachment(v []ClearAttachment, ptr0 *C.VkClearAttachment) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfClearAttachmentValue]C.VkClearAttachment)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewClearAttachmentRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSClearRect transforms a sliced Go data structure into plain C format.
func unpackArgSClearRect(x []ClearRect) (unpacked *C.VkClearRect, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkClearRect) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocClearRectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkClearRect)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkClearRect)(unsafe.Pointer(h.Data))
	return
}

// packSClearRect reads sliced Go data structure out from plain C format.
func packSClearRect(v []ClearRect, ptr0 *C.VkClearRect) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfClearRectValue]C.VkClearRect)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewClearRectRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageResolve transforms a sliced Go data structure into plain C format.
func unpackArgSImageResolve(x []ImageResolve) (unpacked *C.VkImageResolve, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageResolve) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageResolveMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageResolve)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageResolve)(unsafe.Pointer(h.Data))
	return
}

// packSImageResolve reads sliced Go data structure out from plain C format.
func packSImageResolve(v []ImageResolve, ptr0 *C.VkImageResolve) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageResolveValue]C.VkImageResolve)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageResolveRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMemoryBarrier transforms a sliced Go data structure into plain C format.
func unpackArgSMemoryBarrier(x []MemoryBarrier) (unpacked *C.VkMemoryBarrier, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkMemoryBarrier) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMemoryBarrierMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMemoryBarrier)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMemoryBarrier)(unsafe.Pointer(h.Data))
	return
}

// packSMemoryBarrier reads sliced Go data structure out from plain C format.
func packSMemoryBarrier(v []MemoryBarrier, ptr0 *C.VkMemoryBarrier) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMemoryBarrierValue]C.VkMemoryBarrier)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMemoryBarrierRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBufferMemoryBarrier transforms a sliced Go data structure into plain C format.
func unpackArgSBufferMemoryBarrier(x []BufferMemoryBarrier) (unpacked *C.VkBufferMemoryBarrier, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBufferMemoryBarrier) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBufferMemoryBarrierMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferMemoryBarrier)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferMemoryBarrier)(unsafe.Pointer(h.Data))
	return
}

// packSBufferMemoryBarrier reads sliced Go data structure out from plain C format.
func packSBufferMemoryBarrier(v []BufferMemoryBarrier, ptr0 *C.VkBufferMemoryBarrier) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferMemoryBarrierValue]C.VkBufferMemoryBarrier)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferMemoryBarrierRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageMemoryBarrier transforms a sliced Go data structure into plain C format.
func unpackArgSImageMemoryBarrier(x []ImageMemoryBarrier) (unpacked *C.VkImageMemoryBarrier, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageMemoryBarrier) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageMemoryBarrierMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageMemoryBarrier)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageMemoryBarrier)(unsafe.Pointer(h.Data))
	return
}

// packSImageMemoryBarrier reads sliced Go data structure out from plain C format.
func packSImageMemoryBarrier(v []ImageMemoryBarrier, ptr0 *C.VkImageMemoryBarrier) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageMemoryBarrierValue]C.VkImageMemoryBarrier)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageMemoryBarrierRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSurfaceFormat transforms a sliced Go data structure into plain C format.
func unpackArgSSurfaceFormat(x []SurfaceFormat) (unpacked *C.VkSurfaceFormatKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSurfaceFormatKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSurfaceFormatMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSurfaceFormatKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSurfaceFormatKHR)(unsafe.Pointer(h.Data))
	return
}

// packSSurfaceFormat reads sliced Go data structure out from plain C format.
func packSSurfaceFormat(v []SurfaceFormat, ptr0 *C.VkSurfaceFormatKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSurfaceFormatValue]C.VkSurfaceFormatKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSurfaceFormatRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayProperties transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayProperties(x []DisplayProperties) (unpacked *C.VkDisplayPropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayPropertiesKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayPropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayPropertiesKHR)(unsafe.Pointer(h.Data))
	return
}

// packSDisplayProperties reads sliced Go data structure out from plain C format.
func packSDisplayProperties(v []DisplayProperties, ptr0 *C.VkDisplayPropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPropertiesValue]C.VkDisplayPropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayPlaneProperties transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayPlaneProperties(x []DisplayPlaneProperties) (unpacked *C.VkDisplayPlanePropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayPlanePropertiesKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayPlanePropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(h.Data))
	return
}

// packSDisplayPlaneProperties reads sliced Go data structure out from plain C format.
func packSDisplayPlaneProperties(v []DisplayPlaneProperties, ptr0 *C.VkDisplayPlanePropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPlanePropertiesValue]C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPlanePropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayModeProperties transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayModeProperties(x []DisplayModeProperties) (unpacked *C.VkDisplayModePropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayModePropertiesKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayModePropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayModePropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayModePropertiesKHR)(unsafe.Pointer(h.Data))
	return
}

// packSDisplayModeProperties reads sliced Go data structure out from plain C format.
func packSDisplayModeProperties(v []DisplayModeProperties, ptr0 *C.VkDisplayModePropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayModePropertiesValue]C.VkDisplayModePropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayModePropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSwapchainCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSSwapchainCreateInfo(x []SwapchainCreateInfo) (unpacked *C.VkSwapchainCreateInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSwapchainCreateInfoKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSwapchainCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(h.Data))
	return
}

// packSSwapchainCreateInfo reads sliced Go data structure out from plain C format.
func packSSwapchainCreateInfo(v []SwapchainCreateInfo, ptr0 *C.VkSwapchainCreateInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSwapchainCreateInfoValue]C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSwapchainCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}
